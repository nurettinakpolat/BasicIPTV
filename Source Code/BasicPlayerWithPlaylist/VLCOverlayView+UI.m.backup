#import "VLCOverlayView+UI.h"
#import "VLCOverlayView_Private.h"
#import "VLCOverlayView+PlayerControls.h"
#import "VLCSubtitleSettings.h"
#import <objc/runtime.h>
#import "VLCOverlayView+Utilities.h"
#import <math.h>
#import "VLCSliderControl.h"

// Constants for slider types
#define SLIDER_TYPE_NONE 0
#define SLIDER_TYPE_TRANSPARENCY 1
#define SLIDER_TYPE_RED 2
#define SLIDER_TYPE_GREEN 3
#define SLIDER_TYPE_BLUE 4
#define SLIDER_TYPE_SUBTITLE 5

// Global variable to track menu fade-out state
BOOL isFadingOut = NO;

// Add this variable at the top near the other globals
// Add this right after the "BOOL isFadingOut = NO;" line
NSTimeInterval lastFadeOutTime = 0;

// Add timer for auto-hiding player controls
NSTimer *playerControlsTimer = nil;
BOOL playerControlsVisible = NO; // Start with controls hidden

@implementation VLCOverlayView (UI)

// Need to add these properties for the new grid view feature
BOOL isGridViewActive = NO;
NSMutableDictionary *gridLoadingQueue = nil;
NSOperationQueue *coverDownloadQueue = nil;

// Add properties to track hover state across panels
BOOL isPersistingHoverState = NO;
NSInteger lastValidHoveredChannelIndex = -1;
NSInteger lastValidHoveredGroupIndex = -1;

// Add property to track the active slider
NSInteger activeSliderType = SLIDER_TYPE_NONE;

// Add properties for view mode cycling
NSInteger currentViewMode = 0; // 0 = Stacked, 1 = Grid, 2 = List
BOOL isStackedViewActive = YES; // Start with stacked view

// Remove conflicting global variables - use the properties instead defined in the header file
// CGFloat customSelectionRed = 0.2;
// CGFloat customSelectionGreen = 0.4;
// CGFloat customSelectionBlue = 0.9;

#pragma mark - UI Setup

- (void)setupTrackingArea {
    // Remove existing tracking area
    if (trackingArea) {
        [self removeTrackingArea:trackingArea];
        [trackingArea release];
    }
    
    // Create a new tracking area covering the entire view with better tracking options
    NSTrackingAreaOptions options = (NSTrackingMouseMoved | 
                                    NSTrackingMouseEnteredAndExited | 
                                    NSTrackingActiveInKeyWindow |
                                    NSTrackingAssumeInside |      // Assume mouse is inside when view is first shown
                                    NSTrackingInVisibleRect |     // Update tracking rect automatically when view changes
                                    NSTrackingEnabledDuringMouseDrag); // Track even during drag operations
    
    trackingArea = [[NSTrackingArea alloc] initWithRect:[self bounds]
                                                options:options
                                                  owner:self
                                               userInfo:nil];
    [self addTrackingArea:trackingArea];
    
    // Log that we're setting up tracking
    //NSLog(@"Setup tracking area with rect: %@", NSStringFromRect([self bounds]));
    
    // Reset interaction timer
    [self markUserInteraction];
    
    // Initialize grid loading queue if needed
    if (!gridLoadingQueue) {
        gridLoadingQueue = [[NSMutableDictionary alloc] init];
    }
    
    // Initialize download queue if needed
    if (!coverDownloadQueue) {
        coverDownloadQueue = [[NSOperationQueue alloc] init];
        [coverDownloadQueue setMaxConcurrentOperationCount:8]; // Allow 8 concurrent downloads
    }
}

#pragma mark - Drawing Methods

// Helper method to get category icons using SF Symbols
- (NSImage *)iconForCategory:(NSString *)category {
    NSImage *icon = nil;
    NSString *symbolName = nil;
    
    if ([category isEqualToString:@"SEARCH"]) {
        symbolName = @"magnifyingglass";
    } else if ([category isEqualToString:@"FAVORITES"]) {
        symbolName = @"heart.fill";
    } else if ([category isEqualToString:@"TV"]) {
        symbolName = @"tv";
    } else if ([category isEqualToString:@"MOVIES"]) {
        symbolName = @"film";
    } else if ([category isEqualToString:@"SERIES"]) {
        symbolName = @"play.tv";
    } else if ([category isEqualToString:@"SETTINGS"]) {
        symbolName = @"gearshape";
    }
    
    if (symbolName) {
        // Try to use SF Symbols if available (macOS 11+)
        if (@available(macOS 11.0, *)) {
            icon = [NSImage imageWithSystemSymbolName:symbolName accessibilityDescription:nil];
            
            // Configure the icon size
            if (icon) {
                [icon setSize:NSMakeSize(16, 16)];
                
                // Create a white tinted version of the icon
                NSImage *tintedIcon = [[NSImage alloc] initWithSize:NSMakeSize(16, 16)];
                [tintedIcon lockFocus];
                
                // Set white color for the icon
                [[NSColor colorWithCalibratedWhite:0.95 alpha:1.0] set];
                
                // Draw the icon as a template
                NSRect iconRect = NSMakeRect(0, 0, 16, 16);
                [icon drawInRect:iconRect fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0];
                
                // Apply the white tint using source atop
                NSRectFillUsingOperation(iconRect, NSCompositeSourceAtop);
                
                [tintedIcon unlockFocus];
                
                return [tintedIcon autorelease];
            }
        } else {
            // Fallback to creating simple icons for older macOS versions
            icon = [self createFallbackIconForCategory:category];
        }
    }
    
    return icon;
}

// Fallback method to create simple icons for older macOS versions
- (NSImage *)createFallbackIconForCategory:(NSString *)category {
    NSImage *icon = [[NSImage alloc] initWithSize:NSMakeSize(16, 16)];
    [icon lockFocus];
    
    // Set the drawing context
    NSGraphicsContext *context = [NSGraphicsContext currentContext];
    [context saveGraphicsState];
    
    // Create a simple colored circle with a symbol
    NSRect iconRect = NSMakeRect(1, 1, 14, 14);
    NSBezierPath *circlePath = [NSBezierPath bezierPathWithOvalInRect:iconRect];
    
    // Set different colors for different categories
    if ([category isEqualToString:@"SEARCH"]) {
        [[NSColor colorWithCalibratedRed:0.3 green:0.7 blue:1.0 alpha:1.0] set];
    } else if ([category isEqualToString:@"FAVORITES"]) {
        [[NSColor colorWithCalibratedRed:1.0 green:0.4 blue:0.4 alpha:1.0] set];
    } else if ([category isEqualToString:@"TV"]) {
        [[NSColor colorWithCalibratedRed:0.4 green:0.8 blue:0.4 alpha:1.0] set];
    } else if ([category isEqualToString:@"MOVIES"]) {
        [[NSColor colorWithCalibratedRed:1.0 green:0.7 blue:0.3 alpha:1.0] set];
    } else if ([category isEqualToString:@"SERIES"]) {
        [[NSColor colorWithCalibratedRed:0.8 green:0.4 blue:1.0 alpha:1.0] set];
    } else if ([category isEqualToString:@"SETTINGS"]) {
        [[NSColor colorWithCalibratedRed:0.7 green:0.7 blue:0.7 alpha:1.0] set];
    } else {
        [[NSColor colorWithCalibratedRed:0.6 green:0.6 blue:0.6 alpha:1.0] set];
    }
    
    [circlePath fill];
    
    // Add a subtle border
    [[NSColor colorWithCalibratedWhite:1.0 alpha:0.3] set];
    [circlePath setLineWidth:0.5];
    [circlePath stroke];
    
    // Add a simple white symbol in the center
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *attrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:9],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSString *symbolChar = @"?";
    if ([category isEqualToString:@"SEARCH"]) {
        symbolChar = @"üîç";
    } else if ([category isEqualToString:@"FAVORITES"]) {
        symbolChar = @"‚ô•";
    } else if ([category isEqualToString:@"TV"]) {
        symbolChar = @"üì∫";
    } else if ([category isEqualToString:@"MOVIES"]) {
        symbolChar = @"üé¨";
    } else if ([category isEqualToString:@"SERIES"]) {
        symbolChar = @"üì∫";
    } else if ([category isEqualToString:@"SETTINGS"]) {
        symbolChar = @"‚öô";
    }
    
    // For better looking fallback icons, use simple letters instead of emoji
    if ([category isEqualToString:@"SEARCH"]) {
        symbolChar = @"S";
    } else if ([category isEqualToString:@"FAVORITES"]) {
        symbolChar = @"‚ô•";
    } else if ([category isEqualToString:@"TV"]) {
        symbolChar = @"T";
    } else if ([category isEqualToString:@"MOVIES"]) {
        symbolChar = @"M";
    } else if ([category isEqualToString:@"SERIES"]) {
        symbolChar = @"S";
    } else if ([category isEqualToString:@"SETTINGS"]) {
        symbolChar = @"‚öô";
    }
    
    NSRect textRect = NSMakeRect(0, 2, 16, 12);
    [symbolChar drawInRect:textRect withAttributes:attrs];
    
    [style release];
    [context restoreGraphicsState];
    [icon unlockFocus];
    
    return [icon autorelease];
}

- (void)drawCategories:(NSRect)rect {
    CGFloat catWidth = 200;
    
    // Draw background with modern gradient
    NSRect menuRect = NSMakeRect(0, 0, catWidth, self.bounds.size.height);
    NSGradient *backgroundGradient = [[NSGradient alloc] initWithStartingColor:self.themeCategoryStartColor ? self.themeCategoryStartColor : [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.75]
                                                                   endingColor:self.themeCategoryEndColor ? self.themeCategoryEndColor : [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.75]];
    [backgroundGradient drawInRect:menuRect angle:90];
    [backgroundGradient release];
    
    // Calculate total height for scroll bar
    CGFloat rowHeight = 40;
    CGFloat totalCategoriesHeight = [self.categories count] * rowHeight;
    
    // Draw each category with modern styling and icons
    for (NSInteger i = 0; i < [self.categories count]; i++) {
        NSRect itemRect = NSMakeRect(0, 
                                     self.bounds.size.height - ((i+1) * rowHeight) + categoryScrollPosition, 
                                     catWidth, 
                                     rowHeight);
        
        // Skip drawing if not visible
        if (!NSIntersectsRect(itemRect, rect)) {
            continue;
        }
        
        // Draw selection/hover background with rounded corners
        if (i == self.selectedCategoryIndex) {
            NSBezierPath *selectionPath = [NSBezierPath bezierPathWithRoundedRect:
                                         NSInsetRect(itemRect, 4, 2)
                                                                         xRadius:6
                                                                         yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.3] set];
            [selectionPath fill];
            
            // Add subtle highlight
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.2] set];
            [selectionPath stroke];
        } else if (i == self.hoveredCategoryIndex) {
            // Hover state - lighter version of selection
            NSBezierPath *hoverPath = [NSBezierPath bezierPathWithRoundedRect:
                                     NSInsetRect(itemRect, 4, 2)
                                                                     xRadius:6
                                                                     yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.25] set]; // Increased alpha from 0.15
            [hoverPath fill];
            
            // Add subtle highlight
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.15] set]; // Increased stroke alpha from 0.1
            [hoverPath stroke];
        }
        
        // Get category name and icon
        NSString *category = [self.categories objectAtIndex:i];
        NSImage *categoryIcon = [self iconForCategory:category];
        
        // Calculate icon and text positions
        CGFloat iconSize = 16;
        CGFloat iconPadding = 12;
        CGFloat textLeftMargin = iconPadding + iconSize + 8; // Icon + spacing
        
        // Draw icon if available
        if (categoryIcon) {
            NSRect iconRect = NSMakeRect(
                itemRect.origin.x + iconPadding,
                itemRect.origin.y + (itemRect.size.height - iconSize) / 2,
                iconSize,
                iconSize
            );
            
            // Tint the icon to match the text color
            [categoryIcon drawInRect:iconRect 
                            fromRect:NSZeroRect 
                           operation:NSCompositeSourceOver 
                            fraction:0.9];
        }
        
        // Draw the category name with shadow
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentLeft];
        
        NSDictionary *shadowDict = @{
            NSShadowAttributeName: ({
                NSShadow *shadow = [[NSShadow alloc] init];
                shadow.shadowColor = [NSColor colorWithCalibratedWhite:0.0 alpha:0.3];
                shadow.shadowOffset = NSMakeSize(0, -1);
                shadow.shadowBlurRadius = 2;
                shadow;
            })
        };
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:13 weight:NSFontWeightMedium],
            NSForegroundColorAttributeName: [NSColor colorWithCalibratedWhite:0.95 alpha:1.0],
            NSParagraphStyleAttributeName: style,
            NSShadowAttributeName: shadowDict[NSShadowAttributeName]
        };
        
        NSRect textRect = NSMakeRect(itemRect.origin.x + textLeftMargin,
                                   itemRect.origin.y + (itemRect.size.height - 16) / 2,
                                   itemRect.size.width - textLeftMargin - 16,
                                   16);
        
        [category drawInRect:textRect withAttributes:attrs];
        
        [style release];
        [shadowDict[NSShadowAttributeName] release];
    }
    
    // Draw scroll bar if needed
    [self drawScrollBar:menuRect contentHeight:totalCategoriesHeight scrollPosition:categoryScrollPosition];
}

- (void)drawGroups:(NSRect)rect {
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat rowHeight = 40;
    
    // Draw background with modern gradient
    NSRect menuRect = NSMakeRect(catWidth, 0, groupWidth, self.bounds.size.height);
    NSGradient *backgroundGradient = [[NSGradient alloc] initWithStartingColor:self.themeGroupStartColor ? self.themeGroupStartColor : [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.75]
                                                                   endingColor:self.themeGroupEndColor ? self.themeGroupEndColor : [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.75]];
    [backgroundGradient drawInRect:menuRect angle:90];
    [backgroundGradient release];
    
    // Get appropriate groups based on selected category
    NSArray *groups = nil;
    if (self.selectedCategoryIndex == CATEGORY_SEARCH) {
        // When Search is selected, show search textbox instead of groups
        [self drawSearchInterface:rect menuRect:menuRect];
        return;
    } else if (self.selectedCategoryIndex == CATEGORY_FAVORITES) {
        groups = [self safeGroupsForCategory:@"FAVORITES"];
    } else if (self.selectedCategoryIndex == CATEGORY_TV) {
        groups = [self safeTVGroups];
    } else if (self.selectedCategoryIndex == CATEGORY_MOVIES) {
        groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
    } else if (self.selectedCategoryIndex == CATEGORY_SERIES) {
        groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
    } else if (self.selectedCategoryIndex == CATEGORY_SETTINGS) {
        groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    }
    
    if (!groups) return;
        
    // Draw each group with modern styling
    for (NSInteger i = 0; i < [groups count]; i++) {
        NSRect itemRect = NSMakeRect(catWidth, 
                                   self.bounds.size.height - ((i+1) * rowHeight) + groupScrollPosition,
                                     groupWidth, 
                                     rowHeight);
        
        if (!NSIntersectsRect(itemRect, rect)) continue;
        
        NSString *group = [groups objectAtIndex:i];
        
        // Draw selection/hover background
        if (i == self.selectedGroupIndex) {
            NSBezierPath *selectionPath = [NSBezierPath bezierPathWithRoundedRect:
                                         NSInsetRect(itemRect, 4, 2)
                                                                         xRadius:6
                                                                         yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.3] set];
            [selectionPath fill];
            
            // Add subtle highlight
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.2] set];
            [selectionPath stroke];
        } else if (i == self.hoveredGroupIndex) {
            // Hover state - lighter version of selection
            NSBezierPath *hoverPath = [NSBezierPath bezierPathWithRoundedRect:
                                     NSInsetRect(itemRect, 4, 2)
                                                                     xRadius:6
                                                                     yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.25] set]; // Increased alpha from 0.15
            [hoverPath fill];
        
            // Add subtle highlight
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.15] set]; // Increased stroke alpha from 0.1
            [hoverPath stroke];
        }
        
        // Draw group name with shadow
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentLeft];
        
        NSShadow *shadow = [[NSShadow alloc] init];
        shadow.shadowColor = [NSColor colorWithCalibratedWhite:0.0 alpha:0.3];
        shadow.shadowOffset = NSMakeSize(0, -1);
        shadow.shadowBlurRadius = 2;
        
        // Get channel count for this group
        NSArray *channelsInGroup = [self.channelsByGroup objectForKey:group];
        NSString *displayText;
        
        // Only show count for non-settings categories
        if (self.selectedCategoryIndex == CATEGORY_SETTINGS) {
            // For settings, just show the group name without count
            displayText = group;
        } else {
            // For other categories (TV, MOVIES, etc.), show count
            displayText = [NSString stringWithFormat:@"%@ (%ld)", 
                          group, 
                          (long)[channelsInGroup count]];
        }
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:13 weight:NSFontWeightRegular],
            NSForegroundColorAttributeName: [NSColor colorWithCalibratedWhite:0.95 alpha:1.0],
            NSParagraphStyleAttributeName: style,
            NSShadowAttributeName: shadow
        };
        
        NSRect textRect = NSMakeRect(itemRect.origin.x + 16,
                                        itemRect.origin.y + (itemRect.size.height - 16) / 2, 
                                   itemRect.size.width - 32,
                                   16);
        
        [displayText drawInRect:textRect withAttributes:attrs];
        
        [style release];
        [shadow release];
    }
}

- (void)drawSearchInterface:(NSRect)rect menuRect:(NSRect)menuRect {
    // Calculate textbox position
    CGFloat padding = 20;
    CGFloat textboxHeight = 35;
    CGFloat textboxY = menuRect.size.height - 80; // Position near top
    
    NSRect searchRect = NSMakeRect(menuRect.origin.x + padding,
                                  textboxY,
                                  menuRect.size.width - (padding * 2),
                                  textboxHeight);
    
    // Only create search textfield if it doesn't exist or if it's not in the superview
    if (!self.searchTextField || ![self.subviews containsObject:self.searchTextField]) {
        // Store previous search value if textfield exists but is not in superview
        NSString *previousSearchValue = nil;
        if (self.searchTextField) {
            previousSearchValue = [self.searchTextField stringValue];
            [self.searchTextField release];
        }
        
        // Create new search textfield
        self.searchTextField = [[VLCReusableTextField alloc] initWithFrame:searchRect identifier:@"search"];
        self.searchTextField.textFieldDelegate = self;
        [self.searchTextField setPlaceholderText:@"Search channels..."];
        
        // Restore previous search value if it existed
        if (previousSearchValue && [previousSearchValue length] > 0) {
            [self.searchTextField setStringValue:previousSearchValue];
        }
        
        // Add to superview
        [self addSubview:self.searchTextField];
    } else {
        // Just update frame if textfield already exists and is in superview
        [self.searchTextField setFrame:searchRect];
    }
    
    // Make sure search textfield is visible and active
    [self.searchTextField setHidden:NO];
    
    // Draw search label
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSRect labelRect = NSMakeRect(searchRect.origin.x, searchRect.origin.y + textboxHeight + 10, 100, 20);
    [@"Search:" drawInRect:labelRect withAttributes:labelAttrs];
    [style release];
}

- (void)performSearch:(NSString *)searchText {
    // Cancel previous timer if running
    if (self.searchTimer) {
        [self.searchTimer invalidate];
        self.searchTimer = nil;
    }
    
    if (!searchText || [searchText length] == 0) {
        // Clear search results immediately if search text is empty
        self.searchResults = [NSMutableArray array];
        self.isSearchActive = NO;
        dispatch_async(dispatch_get_main_queue(), ^{
            [self setNeedsDisplay:YES];
        });
        return;
    }
    
    // Debounce search - wait 300ms after user stops typing
    self.searchTimer = [NSTimer scheduledTimerWithTimeInterval:0.3
                                                        target:self
                                                      selector:@selector(performDelayedSearch:)
                                                      userInfo:@{@"searchText": searchText}
                                                       repeats:NO];
}

- (void)performDelayedSearch:(NSTimer *)timer {
    NSString *searchText = [[timer userInfo] objectForKey:@"searchText"];
    
    // Create search queue if needed
    if (!self.searchQueue) {
        self.searchQueue = dispatch_queue_create("com.vlc.search", DISPATCH_QUEUE_SERIAL);
    }
    
    // Perform search on background thread
    dispatch_async(self.searchQueue, ^{
        NSMutableArray *allResults = [NSMutableArray array];
        NSMutableArray *channelResults = [NSMutableArray array];
        NSMutableArray *movieResults = [NSMutableArray array];
        NSString *lowercaseSearchText = [searchText lowercaseString];
        
        // Search in channels (regular TV channels)
        if (self.channels) {
            for (VLCChannel *channel in self.channels) {
                if ([self channel:channel matchesSearchText:lowercaseSearchText]) {
                    // Check if this is a movie/series or regular channel based on group
                    if (channel.group && 
                        ([[channel.group lowercaseString] containsString:@"movie"] ||
                         [[channel.group lowercaseString] containsString:@"series"] ||
                         [[channel.group lowercaseString] containsString:@"film"] ||
                         [[channel.group lowercaseString] containsString:@"cinema"])) {
                        [movieResults addObject:channel];
                    } else {
                        [channelResults addObject:channel];
                    }
                    [allResults addObject:channel];
                }
            }
        }
        
        // Update UI on main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            self.searchResults = allResults;
            self.searchChannelResults = channelResults;
            self.searchMovieResults = movieResults;
            self.isSearchActive = ([allResults count] > 0 || [searchText length] > 0);
            [self setNeedsDisplay:YES];
        });
    });
}

- (BOOL)channel:(VLCChannel *)channel matchesSearchText:(NSString *)searchText {
    if (!channel || !searchText) return NO;
    
    // Search in channel name
    if (channel.name && [[channel.name lowercaseString] containsString:searchText]) {
        return YES;
    }
    
    // Search in channel group
    if (channel.group && [[channel.group lowercaseString] containsString:searchText]) {
        return YES;
    }
    
    // Search in channel URL (for specific stream names) 
    if (channel.url && [[channel.url lowercaseString] containsString:searchText]) {
        return YES;
    }
    
    return NO;
}

#pragma mark - VLCReusableTextFieldDelegate

- (void)textFieldDidChange:(NSString *)newValue forIdentifier:(NSString *)identifier {
    if ([identifier isEqualToString:@"search"]) {
        [self performSearch:newValue];
    } else if ([identifier isEqualToString:@"m3u"]) {
        // Update M3U file path
        self.m3uFilePath = newValue;
        
        // Auto-generate EPG URL from M3U URL
        NSString *generatedEpgUrl = [self generateEpgUrlFromM3uUrl:newValue];
        if (generatedEpgUrl && [generatedEpgUrl length] > 0) {
            self.epgUrl = generatedEpgUrl;
        }
        
        // Refresh the EPG label display
        [self setNeedsDisplay:YES];
    }
}

- (void)textFieldDidEndEditing:(NSString *)finalValue forIdentifier:(NSString *)identifier {
    if ([identifier isEqualToString:@"search"]) {
        [self performSearch:finalValue];
    } else if ([identifier isEqualToString:@"m3u"]) {
        // Update M3U file path
        self.m3uFilePath = finalValue;
        
        // Auto-generate EPG URL from M3U URL  
        NSString *generatedEpgUrl = [self generateEpgUrlFromM3uUrl:finalValue];
        if (generatedEpgUrl && [generatedEpgUrl length] > 0) {
            self.epgUrl = generatedEpgUrl;
        }
        
        // Save the M3U URL to preferences
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        [defaults setObject:finalValue forKey:@"M3UFilePath"];
        [defaults synchronize];
        
        // Refresh the EPG label display
        [self setNeedsDisplay:YES];
    }
}

- (void)drawChannelList:(NSRect)rect {
    CGFloat rowHeight = 40;
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat channelListX = catWidth + groupWidth;
    
    // Reduce channel list width to make space for program guide on right
    CGFloat programGuideWidth = 400; // Increased width for program guide
    CGFloat channelListWidth = self.bounds.size.width - channelListX - programGuideWidth;
    
    // Draw background using theme colors with gradient
    NSRect menuRect = NSMakeRect(channelListX, 0, channelListWidth, self.bounds.size.height);
    NSGradient *backgroundGradient = [[NSGradient alloc] initWithStartingColor:self.themeChannelStartColor ? self.themeChannelStartColor : [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.7]
                                                                   endingColor:self.themeChannelEndColor ? self.themeChannelEndColor : [NSColor colorWithCalibratedRed:0.12 green:0.14 blue:0.18 alpha:0.7]];
    [backgroundGradient drawInRect:menuRect angle:90];
    [backgroundGradient release];
    
    // Draw program guide background using theme colors (darker version)
    CGFloat programGuideX = channelListX + channelListWidth;
    NSRect programGuideRect = NSMakeRect(programGuideX, 0, programGuideWidth, self.bounds.size.height);
    
    // Use glassmorphism background instead of solid gradient to match the rest of the interface
    [self drawGlassmorphismPanel:programGuideRect opacity:0.6 cornerRadius:0];
    
    // Define the content rect for the channel list
    NSRect contentRect = NSMakeRect(channelListX, 0, channelListWidth, self.bounds.size.height);
    
    // Determine which channels to display
    NSArray *channelNames = nil;
    NSArray *channelUrls = nil;
    
    if (self.selectedCategoryIndex == CATEGORY_SEARCH && self.searchChannelResults && [self.searchChannelResults count] > 0) {
        // Use search channel results
        NSMutableArray *searchNames = [NSMutableArray array];
        NSMutableArray *searchUrls = [NSMutableArray array];
        
        for (VLCChannel *channel in self.searchChannelResults) {
            [searchNames addObject:channel.name ? channel.name : @""];
            [searchUrls addObject:channel.url ? channel.url : @""];
        }
        
        channelNames = searchNames;
        channelUrls = searchUrls;
    } else {
        // Use regular simple channel lists
        channelNames = self.simpleChannelNames;
        channelUrls = self.simpleChannelUrls;
    }
    
    // Calculate total content height
    CGFloat totalContentHeight = [channelNames count] * rowHeight;
    
    // Add extra space at bottom to ensure last item is fully visible when scrolled to the end
    totalContentHeight += rowHeight;
    
    // Update scroll limits to ensure last item is fully visible
    CGFloat maxScroll = MAX(0, totalContentHeight - contentRect.size.height);
    
    // Use appropriate scroll position based on search mode
    CGFloat currentScrollPosition;
    if (self.selectedCategoryIndex == CATEGORY_SEARCH) {
        currentScrollPosition = self.searchChannelScrollPosition;
    } else {
        currentScrollPosition = channelScrollPosition;
    }
    
    CGFloat scrollPosition = MIN(currentScrollPosition, maxScroll);
    
    // Draw each channel - removed header bar completely
    for (NSInteger i = 0; i < [channelNames count]; i++) {
        // Calculate visible position accounting for scroll
        NSInteger visibleIndex = i - (NSInteger)floor(scrollPosition / rowHeight);
        
        // Adjusted positioning to start from top with no header offset
        NSRect itemRect = NSMakeRect(channelListX, 
                                     self.bounds.size.height - ((visibleIndex+1) * rowHeight), 
                                     channelListWidth, 
                                     rowHeight);
        
        // Skip drawing if not visible
        if (!NSIntersectsRect(itemRect, rect)) {
            continue;
        }
        
        // Highlight hovered or selected channel with rounded corners (matching categories/groups style)
        if (i == self.hoveredChannelIndex || i == self.selectedChannelIndex) {
            if (i == self.selectedChannelIndex) {
                // Selected channel - use custom selection color with rounded corners
                NSBezierPath *selectionPath = [NSBezierPath bezierPathWithRoundedRect:
                                             NSInsetRect(itemRect, 4, 2)
                                                                             xRadius:6
                                                                             yRadius:6];
                [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.3] set];
                [selectionPath fill];
                
                // Add subtle highlight border
                [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.2] set];
                [selectionPath stroke];
            } else {
                // Hovered channel - use lighter version (auto-calculated hover color) with rounded corners
                CGFloat blendFactor = 0.5; // Increased from 0.3 for better visibility
                CGFloat hoverRed = self.customSelectionRed + (1.0 - self.customSelectionRed) * blendFactor;
                CGFloat hoverGreen = self.customSelectionGreen + (1.0 - self.customSelectionGreen) * blendFactor;
                CGFloat hoverBlue = self.customSelectionBlue + (1.0 - self.customSelectionBlue) * blendFactor;
                
                NSBezierPath *hoverPath = [NSBezierPath bezierPathWithRoundedRect:
                                         NSInsetRect(itemRect, 4, 2)
                                                                         xRadius:6
                                                                         yRadius:6];
                [[NSColor colorWithCalibratedRed:hoverRed green:hoverGreen blue:hoverBlue alpha:0.25] set]; // Increased alpha from 0.15
                [hoverPath fill];
                
                // Add subtle highlight border
                [[NSColor colorWithCalibratedRed:hoverRed green:hoverGreen blue:hoverBlue alpha:0.15] set]; // Increased stroke alpha from 0.1
                [hoverPath stroke];
            }
        }
        
        // Draw channel name
        NSString *channelName = [channelNames objectAtIndex:i];
        
        [self.textColor set];
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentLeft];
        
        NSDictionary *channelAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        // Channel name takes less space to make room for program info
        NSRect channelTextRect = NSMakeRect(itemRect.origin.x + 10, 
                                     itemRect.origin.y + (itemRect.size.height - 23),
                                     itemRect.size.width - 20,
                                     20);
        
        [channelName drawInRect:channelTextRect withAttributes:channelAttrs];
        
        // Draw timeshift indicator if channel supports catchup (before getting channel object)
        // We need to get the channel object first to check timeshift support
        VLCChannel *tempChannel = nil;
        NSString *tempCurrentGroup = nil;
        NSArray *tempGroups = nil;
        
        // Get current category and group to find the channel
        NSString *tempCurrentCategory = nil;
        if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
            tempCurrentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
            
            // Get the appropriate groups based on category
            if ([tempCurrentCategory isEqualToString:@"FAVORITES"]) {
                tempGroups = [self safeGroupsForCategory:@"FAVORITES"];
            } else if ([tempCurrentCategory isEqualToString:@"TV"]) {
                tempGroups = [self safeTVGroups];
            } else if ([tempCurrentCategory isEqualToString:@"MOVIES"]) {
                tempGroups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
            } else if ([tempCurrentCategory isEqualToString:@"SERIES"]) {
                tempGroups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
            }
            
            // Get the current group
            if (tempGroups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < tempGroups.count) {
                tempCurrentGroup = [tempGroups objectAtIndex:self.selectedGroupIndex];
                
                // Get channels for this group
                NSArray *tempChannelsInGroup = [self.channelsByGroup objectForKey:tempCurrentGroup];
                if (tempChannelsInGroup && i < tempChannelsInGroup.count) {
                    tempChannel = [tempChannelsInGroup objectAtIndex:i];
                }
            }
        }
        
        // Draw timeshift indicator if channel supports catchup
        if (tempChannel && tempChannel.supportsCatchup) {
            NSRect timeshiftIconRect = NSMakeRect(
                itemRect.origin.x + itemRect.size.width - 30, // Position on the right side
                itemRect.origin.y + (itemRect.size.height - 16) / 2 + 8, // Center vertically, slightly down
                16, 
                16
            );
            
            // Draw timeshift icon (clock with arrow)
            [[NSColor colorWithCalibratedRed:0.2 green:0.7 blue:1.0 alpha:0.9] set];
            
            // Draw clock circle
            NSBezierPath *clockCircle = [NSBezierPath bezierPathWithOvalInRect:timeshiftIconRect];
            [clockCircle setLineWidth:1.5];
            [clockCircle stroke];
            
            // Draw clock hands pointing to 10:10 (classic clock position)
            NSPoint center = NSMakePoint(timeshiftIconRect.origin.x + timeshiftIconRect.size.width/2, 
                                        timeshiftIconRect.origin.y + timeshiftIconRect.size.height/2);
            
            // Hour hand (pointing to 10)
            NSBezierPath *hourHand = [NSBezierPath bezierPath];
            [hourHand moveToPoint:center];
            [hourHand lineToPoint:NSMakePoint(center.x - 3, center.y + 2)];
            [hourHand setLineWidth:1.5];
            [hourHand stroke];
            
            // Minute hand (pointing to 2)
            NSBezierPath *minuteHand = [NSBezierPath bezierPath];
            [minuteHand moveToPoint:center];
            [minuteHand lineToPoint:NSMakePoint(center.x + 4, center.y + 1)];
            [minuteHand setLineWidth:1.0];
            [minuteHand stroke];
            
            // Center dot
            NSBezierPath *centerDot = [NSBezierPath bezierPathWithOvalInRect:NSMakeRect(center.x - 1, center.y - 1, 2, 2)];
            [centerDot fill];
            
            // Draw small arrow to indicate rewind capability
            NSBezierPath *rewindArrow = [NSBezierPath bezierPath];
            [rewindArrow moveToPoint:NSMakePoint(center.x - 6, center.y - 6)];
            [rewindArrow lineToPoint:NSMakePoint(center.x - 3, center.y - 4)];
            [rewindArrow lineToPoint:NSMakePoint(center.x - 3, center.y - 8)];
            [rewindArrow closePath];
            [rewindArrow fill];
        }
        
        // Get the actual channel object to access program info
        VLCChannel *channel = nil;
        NSString *currentGroup = nil;
        NSArray *groups = nil;
        
        // Get current category and group
        NSString *currentCategory = nil;
        if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
            currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
            
            // Get the appropriate groups based on category
            if ([currentCategory isEqualToString:@"FAVORITES"]) {
                groups = [self safeGroupsForCategory:@"FAVORITES"];
            } else if ([currentCategory isEqualToString:@"TV"]) {
                groups = [self safeTVGroups];
            } else if ([currentCategory isEqualToString:@"MOVIES"]) {
                groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
            } else if ([currentCategory isEqualToString:@"SERIES"]) {
                groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
            }
            
            // Get the current group
            if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
                currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
                
                // Get channels for this group
                NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
                if (channelsInGroup && i < channelsInGroup.count) {
                    channel = [channelsInGroup objectAtIndex:i];
                }
            }
        }
        
        // If we have a channel and EPG data, show current program
        if (channel) {
            VLCProgram *currentProgram = [channel currentProgramWithTimeOffset:self.epgTimeOffsetHours];
            
            // Debug logging for time offset issues
            
            // Check if the channel has EPG data
            BOOL hasEpgData = (self.isEpgLoaded && currentProgram != nil);
            if (hasEpgData) {
                // Draw current program name with smaller font
                NSDictionary *programAttrs = @{
                    NSFontAttributeName: [NSFont systemFontOfSize:12],
                    NSForegroundColorAttributeName: [NSColor lightGrayColor],
                    NSParagraphStyleAttributeName: style
                };
                
                // Program info below channel name
                NSRect programTextRect = NSMakeRect(itemRect.origin.x + 8,
                                           itemRect.origin.y + 5,
                                           itemRect.size.width - 100, // Leave space for time on right
                                           16);
                
                // Truncate program title if needed
                NSString *programTitle = currentProgram.title;
                if (programTitle.length > 30) {
                    programTitle = [[programTitle substringToIndex:27] stringByAppendingString:@"..."];
                }
                [programTitle drawInRect:programTextRect withAttributes:programAttrs];
                
                // Draw program time on right side
                NSRect timeRect = NSMakeRect(itemRect.origin.x + itemRect.size.width - 90, 
                                           itemRect.origin.y + 5, 
                                           80, 
                                           16);
                
                [[currentProgram formattedTimeRangeWithOffset:self.epgTimeOffsetHours] drawInRect:timeRect withAttributes:programAttrs];
                
                // Draw progress bar
                NSDate *now = [NSDate date];
                // Apply EPG time offset for progress calculation
                NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600.0;
                NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
                NSTimeInterval totalDuration = [currentProgram.endTime timeIntervalSinceDate:currentProgram.startTime];
                NSTimeInterval elapsed = [adjustedNow timeIntervalSinceDate:currentProgram.startTime];
                CGFloat progress = totalDuration > 0 ? (elapsed / totalDuration) : 0;
                progress = MAX(0, MIN(progress, 1.0)); // Clamp between 0 and 1
                
                // Draw thin progress bar
                CGFloat progressBarHeight = 2;
                NSRect progressBarBg = NSMakeRect(itemRect.origin.x + 10, 
                                                itemRect.origin.y + 3, 
                                                itemRect.size.width - 20, 
                                                progressBarHeight);
                
                // Background bar
                [[NSColor colorWithCalibratedRed:0.2 green:0.2 blue:0.2 alpha:0.7] set];
                NSRectFill(progressBarBg);
                
                // Progress fill
                NSRect progressBarFill = NSMakeRect(progressBarBg.origin.x, 
                                                 progressBarBg.origin.y, 
                                                 progressBarBg.size.width * progress, 
                                                 progressBarHeight);
                
                // Use a color based on how far along we are
                if (progress < 0.25) {
                    [[NSColor colorWithCalibratedRed:0.2 green:0.7 blue:0.3 alpha:0.8] set]; // Green for just started
                } else if (progress < 0.75) {
                    [[NSColor colorWithCalibratedRed:0.2 green:0.5 blue:0.8 alpha:0.8] set]; // Blue for middle
                } else {
                    [[NSColor colorWithCalibratedRed:0.8 green:0.3 blue:0.2 alpha:0.8] set]; // Red for almost over
                }
                NSRectFill(progressBarFill);
            } else {
                // No EPG data available for this channel
                if (self.isEpgLoaded) {
                    // EPG is loaded but no program data for this specific channel
                    NSDictionary *noDataAttrs = @{
                        NSFontAttributeName: [NSFont systemFontOfSize:10],
                        NSForegroundColorAttributeName: [NSColor darkGrayColor],
                        NSParagraphStyleAttributeName: style
                    };
                    
                    NSRect noDataRect = NSMakeRect(itemRect.origin.x + 10, 
                                            itemRect.origin.y + 5, 
                                            itemRect.size.width - 20, 
                                            16);
                    
                    [@"No program data available" drawInRect:noDataRect withAttributes:noDataAttrs];
                } else if (self.isLoadingEpg) {
                    // EPG is still loading, but don't show any text
                    // The progress bar in the bottom right corner will indicate loading status
                }
            }
        }
        
        [style release];
    }
       // Draw search movie results in the program guide area if in search mode
    if (self.selectedCategoryIndex == CATEGORY_SEARCH && self.searchMovieResults && [self.searchMovieResults count] > 0) {
        [self drawSearchMovieResults:programGuideRect];
    }
    
    // Show program guide when hovering over a channel
    if (self.hoveredChannelIndex >= 0 && self.hoveredChannelIndex < [channelNames count]) {
        [self drawProgramGuideForHoveredChannel];
    }
    
    // Draw scroll bar
    [self drawScrollBar:contentRect contentHeight:totalContentHeight scrollPosition:scrollPosition];
}

- (void)drawLoadingIndicator:(NSRect)rect {
    if (!self.isLoading) {
        return; // Don't draw anything if we're not in loading state
    }
    
    // Create a more visible overlay in the bottom right
    CGFloat overlayWidth = 350; // Width for detailed info
    CGFloat overlayHeight = 120; // Height to fit content
    CGFloat padding = 20; // Padding from screen edges
    
    // Calculate position for bottom right corner
    NSRect overlayRect = NSMakeRect(
        self.bounds.size.width - overlayWidth - padding,
        padding,
        overlayWidth, 
        overlayHeight
    );
    
    // Draw more visible rounded background with stronger colors
    NSBezierPath *bgPath = [NSBezierPath bezierPathWithRoundedRect:overlayRect xRadius:8 yRadius:8];
    [[NSColor colorWithCalibratedWhite:0.0 alpha:0.8] set]; // Darker background
    [bgPath fill];
    
    // Draw border
    [[NSColor colorWithCalibratedWhite:0.7 alpha:0.7] set];
    [bgPath setLineWidth:1.0];
    [bgPath stroke];
    
    // Draw title and loading text
    NSString *titleText;
    
    // Determine if we're downloading or processing
    NSString *currentStatus = @"";
    if (gProgressMessageLock) {
        [gProgressMessageLock lock];
        if (gProgressMessage) {
            currentStatus = [NSString stringWithString:gProgressMessage];
        }
        [gProgressMessageLock unlock];
    }
    
    if ([currentStatus rangeOfString:@"Downloading:"].location != NSNotFound) {
        titleText = @"Downloading...";
    } else if ([currentStatus rangeOfString:@"Processing:"].location != NSNotFound) {
        titleText = @"Processing...";
    } else if ([currentStatus rangeOfString:@"Download complete"].location != NSNotFound) {
        titleText = @"Download Complete";
    } else {
        titleText = @"Please Wait...";
    }
    
    // Draw title
    NSMutableParagraphStyle *centerStyle = [[NSMutableParagraphStyle alloc] init];
    [centerStyle setAlignment:NSCenterTextAlignment];
    
    // Use a smaller font for the title to save space
    NSFont *titleFont = [NSFont boldSystemFontOfSize:14.0];
    NSDictionary *titleAttrs = [NSDictionary dictionaryWithObjectsAndKeys:
                              titleFont, NSFontAttributeName,
                              [NSColor colorWithCalibratedWhite:1.0 alpha:0.9], NSForegroundColorAttributeName,
                              centerStyle, NSParagraphStyleAttributeName,
                              nil];
    
    NSRect titleRect = NSMakeRect(
        overlayRect.origin.x + 10,
        overlayRect.origin.y + overlayRect.size.height - 30,
        overlayRect.size.width - 20,
        20
    );
    
    [titleText drawInRect:titleRect withAttributes:titleAttrs];
    
    // Draw detail status text (if available)
    NSString *statusText = @"";
    if (gProgressMessageLock) {
        [gProgressMessageLock lock];
        if (gProgressMessage) {
            statusText = [NSString stringWithString:gProgressMessage];
        }
        [gProgressMessageLock unlock];
    }
    
    if (!statusText || [statusText length] == 0) {
        statusText = @"Please wait...";
    }
    
    // Use a smaller font for status text
    NSFont *statusFont = [NSFont systemFontOfSize:12.0];
    NSDictionary *statusAttrs = [NSDictionary dictionaryWithObjectsAndKeys:
                               statusFont, NSFontAttributeName,
                               [NSColor colorWithCalibratedWhite:1.0 alpha:0.9], NSForegroundColorAttributeName,
                               centerStyle, NSParagraphStyleAttributeName,
                               nil];
    
    NSRect statusRect = NSMakeRect(
        overlayRect.origin.x + 10,
        overlayRect.origin.y + overlayRect.size.height - 55, // Position below title
        overlayRect.size.width - 20,
        20
    );
    
    [statusText drawInRect:statusRect withAttributes:statusAttrs];
    [centerStyle release];
    
    // Draw progress bar
    CGFloat progressBarHeight = 16;
    CGFloat progressBarWidth = overlayRect.size.width - 40; // Leave margin on sides
    NSRect progressBarBgRect = NSMakeRect(
        overlayRect.origin.x + 20,
        overlayRect.origin.y + 20, // Position at bottom
        progressBarWidth,
        progressBarHeight
    );
    
    // Draw progress bar background
    NSBezierPath *progressBgPath = [NSBezierPath bezierPathWithRoundedRect:progressBarBgRect xRadius:4 yRadius:4];
    [[NSColor colorWithCalibratedWhite:0.2 alpha:1.0] set]; // Darker background
    [progressBgPath fill];
    
    // Determine progress value to show
    float progressValue = 0.0;
    if (self.isLoadingEpg) {
        progressValue = self.epgLoadingProgress;
    } else {
        progressValue = self.loadingProgress;
    }
    
    // Avoid NaN or negative values
    if (isnan(progressValue) || progressValue < 0.0) {
        progressValue = 0.0;
    }
    
    // Draw actual progress
    if (progressValue > 0.0) {
        NSRect progressFilledRect = NSMakeRect(
            progressBarBgRect.origin.x,
            progressBarBgRect.origin.y,
            progressBarWidth * MIN(1.0, progressValue),
                                               progressBarBgRect.size.height
        );
        
        NSBezierPath *progressFilledPath = [NSBezierPath bezierPathWithRoundedRect:progressFilledRect xRadius:4 yRadius:4];
        
        // Use a bright color for the progress
        [[NSColor colorWithCalibratedRed:0.2 green:0.6 blue:1.0 alpha:1.0] set];
        [progressFilledPath fill];
    } else {
        // Draw animated indicator for indeterminate progress
        static float animationOffset = 0.0;
        animationOffset += 0.01;
        if (animationOffset > 1.0) {
            animationOffset = 0.0;
        }
        
        // Create a moving segment
        CGFloat segmentWidth = progressBarWidth * 0.25; // 25% of the total width
        NSRect progressFilledRect = NSMakeRect(
            progressBarBgRect.origin.x + ((progressBarWidth - segmentWidth) * animationOffset),
            progressBarBgRect.origin.y,
            segmentWidth,
                                               progressBarBgRect.size.height
        );
        
        NSBezierPath *progressFilledPath = [NSBezierPath bezierPathWithRoundedRect:progressFilledRect xRadius:4 yRadius:4];
        
        // Use a bright color for the progress
        [[NSColor colorWithCalibratedRed:0.2 green:0.6 blue:1.0 alpha:1.0] set];
        [progressFilledPath fill];
    }
    
    // Draw percentage text on progress bar
    NSString *percentText;
    
    // Get the current status text from global variable - use progressStatus to avoid redefining currentStatus
    NSString *progressStatus = @"";
    if (gProgressMessageLock) {
        [gProgressMessageLock lock];
        if (gProgressMessage) {
            progressStatus = [NSString stringWithString:gProgressMessage];
        }
        [gProgressMessageLock unlock];
    }
    
    if (progressValue > 0.0) {
        // Use the value from status text if it contains download information
        if ([progressStatus rangeOfString:@"Downloading:"].location != NSNotFound) {
            percentText = progressStatus;
        } else {
            percentText = [NSString stringWithFormat:@"%.0f%%", progressValue * 100.0];
        }
    } else {
        percentText = @"Processing...";
    }
    
    NSFont *percentFont = [NSFont boldSystemFontOfSize:12.0];
    NSDictionary *percentAttrs = [NSDictionary dictionaryWithObjectsAndKeys:
                                percentFont, NSFontAttributeName,
                                [NSColor whiteColor], NSForegroundColorAttributeName,
                                nil];
    
    NSRect percentRect = NSMakeRect(
        progressBarBgRect.origin.x,
        progressBarBgRect.origin.y,
        progressBarBgRect.size.width,
        progressBarBgRect.size.height
    );
    
    // Center the percentage text
    NSMutableParagraphStyle *percentStyle = [[NSMutableParagraphStyle alloc] init];
    [percentStyle setAlignment:NSCenterTextAlignment];
    percentAttrs = [NSDictionary dictionaryWithObjectsAndKeys:
                  percentFont, NSFontAttributeName,
                  [NSColor whiteColor], NSForegroundColorAttributeName,
                  percentStyle, NSParagraphStyleAttributeName,
                  nil];
    
    [percentText drawInRect:percentRect withAttributes:percentAttrs];
    [percentStyle release];
}

- (void)drawEpgPanel:(NSRect)rect {
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat epgPanelX = catWidth + groupWidth;
    CGFloat epgPanelWidth = self.bounds.size.width - epgPanelX;
    CGFloat rowHeight = 40;
    
    // Draw background using theme colors
    NSRect epgRect = NSMakeRect(epgPanelX, 0, epgPanelWidth, self.bounds.size.height);
    
    // Use theme colors for EPG panel background
    NSColor *epgStartColor, *epgEndColor;
    if (self.themeChannelStartColor && self.themeChannelEndColor) {
        // Make the EPG panel use a darker version of channel theme colors
        CGFloat darkAlpha = self.themeAlpha * 0.8;
        epgStartColor = [self.themeChannelStartColor colorWithAlphaComponent:darkAlpha];
        epgEndColor = [self.themeChannelEndColor colorWithAlphaComponent:darkAlpha];
    } else {
        epgStartColor = [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.7];
        epgEndColor = [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.7];
    }
    
    NSGradient *epgGradient = [[NSGradient alloc] initWithStartingColor:epgStartColor endingColor:epgEndColor];
    [epgGradient drawInRect:epgRect angle:90];
    [epgGradient release];
    
    // Remove the header bar completely
    
    // Draw EPG data
    if (self.selectedChannelIndex < 0 || self.selectedChannelIndex >= [self.simpleChannelNames count]) {
        // No channel selected, just show a message
        NSString *message = @"Select a channel to view program guide";
        
        [self.textColor set];
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:16],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        NSRect messageRect = NSMakeRect(epgPanelX + 20, 
                                        self.bounds.size.height / 2 - 10, 
                                        epgPanelWidth - 40, 
                                        20);
        
        [message drawInRect:messageRect withAttributes:attrs];
        [style release];
    } else {
        // Show EPG data for selected channel
        NSString *channelName = [self.simpleChannelNames objectAtIndex:self.selectedChannelIndex];
        
        // Draw channel name
        [self.textColor set];
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:18],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        // Adjust position without the header
        NSRect channelRect = NSMakeRect(epgPanelX + 20, 
                                        self.bounds.size.height - rowHeight - 10, 
                                        epgPanelWidth - 40, 
                                        rowHeight);
        
        [channelName drawInRect:channelRect withAttributes:attrs];
        [style release];
        
        // TODO: Draw actual EPG data when available
    }
}

- (void)drawSettingsPanel:(NSRect)rect {
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat settingsPanelX = catWidth + groupWidth;
    CGFloat settingsPanelWidth = self.bounds.size.width - settingsPanelX;
    CGFloat rowHeight = 40;
    
    // Draw background using theme colors
    NSRect settingsRect = NSMakeRect(settingsPanelX, 0, settingsPanelWidth, self.bounds.size.height);
    
    // Use theme colors for settings panel background
    NSColor *settingsStartColor, *settingsEndColor;
    if (self.themeChannelStartColor && self.themeChannelEndColor) {
        // Make the settings panel use theme colors with slight alpha adjustment
        CGFloat settingsAlpha = self.themeAlpha * 0.85;
        settingsStartColor = [self.themeChannelStartColor colorWithAlphaComponent:settingsAlpha];
        settingsEndColor = [self.themeChannelEndColor colorWithAlphaComponent:settingsAlpha];
    } else {
        settingsStartColor = [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.7];
        settingsEndColor = [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.7];
    }
    
    NSGradient *settingsGradient = [[NSGradient alloc] initWithStartingColor:settingsStartColor endingColor:settingsEndColor];
    [settingsGradient drawInRect:settingsRect angle:90];
    [settingsGradient release];
    
    // Only draw settings content if a settings group is selected
    NSArray *settingsGroups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    
    if (self.selectedGroupIndex >= 0 && self.selectedGroupIndex < [settingsGroups count]) {
        NSString *selectedGroup = [settingsGroups objectAtIndex:self.selectedGroupIndex];
        
        if ([selectedGroup isEqualToString:@"Playlist"]) {
            // Draw Playlist settings
            [self drawPlaylistSettings:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"General"]) {
            // Draw General settings
            [self drawGeneralSettings:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"Subtitles"]) {
            // Draw Subtitle settings
            [self drawSubtitleSettings:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"Movie Info"]) {
            // Draw Movie Info settings
            [self drawMovieInfoSettings:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"Themes"]) {
            // Draw Theme settings
            [self drawThemeSettings:rect x:settingsPanelX width:settingsPanelWidth];
        }
    } else {
        // No group selected, show a helper message
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *helpAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:14],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        NSRect helpRect = NSMakeRect(settingsPanelX + 20, 
                                    self.bounds.size.height / 2 - 10, 
                                    settingsPanelWidth - 40, 
                                    20);
        
        [@"Select a settings group from the left panel" drawInRect:helpRect withAttributes:helpAttrs];
    [style release];
    }
}

- (void)drawPlaylistSettings:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat fieldHeight = 30;
    CGFloat labelHeight = 20;
    CGFloat verticalSpacing = 10; // Add spacing between label and field
    CGFloat startY = self.bounds.size.height - 100;
    CGFloat fieldWidth = width - (padding * 2);
    
    // Draw a section title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, width - (padding * 2), 20);
    [@"Playlist Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Calculate vertical positions with proper spacing
    CGFloat m3uLabelY = startY - 40;
    CGFloat m3uFieldY = m3uLabelY - labelHeight - verticalSpacing;
    CGFloat epgLabelY = m3uFieldY - fieldHeight - verticalSpacing;
    CGFloat epgFieldY = epgLabelY - labelHeight - verticalSpacing;
    
    // Draw labels
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    // M3U URL label
    NSRect m3uLabelRect = NSMakeRect(x + padding, m3uLabelY, fieldWidth, labelHeight);
    [@"M3U URL:" drawInRect:m3uLabelRect withAttributes:labelAttrs];
    
    // EPG URL label
    NSRect epgLabelRect = NSMakeRect(x + padding, epgLabelY, fieldWidth, labelHeight);
    [@"EPG XML URL (auto-generated, click to copy):" drawInRect:epgLabelRect withAttributes:labelAttrs];
    
    // Create or update M3U text field
    NSRect m3uFieldRect = NSMakeRect(x + padding, m3uFieldY, fieldWidth, fieldHeight);
    if (!self.m3uTextField) {
        self.m3uTextField = [[VLCReusableTextField alloc] initWithFrame:m3uFieldRect identifier:@"m3u"];
        self.m3uTextField.textFieldDelegate = self;
        [self.m3uTextField setPlaceholderText:@"Enter a URL or click 'Load From URL' to download a playlist"];
        
        // Add to subview immediately since we're in the playlist settings
        if (![self.subviews containsObject:self.m3uTextField]) {
            [self addSubview:self.m3uTextField];
        }
        [self.m3uTextField setHidden:NO];
    } else {
        [self.m3uTextField setFrame:m3uFieldRect];
        
        // Ensure it's visible and added to subviews
        if (![self.subviews containsObject:self.m3uTextField]) {
            [self addSubview:self.m3uTextField];
        }
        [self.m3uTextField setHidden:NO];
    }
    
    // Update M3U text field value only if not currently being edited
    if (!self.m3uTextField.isActive) {
        NSString *m3uUrl = self.m3uFilePath;
        if ([m3uUrl hasPrefix:@"http://"] || [m3uUrl hasPrefix:@"https://"]) {
            [self.m3uTextField setTextValue:m3uUrl];
        } else {
            [self.m3uTextField setTextValue:@""];
        }
    }
    
    // Create or update EPG clickable label
    NSRect epgFieldRect = NSMakeRect(x + padding, epgFieldY, fieldWidth, fieldHeight);
    if (!self.epgLabel) {
        self.epgLabel = [[VLCClickableLabel alloc] initWithFrame:epgFieldRect identifier:@"epg"];
        self.epgLabel.delegate = self;
        [self.epgLabel setPlaceholderText:@"EPG URL will be auto-generated from M3U URL"];
        
        // Add to subview immediately since we're in the playlist settings
        if (![self.subviews containsObject:self.epgLabel]) {
            [self addSubview:self.epgLabel];
        }
        [self.epgLabel setHidden:NO];
    } else {
        [self.epgLabel setFrame:epgFieldRect];
        
        // Ensure it's visible and added to subviews
        if (![self.subviews containsObject:self.epgLabel]) {
            [self addSubview:self.epgLabel];
        }
        [self.epgLabel setHidden:NO];
    }
    
    // Update EPG label text
    NSString *epgUrl = self.epgUrl;
    if (epgUrl && [epgUrl length] > 0) {
        [self.epgLabel setText:epgUrl];
    } else {
        [self.epgLabel setText:@""];
    }
    
    // Store field rects for click handling (keep for compatibility)
    self.m3uFieldRect = m3uFieldRect;
    self.epgFieldRect = epgFieldRect;
    
    // Calculate button and help text positions based on new layout
    CGFloat buttonY = epgFieldY - fieldHeight - verticalSpacing * 2;
    
    // Continue with the rest of the method (EPG Time Offset dropdown, buttons, etc.)
    // Add EPG Time Offset dropdown between EPG field and buttons
    CGFloat offsetLabelY = epgFieldY - fieldHeight - verticalSpacing;
    CGFloat offsetDropdownY = offsetLabelY - labelHeight - verticalSpacing;
    
    // EPG Time Offset label
    NSRect offsetLabelRect = NSMakeRect(x + padding, offsetLabelY, fieldWidth, labelHeight);
    [@"EPG Time Offset:" drawInRect:offsetLabelRect withAttributes:labelAttrs];
    
    // EPG Time Offset dropdown using new dropdown manager
    CGFloat dropdownWidth = 150; // Smaller width for dropdown
    NSRect offsetDropdownRect = NSMakeRect(x + padding, offsetDropdownY, dropdownWidth, fieldHeight);
    
    // Store the dropdown rect for click handling
    self.epgTimeOffsetDropdownRect = offsetDropdownRect;
    
    // Draw dropdown background
    if (self.epgTimeOffsetDropdownActive) {
        [[NSColor colorWithCalibratedRed:0.2 green:0.3 blue:0.4 alpha:1.0] set];
    } else {
        [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0] set];
    }
    NSRectFill(offsetDropdownRect);
    
    // Draw dropdown border
    if (self.epgTimeOffsetDropdownActive) {
        [[NSColor blueColor] set];
    } else {
        [[NSColor grayColor] set];
    }
    NSFrameRect(offsetDropdownRect);
    
    // Draw current offset value
    NSString *offsetText = [NSString stringWithFormat:@"%+d hours", (int)self.epgTimeOffsetHours];
    NSRect offsetValueRect = NSMakeRect(offsetDropdownRect.origin.x + 10, 
                                       offsetDropdownRect.origin.y + 7, 
                                       offsetDropdownRect.size.width - 30, 
                                       offsetDropdownRect.size.height - 14);
    
    NSDictionary *offsetAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    [offsetText drawInRect:offsetValueRect withAttributes:offsetAttrs];
    
    // Draw dropdown arrow
    NSRect arrowRect = NSMakeRect(offsetDropdownRect.origin.x + offsetDropdownRect.size.width - 20, 
                                 offsetDropdownRect.origin.y + 10, 
                                 10, 10);
    [[NSColor lightGrayColor] set];
    NSBezierPath *arrowPath = [NSBezierPath bezierPath];
    [arrowPath moveToPoint:NSMakePoint(arrowRect.origin.x, arrowRect.origin.y + arrowRect.size.height)];
    [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width/2, arrowRect.origin.y)];
    [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width, arrowRect.origin.y + arrowRect.size.height)];
    [arrowPath closePath];
    [arrowPath fill];
    
    // Update button Y position
    buttonY = offsetDropdownY - fieldHeight - verticalSpacing;
    
    // Draw buttons
    CGFloat buttonWidth = 120;
    CGFloat buttonHeight = 30;
    CGFloat buttonSpacing = 20;
    
    // Load From URL button
    NSRect loadButtonRect = NSMakeRect(x + padding, buttonY, buttonWidth, buttonHeight);
    self.loadButtonRect = loadButtonRect;
    
    // Draw load button background with disabled state
    NSColor *loadButtonColor;
    if (self.isLoading) {
        loadButtonColor = [NSColor colorWithCalibratedRed:0.5 green:0.5 blue:0.5 alpha:0.6]; // Grayed out when disabled
    } else {
        loadButtonColor = [NSColor colorWithCalibratedRed:0.2 green:0.4 blue:0.7 alpha:1.0]; // Normal blue
    }
    [loadButtonColor set];
    NSBezierPath *loadButtonPath = [NSBezierPath bezierPathWithRoundedRect:loadButtonRect xRadius:5 yRadius:5];
    [loadButtonPath fill];
    
    // Draw load button text with centered alignment
    NSMutableParagraphStyle *buttonStyle = [[NSMutableParagraphStyle alloc] init];
    [buttonStyle setAlignment:NSTextAlignmentCenter];
    
    NSColor *buttonTextColor = self.isLoading ? [NSColor colorWithCalibratedWhite:0.8 alpha:0.6] : [NSColor whiteColor];
    NSDictionary *buttonTextAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
        NSForegroundColorAttributeName: buttonTextColor,
        NSParagraphStyleAttributeName: buttonStyle
    };
    
    NSRect loadButtonTextRect = NSMakeRect(loadButtonRect.origin.x, loadButtonRect.origin.y + 10, 
                                          loadButtonRect.size.width, loadButtonRect.size.height - 20);
    [@"Load Playlist" drawInRect:loadButtonTextRect withAttributes:buttonTextAttrs];
    
    // Update EPG button
    NSRect epgButtonRect = NSMakeRect(x + padding + buttonWidth + buttonSpacing, buttonY, buttonWidth, buttonHeight);
    self.epgButtonRect = epgButtonRect;
    
    // Draw EPG button background with disabled state
    NSColor *epgButtonColor;
    if (self.isLoading) {
        epgButtonColor = [NSColor colorWithCalibratedRed:0.5 green:0.5 blue:0.5 alpha:0.6]; // Grayed out when disabled
    } else {
        epgButtonColor = [NSColor colorWithCalibratedRed:0.2 green:0.6 blue:0.3 alpha:1.0]; // Normal green
    }
    [epgButtonColor set];
    NSBezierPath *epgButtonPath = [NSBezierPath bezierPathWithRoundedRect:epgButtonRect xRadius:5 yRadius:5];
    [epgButtonPath fill];
    
    // Draw EPG button text
    NSRect epgButtonTextRect = NSMakeRect(epgButtonRect.origin.x, epgButtonRect.origin.y + 10, 
                                         epgButtonRect.size.width, epgButtonRect.size.height - 20);
    [@"Update EPG" drawInRect:epgButtonTextRect withAttributes:buttonTextAttrs];
    
    // Draw EPG Time Offset dropdown options if active
    if (self.epgTimeOffsetDropdownActive) {
        CGFloat dropdownOptionHeight = 25;
        NSInteger numOptions = 25; // -12 to +12 hours
        CGFloat totalDropdownHeight = numOptions * dropdownOptionHeight;
        NSRect dropdownOptionsRect = NSMakeRect(self.epgTimeOffsetDropdownRect.origin.x,
                                               self.epgTimeOffsetDropdownRect.origin.y - totalDropdownHeight,
                                               self.epgTimeOffsetDropdownRect.size.width,
                                               totalDropdownHeight);
        
        // Draw dropdown options background
        [[NSColor colorWithCalibratedRed:0.15 green:0.15 blue:0.15 alpha:0.95] set];
        NSRectFill(dropdownOptionsRect);
        
        // Draw dropdown options border
        [[NSColor grayColor] set];
        NSFrameRect(dropdownOptionsRect);
        
        // Draw each option
        for (NSInteger i = 0; i < numOptions; i++) {
            NSInteger offsetHours = i - 12; // -12 to +12
            NSRect optionRect = NSMakeRect(dropdownOptionsRect.origin.x,
                                          dropdownOptionsRect.origin.y + (i * dropdownOptionHeight),
                                          dropdownOptionsRect.size.width,
                                          dropdownOptionHeight);
            
            // Highlight current selection
            if (offsetHours == self.epgTimeOffsetHours) {
                [[NSColor colorWithCalibratedRed:0.3 green:0.4 blue:0.6 alpha:0.8] set];
                NSRectFill(optionRect);
            }
            
            // Draw option text
            NSString *optionText = [NSString stringWithFormat:@"%+d hours", (int)offsetHours];
            NSRect optionTextRect = NSMakeRect(optionRect.origin.x + 10,
                                              optionRect.origin.y + 3,
                                              optionRect.size.width - 20,
                                              optionRect.size.height - 6);
            
            NSDictionary *optionAttrs = @{
                NSFontAttributeName: [NSFont systemFontOfSize:12],
                NSForegroundColorAttributeName: [NSColor whiteColor],
                NSParagraphStyleAttributeName: style
            };
            [optionText drawInRect:optionTextRect withAttributes:optionAttrs];
        }
    }
    
    [style release];
}

- (void)drawGeneralSettings:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = self.bounds.size.height - 100;
    
    // Draw a section title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, width - (padding * 2), 20);
    [@"General Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Additional general settings would go here
    
    [style release];
}

- (void)drawURLInputField:(NSRect)rect {
    // Draw semi-transparent background over the entire view
    [[[NSColor blackColor] colorWithAlphaComponent:0.7] set];
    NSRectFill(self.bounds);
    
    // Create a dialog box in the center
    CGFloat dialogWidth = 500;
    CGFloat dialogHeight = 150;
    NSRect dialogRect = NSMakeRect((self.bounds.size.width - dialogWidth) / 2,
                                  (self.bounds.size.height - dialogHeight) / 2,
                                  dialogWidth,
                                  dialogHeight);
    
    // Draw dialog background
    [[NSColor colorWithCalibratedRed:0.2 green:0.2 blue:0.2 alpha:0.9] set];
    NSRectFill(dialogRect);
    
    // Draw border
    [[NSColor whiteColor] set];
    NSFrameRect(dialogRect);
    
    // Draw title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(dialogRect.origin.x + 10,
                                 dialogRect.origin.y + dialogRect.size.height - 40,
                                 dialogRect.size.width - 20,
                                 30);
    
    [@"Enter URL" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Draw text field
    NSRect textFieldRect = NSMakeRect(dialogRect.origin.x + 20,
                                     dialogRect.origin.y + dialogRect.size.height / 2 - 15,
                                     dialogRect.size.width - 40,
                                     30);
    
    [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0] set];
    NSRectFill(textFieldRect);
    [[NSColor whiteColor] set];
    NSFrameRect(textFieldRect);
    
    // Draw text
    NSDictionary *textAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSRect valueRect = NSMakeRect(textFieldRect.origin.x + 5,
                                 textFieldRect.origin.y + 5,
                                 textFieldRect.size.width - 10,
                                 textFieldRect.size.height - 10);
    
    [self.inputUrlString drawInRect:valueRect withAttributes:textAttrs];
    
    // Draw helper text
    NSString *helperText = @"Press Enter to confirm, Esc to cancel";
    NSDictionary *helperAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor lightGrayColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSRect helperRect = NSMakeRect(dialogRect.origin.x + 10,
                                  dialogRect.origin.y + 10,
                                  dialogRect.size.width - 20,
                                  20);
    
    [helperText drawInRect:helperRect withAttributes:helperAttrs];
    
    [style release];
}

#pragma mark - Mouse Handling

- (void)mouseDown:(NSEvent *)event {
    [self markUserInteraction];
    
    // Handle dropdown manager clicks first
    if ([self.dropdownManager handleMouseDown:event]) {
        // Dropdown manager handled the click
        return;
    }
    
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // If menu is hidden, only handle player controls - skip ALL menu processing
    if (!self.isChannelListVisible) {
        // Check if we have a player and the click is on player controls
        if (self.player) {
            BOOL handled = [self handlePlayerControlsClickAtPoint:point];
            if (handled) {
                return;
            }
            
            // Don't hide controls on any click - let them stay visible
            //NSLog(@"Click outside controls - keeping controls visible");
        }
        // If no player or click not on controls, do nothing - menu is hidden
        return;
    }
    
    // Everything below this point is ONLY for when the menu is visible
    
    // Check if we're in one of the menus
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    if (point.x < catWidth) {
        // Category menu
        [self handleCategoryClick:point];
    } else if (point.x < catWidth + groupWidth) {
        // Group menu
        [self handleGroupClick:point];
    } else {
        // If in grid view and clicking in the grid area
        if (isGridViewActive) {
            [self handleGridViewClick:point];
        } else {
            // Normal channel list
            BOOL handled = [self handleClickAtPoint:point];
            if (handled) {
                return;
            }
        }
    }
}

// Handle clicks in grid view
- (void)handleGridViewClick:(NSPoint)point {
    NSInteger gridIndex = [self gridItemIndexAtPoint:point];
    if (gridIndex >= 0) {
        // Get the channel at this index
        NSArray *channels = [self getChannelsForCurrentGroup];
        if (channels && gridIndex < channels.count) {
            VLCChannel *channel = [channels objectAtIndex:gridIndex];
            if (channel) {
                // Set selected channel index
                self.selectedChannelIndex = gridIndex;
                
                // Play the channel
                [self playChannelAtIndex:gridIndex];
                
                // Trigger redraw
                [self setNeedsDisplay:YES];
            }
        }
    }
}

- (void)handleCategoryClick:(NSPoint)point {
    CGFloat rowHeight = 40;
    NSInteger index = (NSInteger)((self.bounds.size.height - point.y) / rowHeight);
    
    if (index >= 0 && index < [self.categories count]) {
        // Hide all controls before changing category
        [self hideControls];
        
        self.selectedCategoryIndex = index;
        self.selectedGroupIndex = -1; // Reset group selection
        self.selectedChannelIndex = -1; // Reset channel selection
        
        [self setNeedsDisplay:YES];
    }
}

- (void)handleGroupClick:(NSPoint)point {
    if (self.selectedCategoryIndex < 0 || self.selectedCategoryIndex >= [self.categories count]) {
        return;
    }
    
    CGFloat rowHeight = 40;
    // Calculate group index accounting for scroll position
    NSInteger index = (NSInteger)((self.bounds.size.height - point.y) / rowHeight + groupScrollPosition / rowHeight);
    
    NSArray *groups;
    NSString *categoryName = [self.categories objectAtIndex:self.selectedCategoryIndex];
    
    if ([categoryName isEqualToString:@"FAVORITES"]) {
        groups = [self safeGroupsForCategory:@"FAVORITES"];
    } else if ([categoryName isEqualToString:@"TV"]) {
        groups = [self safeTVGroups];
    } else if ([categoryName isEqualToString:@"MOVIES"]) {
        groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
    } else if ([categoryName isEqualToString:@"SERIES"]) {
        groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
    } else if ([categoryName isEqualToString:@"SETTINGS"]) {
        groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    } else {
        return;
    }
    
    if (index >= 0 && index < [groups count]) {
        // Hide all controls before changing group
        [self hideControls];
        
        self.selectedGroupIndex = index;
        self.selectedChannelIndex = -1; // Reset channel selection
        
        // Make sure channels are prepared when a group is clicked
        [self prepareSimpleChannelLists];
        
        // NEW: When a movie group is selected, immediately scan and load cached info/covers
        if ([categoryName isEqualToString:@"MOVIES"] || 
            ([categoryName isEqualToString:@"FAVORITES"] && [self currentGroupContainsMovieChannels])) {
            [self immediatelyLoadCachedMovieDataForCurrentGroup];
        }
        
        // REMOVED: Don't bulk download entire group - only process visible movies on demand
        // [self checkAndRefreshMovieDataForCurrentGroup];
        
        // Reset scroll positions
        channelScrollPosition = 0;
        
        // Reset grid loading queue to force reloading images for the new group
        if (isGridViewActive) {
            if (gridLoadingQueue) {
                [gridLoadingQueue removeAllObjects];
            }
        }
        
        // Log that a group was selected for debugging
        //NSLog(@"Group selected: %@, with %lu channels", 
              //[groups objectAtIndex:index],
              //(unsigned long)[[self.channelsByGroup objectForKey:[groups objectAtIndex:index]] count]);
        
        [self setNeedsDisplay:YES];
    }
}

- (BOOL)handleClickAtPoint:(NSPoint)point {
    // Define exact boundaries for the channel list area
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    // Calculate channelListWidth dynamically based on content type
    CGFloat programGuideWidth = 350; // Width reserved for program guide
    CGFloat channelListWidth;
    CGFloat movieInfoX;
    
    // Check if we're displaying movies in grid or stacked view (which should take full width)
    BOOL isMovieViewMode = (isGridViewActive || isStackedViewActive) && 
                          ((self.selectedCategoryIndex == CATEGORY_MOVIES) ||
                           (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]));
    
    if (isMovieViewMode) {
        // Movies in grid/stacked view take the full available space
        channelListWidth = self.bounds.size.width - catWidth - groupWidth;
        movieInfoX = self.bounds.size.width; // No movie info panel when in movie view modes
    } else {
        // Regular layout with program guide
        channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
        movieInfoX = catWidth + groupWidth + channelListWidth;
    }
    
    // Calculate the exact start and end points of channel list
    CGFloat channelListStartX = catWidth + groupWidth;
    CGFloat channelListEndX = channelListStartX + channelListWidth;
    
    // Log click coordinates for debugging
    //NSLog(@"Click at point: (%.1f, %.1f) - Channel list bounds: X from %.1f to %.1f", 
          //point.x, point.y, channelListStartX, channelListEndX);
    
    // Check if we're in the settings panel FIRST (before movie info panel check)
    // because settings uses the same area as movie info panel
    if (self.selectedCategoryIndex == CATEGORY_SETTINGS) {
        NSLog(@"Click in settings panel - handling with settings handler");
        return [self handleSettingsClickAtPoint:point];
    }
    
    // Handle search results clicks when in search mode
    if (self.selectedCategoryIndex == CATEGORY_SEARCH) {
        return [self handleSearchResultsClickAtPoint:point];
    }
    
    // Don't process clicks in the movie info panel area (only if NOT in settings or search)
    if (point.x >= channelListEndX) {
        // This is a click in the movie info panel, just update display
        NSLog(@"Click in movie info panel area - ignoring for channel selection");
        [self setNeedsDisplay:YES];
        return YES;  // Return YES to indicate we handled it (by ignoring it for channel selection)
    }
    
    // Don't process clicks in the categories or groups area
    if (point.x < channelListStartX) {
        NSLog(@"Click in categories/groups area - not handling as channel click");
        return NO;
    }
    
    // Use simpleChannelIndexAtPoint which now has improved boundary checking
    NSInteger channelIndex = [self simpleChannelIndexAtPoint:point];
    //NSLog(@"Channel index at click point: %ld", (long)channelIndex);
    
    if (channelIndex >= 0) {
        //NSLog(@"Valid channel clicked - playing channel %ld", (long)channelIndex);
        self.selectedChannelIndex = channelIndex;
        [self playChannelAtIndex:channelIndex];
        [self setNeedsDisplay:YES];
        return YES;
    }
    
    return NO;
}

- (BOOL)handleSettingsClickAtPoint:(NSPoint)point {
    // Check for clicks on settings UI elements
    
    // Get the selected settings group
    NSString *selectedGroup = nil;
    NSArray *settingsGroups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    
    if (self.selectedGroupIndex >= 0 && self.selectedGroupIndex < [settingsGroups count]) {
        selectedGroup = [settingsGroups objectAtIndex:self.selectedGroupIndex];
    }
    
    if ([selectedGroup isEqualToString:@"Playlist"]) {
        // Don't handle button clicks if we're already loading
        if (self.isLoading) {
            NSLog(@"Ignoring button click - operation in progress");
            return YES; // Return YES to indicate we handled the click (even though we ignored it)
        }
        
        // Handle Load From URL button click
        if (NSPointInRect(point, self.loadButtonRect)) {
            NSLog(@"Load From URL button clicked");
            [self loadFromUrlButtonClicked];
            return YES;
        }
        
        // Handle Update EPG button click
        if (NSPointInRect(point, self.epgButtonRect)) {
            NSLog(@"Update EPG button clicked");
            [self updateEpgButtonClicked];
            return YES;
        }
        
        // Handle EPG Time Offset dropdown click
        if (NSPointInRect(point, self.epgTimeOffsetDropdownRect)) {
            NSLog(@"EPG Time Offset dropdown clicked");
            if (self.epgTimeOffsetDropdownActive) {
                self.epgTimeOffsetDropdownActive = NO;
                NSLog(@"EPG Time Offset dropdown closed");
            } else {
                self.epgTimeOffsetDropdownActive = YES;
                NSLog(@"EPG Time Offset dropdown opened");
            }
            [self setNeedsDisplay:YES];
            return YES;
        }
        
        // Handle EPG Time Offset dropdown options (when dropdown is open)
        if (self.epgTimeOffsetDropdownActive) {
            // Calculate dropdown options area
            CGFloat dropdownOptionHeight = 25;
            NSInteger numOptions = 25; // -12 to +12 hours
            CGFloat totalDropdownHeight = numOptions * dropdownOptionHeight;
            NSRect dropdownOptionsRect = NSMakeRect(self.epgTimeOffsetDropdownRect.origin.x,
                                                   self.epgTimeOffsetDropdownRect.origin.y - totalDropdownHeight,
                                                   self.epgTimeOffsetDropdownRect.size.width,
                                                   totalDropdownHeight);
            
            if (NSPointInRect(point, dropdownOptionsRect)) {
                // Calculate which option was clicked
                CGFloat relativeY = point.y - dropdownOptionsRect.origin.y;
                NSInteger optionIndex = (NSInteger)(relativeY / dropdownOptionHeight);
                
                if (optionIndex >= 0 && optionIndex < numOptions) {
                    // Convert option index to hour offset (-12 to +12)
                    NSInteger newOffset = optionIndex - 12;
                    if (self.epgTimeOffsetHours != newOffset) {
                        self.epgTimeOffsetHours = newOffset;
                        NSLog(@"EPG Time Offset changed to: %+d hours", (int)newOffset);
                        
                        // Save the new offset
                        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
                        [defaults setInteger:newOffset forKey:@"EPGTimeOffsetHours"];
                        [defaults synchronize];
                    }
                }
                
                // Close the dropdown
                self.epgTimeOffsetDropdownActive = NO;
                [self setNeedsDisplay:YES];
                return YES;
            }
        }
        
        // Handle other playlist-related UI elements here as needed
        
    } else if ([selectedGroup isEqualToString:@"Themes"]) {
        // Handle theme dropdown click
        if (NSPointInRect(point, self.themeDropdownRect)) {
            VLCDropdown *dropdown = [self.dropdownManager dropdownWithIdentifier:@"theme"];
            if (dropdown) {
                if (dropdown.isOpen) {
                    [self.dropdownManager hideDropdown:@"theme"];
                } else {
                    dropdown.frame = self.themeDropdownRect;
                    [self.dropdownManager showDropdown:@"theme"];
                }
            } else {
                [self setupThemeDropdowns];
                [self.dropdownManager showDropdown:@"theme"];
            }
            return YES;
        }
        
        // Handle transparency slider interaction
        if ([VLCSliderControl isPoint:point inSliderRect:self.transparencySliderRect]) {
            CGFloat value = [VLCSliderControl valueForPoint:point
                                               sliderRect:self.transparencySliderRect
                                                minValue:0.0
                                                maxValue:1.0];
            
            // Use the exact slider value instead of converting to discrete levels
            // This provides smooth transparency adjustment
            if (self.themeAlpha != value) {
                self.themeAlpha = value;
                [self updateThemeColors];
                [self saveThemeSettings];
                [self setNeedsDisplay:YES];
            }
            return YES;
        }
        
        // Handle RGB sliders interactions (only when Custom theme is selected)
        if (self.currentTheme == VLC_THEME_CUSTOM) {
            // Red slider interaction
            if ([VLCSliderControl isPoint:point inSliderRect:self.redSliderRect]) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.redSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customThemeRed != value) {
                    self.customThemeRed = value;
                    [self updateThemeColors];
                    [self saveThemeSettings];
                    [self setNeedsDisplay:YES];
                }
                return YES;
            }
            
            // Green slider interaction
            if ([VLCSliderControl isPoint:point inSliderRect:self.greenSliderRect]) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.greenSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customThemeGreen != value) {
                    self.customThemeGreen = value;
                    [self updateThemeColors];
                    [self saveThemeSettings];
                    [self setNeedsDisplay:YES];
                }
                return YES;
            }
            
            // Blue slider interaction
            if ([VLCSliderControl isPoint:point inSliderRect:self.blueSliderRect]) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.blueSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customThemeBlue != value) {
                    self.customThemeBlue = value;
                    [self updateThemeColors];
                    [self saveThemeSettings];
                    [self setNeedsDisplay:YES];
                }
                return YES;
            }
        }
    }
    
    // Handle Selection Color RGB sliders dragging (always available)
    // Selection Red slider dragging
    NSRect expandedSelectionRedRect = NSMakeRect(self.selectionRedSliderRect.origin.x - 20, 
                                                 self.selectionRedSliderRect.origin.y - 20, 
                                                 self.selectionRedSliderRect.size.width + 40, 
                                                 self.selectionRedSliderRect.size.height + 40);
    
    if (NSPointInRect(point, expandedSelectionRedRect)) {
        CGFloat value = [VLCSliderControl valueForPoint:point
                                           sliderRect:self.selectionRedSliderRect
                                            minValue:0.0
                                            maxValue:1.0];
        
        if (self.customSelectionRed != value) {
            self.customSelectionRed = value;
            [self updateSelectionColors];
            [self saveThemeSettings];
            [self setNeedsDisplay:YES];
        }
        return YES;
    }
    
    // Selection Green slider dragging
    NSRect expandedSelectionGreenRect = NSMakeRect(self.selectionGreenSliderRect.origin.x - 20, 
                                                   self.selectionGreenSliderRect.origin.y - 20, 
                                                   self.selectionGreenSliderRect.size.width + 40, 
                                                   self.selectionGreenSliderRect.size.height + 40);
    
    if (NSPointInRect(point, expandedSelectionGreenRect)) {
        CGFloat value = [VLCSliderControl valueForPoint:point
                                           sliderRect:self.selectionGreenSliderRect
                                            minValue:0.0
                                            maxValue:1.0];
        
        if (self.customSelectionGreen != value) {
            self.customSelectionGreen = value;
            [self updateSelectionColors];
            [self saveThemeSettings];
            [self setNeedsDisplay:YES];
        }
        return YES;
    }
    
    // Selection Blue slider dragging
    NSRect expandedSelectionBlueRect = NSMakeRect(self.selectionBlueSliderRect.origin.x - 20, 
                                                  self.selectionBlueSliderRect.origin.y - 20, 
                                                  self.selectionBlueSliderRect.size.width + 40, 
                                                  self.selectionBlueSliderRect.size.height + 40);
    
    if (NSPointInRect(point, expandedSelectionBlueRect)) {
        CGFloat value = [VLCSliderControl valueForPoint:point
                                           sliderRect:self.selectionBlueSliderRect
                                            minValue:0.0
                                            maxValue:1.0];
        
        if (self.customSelectionBlue != value) {
            self.customSelectionBlue = value;
            [self updateSelectionColors];
            [self saveThemeSettings];
            [self setNeedsDisplay:YES];
        }
        return YES;
    }
    
    return NO;
}

- (BOOL)handleSearchResultsClickAtPoint:(NSPoint)point {
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat programGuideWidth = 350;
    CGFloat channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
    CGFloat channelListStartX = catWidth + groupWidth;
    CGFloat channelListEndX = channelListStartX + channelListWidth;
    
    // Check if click is in channel list area (for channel search results)
    if (point.x >= channelListStartX && point.x < channelListEndX) {
        return [self handleSearchChannelClickAtPoint:point];
    }
    
    // Check if click is in program guide area (for movie search results)
    if (point.x >= channelListEndX) {
        return [self handleSearchMovieClickAtPoint:point];
    }
    
    return NO;
}

- (BOOL)handleSearchChannelClickAtPoint:(NSPoint)point {
    if (!self.searchChannelResults || [self.searchChannelResults count] == 0) {
        return NO;
    }
    
    // Calculate which channel was clicked using the same logic as channel list
    CGFloat rowHeight = 40;
    CGFloat totalY = self.bounds.size.height - point.y + self.searchChannelScrollPosition;
    NSInteger channelIndex = (NSInteger)(totalY / rowHeight);
    
    if (channelIndex >= 0 && channelIndex < [self.searchChannelResults count]) {
        VLCChannel *selectedChannel = [self.searchChannelResults objectAtIndex:channelIndex];
        NSLog(@"Search channel clicked: %@", selectedChannel.name);
        
        // SMART SELECTION: Switch to SEARCH and remember original location
        [self selectSearchAndRememberOriginalLocation:selectedChannel];
        
        // Hide the search interface/controls before playing
        [self hideControls];
        
        // Update the current channel reference for player controls
        self.tmpCurrentChannel = selectedChannel;
        
        // Update selected channel index if we can find it in the main channels list
        // This helps with UI consistency
        if (self.channels) {
            for (NSInteger i = 0; i < [self.channels count]; i++) {
                VLCChannel *channel = [self.channels objectAtIndex:i];
                if ([channel.url isEqualToString:selectedChannel.url]) {
                    self.selectedChannelIndex = i;
                    break;
                }
            }
        }
        
        // Play the channel directly using the VLCChannel object
        [self playChannel:selectedChannel];
        
        // Force immediate UI update to reflect the new channel info
        [self setNeedsDisplay:YES];
        
        // Show player controls with channel information
        // This ensures the player controls display the correct channel info
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // After a short delay (to let playback start), refresh the display
            // to ensure channel info is properly shown in player controls
            [self setNeedsDisplay:YES];
        });
        
        return YES;
    }
    
    return NO;
}

- (BOOL)handleSearchMovieClickAtPoint:(NSPoint)point {
    if (!self.searchMovieResults || [self.searchMovieResults count] == 0) {
        return NO;
    }
    
    // Calculate movie index based on the drawing logic from drawSearchMovieResults
    CGFloat rowHeight = 120; // Match the row height from drawSearchMovieResults
    CGFloat contentAreaY = 30; // Account for header height
    CGFloat totalY = (self.bounds.size.height - contentAreaY - point.y) + self.searchMovieScrollPosition;
    NSInteger movieIndex = (NSInteger)(totalY / rowHeight);
    
    if (movieIndex >= 0 && movieIndex < [self.searchMovieResults count]) {
        VLCChannel *selectedMovie = [self.searchMovieResults objectAtIndex:movieIndex];
        NSLog(@"Search movie clicked: %@", selectedMovie.name);
        
        // SMART SELECTION: Switch to SEARCH and remember original location
        [self selectSearchAndRememberOriginalLocation:selectedMovie];
        
        // Hide the search interface/controls before playing
        [self hideControls];
        
        // Update the current channel reference for player controls
        self.tmpCurrentChannel = selectedMovie;
        
        // Update selected channel index if we can find it in the main channels list
        // This helps with UI consistency
        if (self.channels) {
            for (NSInteger i = 0; i < [self.channels count]; i++) {
                VLCChannel *channel = [self.channels objectAtIndex:i];
                if ([channel.url isEqualToString:selectedMovie.url]) {
                    self.selectedChannelIndex = i;
                    break;
                }
            }
        }
        
        // Play the movie directly using the VLCChannel object
        [self playChannel:selectedMovie];
        
        // Force immediate UI update to reflect the new movie info
        [self setNeedsDisplay:YES];
        
        // Show player controls with movie information
        // This ensures the player controls display the correct movie info
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // After a short delay (to let playback start), refresh the display
            // to ensure movie info is properly shown in player controls
            [self setNeedsDisplay:YES];
        });
        
        return YES;
    }
    
    return NO;
}


// Helper method to calculate cursor position in text field when clicked
- (void)calculateCursorPositionForTextField:(BOOL)isM3uField withPoint:(NSPoint)point {
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *fieldAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSRect fieldRect = isM3uField ? self.m3uFieldRect : self.epgFieldRect;
    NSRect valueRect = NSMakeRect(fieldRect.origin.x + 10, 
                                 fieldRect.origin.y + 7, 
                                 fieldRect.size.width - 20, 
                                 fieldRect.size.height - 14);
    
    NSString *text = isM3uField ? (self.tempM3uUrl ? self.tempM3uUrl : @"") 
                                : (self.tempEpgUrl ? self.tempEpgUrl : @"");
    CGFloat clickX = point.x - valueRect.origin.x;
    NSInteger cursorPosition = 0;
    
    // Find the closest character position to the click
    for (NSInteger i = 1; i <= [text length]; i++) {
        NSString *textUpToI = [text substringToIndex:i];
        CGFloat width = [textUpToI sizeWithAttributes:fieldAttrs].width;
        
        if (width > clickX) {
            // If we're closer to the previous position, use that
            if (i > 0 && width - clickX > clickX - [textUpToI substringToIndex:i-1 > 0 ? i-1 : 0].length) {
                cursorPosition = i - 1;
            } else {
                cursorPosition = i;
            }
            break;
        }
        
        // If we reach the end, put cursor at the end
        if (i == [text length]) {
            cursorPosition = i;
        }
    }
    
    // Update the appropriate cursor position
    if (isM3uField) {
        self.m3uCursorPosition = cursorPosition;
    } else {
        self.epgCursorPosition = cursorPosition;
    }
    
    [style release];
}

- (void)loadFromUrlButtonClicked {
    NSLog(@"loadFromUrlButtonClicked method called");
    
    // Set loading state and start the progress timer immediately
    self.isLoading = YES;
    [self startProgressRedrawTimer];
    [self setLoadingStatusText:@"Preparing to load channel list..."];
    [self setNeedsDisplay:YES];
    
    // Check the M3U URL first - either use temporary edit field or the saved path
    NSString *urlToLoad = nil;
    
    // Priority 1: If there's a temp URL being edited, use that
    if (self.tempM3uUrl && [self.tempM3uUrl length] > 0) {
        urlToLoad = self.tempM3uUrl;
    } 
    // Priority 2: If there's a saved m3uFilePath and it's a URL, use that
    else if (self.m3uFilePath && ([self.m3uFilePath hasPrefix:@"http://"] || [self.m3uFilePath hasPrefix:@"https://"])) {
        urlToLoad = self.m3uFilePath;
        // Also update the temp URL for display
        self.tempM3uUrl = [[NSString alloc] initWithString:self.m3uFilePath];
    }
    
    // Only load if we have a non-empty URL
    if (urlToLoad && [urlToLoad length] > 0) {
        // Check if the URL begins with http:// or https://
        if (![urlToLoad hasPrefix:@"http://"] && ![urlToLoad hasPrefix:@"https://"]) {
            urlToLoad = [@"http://" stringByAppendingString:urlToLoad];
            self.tempM3uUrl = urlToLoad;
        }
        
        // Basic URL validation - use a less strict pattern to allow query params
        NSString *urlPattern = @"^https?://[-A-Za-z0-9+&@#/%?=~_|!:,.;]*[-A-Za-z0-9+&@#/%=~_|]";
        NSPredicate *urlTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", urlPattern];
        BOOL isValid = [urlTest evaluateWithObject:urlToLoad];
        
        if (!isValid) {
            // Show an error message
            [self setLoadingStatusText:@"Error: Invalid URL format"];
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isLoading = NO;
                [self stopProgressRedrawTimer];
                [self setNeedsDisplay:YES];
                
                // Clear error message after a delay
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    if (gProgressMessageLock) {
                        [gProgressMessageLock lock];
                        [gProgressMessage release];
                        gProgressMessage = nil;
                        [gProgressMessageLock unlock];
                    }
                    [self setNeedsDisplay:YES];
                });
            });
            return;
        }
        
        // Set the M3U file path
        self.m3uFilePath = urlToLoad;
        
        // Similarly check EPG URL
        NSString *epgUrlToLoad = nil;
        
        // Priority 1: If there's a temp EPG URL being edited, use that
        if (self.tempEpgUrl && [self.tempEpgUrl length] > 0) {
            epgUrlToLoad = self.tempEpgUrl;
        } 
        // Priority 2: If there's a saved epgUrl and it's a URL, use that
        else if (self.epgUrl && [self.epgUrl length] > 0) {
            epgUrlToLoad = self.epgUrl;
            // Also update the temp URL for display
            self.tempEpgUrl = [[NSString alloc] initWithString:self.epgUrl];
        }
        // Priority 3: Try to auto-generate EPG URL
        else {
            NSString *generatedEpgUrl = [self generateEpgUrlFromM3uUrl:urlToLoad];
            if (generatedEpgUrl) {
                epgUrlToLoad = generatedEpgUrl;
                self.epgUrl = generatedEpgUrl;
                self.tempEpgUrl = generatedEpgUrl;
                //NSLog(@"Auto-generated EPG URL: %@", self.epgUrl);
            }
        }
        
        // Save settings to user defaults
        [self saveSettings];
        
        // Save EPG URL but don't load EPG data yet - wait for channels to load first
        if (epgUrlToLoad && [epgUrlToLoad length] > 0) {
            // Make sure it has http:// prefix
            if (![epgUrlToLoad hasPrefix:@"http://"] && ![epgUrlToLoad hasPrefix:@"https://"]) {
                epgUrlToLoad = [@"http://" stringByAppendingString:epgUrlToLoad];
                self.tempEpgUrl = epgUrlToLoad;
            }
            
            self.epgUrl = epgUrlToLoad;
            // EPG data will be loaded after channels are loaded successfully
        }
        
        // Use the force reload method to always download fresh data
        if ([self respondsToSelector:@selector(forceReloadChannelsAndEpg)]) {
            //NSLog(@"Force reloading channels and EPG data from settings menu");
            [self forceReloadChannelsAndEpg];
        } else {
            // Fallback to regular load if the force method isn't available
            [self loadChannelsFile];
        }
        
        // Deactivate text fields but keep the values
        self.m3uFieldActive = NO;
        self.epgFieldActive = NO;
    } else {
        // Show error for empty URL
        [self setLoadingStatusText:@"Error: Please enter a URL"];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.isLoading = NO;
            [self stopProgressRedrawTimer];
            [self setNeedsDisplay:YES];
            
            // Clear error message after a delay
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (gProgressMessageLock) {
                    [gProgressMessageLock lock];
                    [gProgressMessage release];
                    gProgressMessage = nil;
                    [gProgressMessageLock unlock];
                }
                [self setNeedsDisplay:YES];
            });
        });
    }
}

- (void)updateEpgButtonClicked {
    NSLog(@"updateEpgButtonClicked method called");
    
    // Set loading state and start the progress timer immediately
    self.isLoading = YES;
    [self startProgressRedrawTimer];
    [self setLoadingStatusText:@"Updating EPG data..."];
    [self setNeedsDisplay:YES];
    
    // Check if there's a valid EPG URL
    NSString *epgUrlToLoad = nil;
    
    // Priority 1: If there's a temp EPG URL being edited, use that
    if (self.tempEpgUrl && [self.tempEpgUrl length] > 0) {
        epgUrlToLoad = self.tempEpgUrl;
    } 
    // Priority 2: If there's a saved epgUrl and it's a URL, use that
    else if (self.epgUrl && [self.epgUrl length] > 0) {
        epgUrlToLoad = self.epgUrl;
        // Also update the temp URL for display
        self.tempEpgUrl = [[NSString alloc] initWithString:self.epgUrl];
    }
    
    // Only proceed if we have a valid EPG URL
    if (epgUrlToLoad && [epgUrlToLoad length] > 0) {
        // Make sure it has http:// prefix
        if (![epgUrlToLoad hasPrefix:@"http://"] && ![epgUrlToLoad hasPrefix:@"https://"]) {
            epgUrlToLoad = [@"http://" stringByAppendingString:epgUrlToLoad];
            self.tempEpgUrl = epgUrlToLoad;
        }
        
        // Basic URL validation - use a less strict pattern to allow query params
        NSString *urlPattern = @"^https?://[-A-Za-z0-9+&@#/%?=~_|!:,.;]*[-A-Za-z0-9+&@#/%=~_|]";
        NSPredicate *urlTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", urlPattern];
        BOOL isValid = [urlTest evaluateWithObject:epgUrlToLoad];
        
        if (!isValid) {
            // Show an error message
            [self setLoadingStatusText:@"Error: Invalid EPG URL format"];
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isLoading = NO;
                [self stopProgressRedrawTimer];
                [self setNeedsDisplay:YES];
                
                // Clear error message after a delay
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    if (gProgressMessageLock) {
                        [gProgressMessageLock lock];
                        [gProgressMessage release];
                        gProgressMessage = nil;
                        [gProgressMessageLock unlock];
                    }
                    [self setNeedsDisplay:YES];
                });
            });
            return;
        }
        
        // Save the EPG URL
        self.epgUrl = epgUrlToLoad;
        [self saveSettings];
        
        // Force reload EPG data
        if ([self respondsToSelector:@selector(forceReloadEpgData)]) {
            [self forceReloadEpgData];
        } else {
            // Fallback to regular load if the force method isn't available
            [self loadEpgData];
        }
        
        // Deactivate text fields but keep the values
        self.epgFieldActive = NO;
    } else {
        // Show error for empty EPG URL
        [self setLoadingStatusText:@"Error: Please enter an EPG URL"];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.isLoading = NO;
            [self stopProgressRedrawTimer];
            [self setNeedsDisplay:YES];
            
            // Clear error message after a delay
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (gProgressMessageLock) {
                    [gProgressMessageLock lock];
                    [gProgressMessage release];
                    gProgressMessage = nil;
                    [gProgressMessageLock unlock];
                }
                [self setNeedsDisplay:YES];
            });
        });
    }
}

- (void)mouseMoved:(NSEvent *)event {
    // Handle dropdown manager mouse events first
    if ([self.dropdownManager handleMouseMoved:event]) {
        // Dropdown manager handled the event, redraw and return
        [self setNeedsDisplay:YES];
        return;
    }
    
    // Get the current mouse position
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // Calculate 10% of the window width for the activation zone
    CGFloat activationZone = self.bounds.size.width * 0.1;
    
    // Only show menu when mouse is in the activation zone (left edge)
    // If we're in a fade-out animation, moving the mouse shouldn't trigger showing the menu
    extern BOOL isFadingOut;
    extern NSTimeInterval lastFadeOutTime;
    
    // Check if we're in the cooldown period after a fade-out
    NSTimeInterval currentTime = [NSDate timeIntervalSinceReferenceDate];
    CGFloat fadeOutCooldown = 0.5; // Half-second cooldown to prevent immediate fade-in
    BOOL isInFadeOutCooldown = (currentTime - lastFadeOutTime < fadeOutCooldown);
    
    // Update mouse movement time and show cursor if hidden
    // Call markUserInteraction to properly update both interaction and mouse movement times
    // This ensures cursor hiding works correctly
    if (isCursorHidden) {
        [NSCursor unhide];
        isCursorHidden = NO;
        //NSLog(@"Cursor shown due to mouse movement in UI");
    }
    
    // Update the mouse movement time for cursor hiding logic
    lastMouseMoveTime = currentTime;
    
    // Ensure the cursor hiding timer is running
    // This is important for cursor hiding to work even when not in the activation zone
    if (!autoHideTimer) {
        [self scheduleInteractionCheck];
    }
    
    if (point.x <= activationZone && !isInFadeOutCooldown && !isFadingOut) {
        // Only when mouse is in left activation zone, mark interaction and show menu
        [self markUserInteractionWithMenuShow:YES];
    } else if (self.isChannelListVisible && !isFadingOut) {
        // If menu is visible but mouse is not in activation zone, keep the menu visible
        // but don't trigger showing if it's hidden
        lastInteractionTime = [NSDate timeIntervalSinceReferenceDate];
    }
    
    // Handle player controls visibility - call the new method from PlayerControls category
    // Only trigger showing player controls if menu is not visible
    if (!self.isChannelListVisible) {
        [self handleMouseMovedForPlayerControls];
        return; // Skip ALL menu processing when menu is hidden
    }
    
    // Everything below this point is ONLY for when the menu is visible
    
    // Check if we're currently scrolling (set in scrollWheel method)
    static BOOL isScrolling = NO;
    
    // If scrolling, don't process hover/fetching
    if (isScrolling) {
        return;
    }
    
    // Determine which region the mouse is in
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    // Calculate channelListWidth dynamically based on content type
    CGFloat programGuideWidth = 350; // Width reserved for program guide
    CGFloat channelListWidth;
    CGFloat movieInfoX;
    
    // Check if we're displaying movies in grid or stacked view (which should take full width)
    BOOL isMovieViewMode = (isGridViewActive || isStackedViewActive) && 
                          ((self.selectedCategoryIndex == CATEGORY_MOVIES) ||
                           (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]));
    
    if (isMovieViewMode) {
        // Movies in grid/stacked view take the full available space
        channelListWidth = self.bounds.size.width - catWidth - groupWidth;
        movieInfoX = self.bounds.size.width; // No movie info panel when in movie view modes
    } else {
        // Regular layout with program guide
        channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
        movieInfoX = catWidth + groupWidth + channelListWidth;
    }
    
    // Check if we're hovering over the movie info panel or the EPG panel
    BOOL wasHoveringMovieInfo = self.isHoveringMovieInfoPanel;
    BOOL isInMovieInfoArea = (self.selectedChannelIndex >= 0 && point.x >= movieInfoX);
    BOOL isInEpgPanelArea = self.showEpgPanel && (point.x >= catWidth + groupWidth);
    
    // Handle movie info panel hover
    if (isInMovieInfoArea || isInEpgPanelArea) {
        // We're hovering over the movie info panel or EPG panel
        self.isHoveringMovieInfoPanel = isInMovieInfoArea;
        
        // When entering either panel, restore the last valid hover state
        if ((!wasHoveringMovieInfo || isInEpgPanelArea) && isPersistingHoverState) {
            if (lastValidHoveredChannelIndex >= 0) {
                self.hoveredChannelIndex = lastValidHoveredChannelIndex;
            }
        }
        
        // Mark that we're retaining hover state for either panel
        isPersistingHoverState = YES;
    } else {
        self.isHoveringMovieInfoPanel = NO;
    }
    
    // If we just entered or left the movie info panel, redraw
    if (wasHoveringMovieInfo != self.isHoveringMovieInfoPanel) {
        [self setNeedsDisplay:YES];
    }
    
    // If hovering over movie info panel or EPG panel, don't process other hover states,
    // but keep the last valid hover state active
    // Both cases are handled by isPersistingHoverState flag
    if (self.isHoveringMovieInfoPanel || (self.showEpgPanel && isPersistingHoverState)) {
        // When in any detail panel, we're intentionally keeping the hover state
        isPersistingHoverState = YES;
        return;
    }
    
    // We're back in the main UI, so we can reset the persistence flag
    isPersistingHoverState = NO;
    
    // Store previous hover states
    NSInteger prevHoveredCategoryIndex = self.hoveredCategoryIndex;
    NSInteger prevHoveredGroupIndex = self.hoveredGroupIndex;
    NSInteger prevHoveredChannelIndex = self.hoveredChannelIndex;
    
    // Reset hover states
    self.hoveredCategoryIndex = -1;
    self.hoveredGroupIndex = -1;
    
    // Check if mouse is in categories area (left panel)
    if (point.x >= 0 && point.x < catWidth) {
        // Calculate category index
        CGFloat effectiveY = self.bounds.size.height - point.y;
        NSInteger itemsScrolled = (NSInteger)floor(categoryScrollPosition / 40);
        NSInteger visibleIndex = (NSInteger)floor(effectiveY / 40);
        NSInteger categoryIndex = visibleIndex + itemsScrolled;
        
        if (categoryIndex >= 0 && categoryIndex < [self.categories count]) {
            self.hoveredCategoryIndex = categoryIndex;
        }
    }
    
    // Only reset hover indices if we're in the channel list or another actionable area
    // This prevents clearing when moving to EPG panel
    if (point.x >= catWidth && point.x < catWidth + groupWidth + channelListWidth) {
    self.hoveredGroupIndex = -1;
    
    if (point.x >= catWidth && point.x < catWidth + groupWidth) {
        // Mouse is in the group list
        if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < [self.categories count]) {
            // Calculate group index with precision to avoid fractional errors
            CGFloat effectiveY = self.bounds.size.height - point.y;
            NSInteger itemsScrolled = (NSInteger)floor(groupScrollPosition / 40);
            NSInteger visibleIndex = (NSInteger)floor(effectiveY / 40);
            NSInteger groupIndex = visibleIndex + itemsScrolled;
            
            // Validate index against current group list
            NSArray *groups = nil;
            NSString *categoryName = [self.categories objectAtIndex:self.selectedCategoryIndex];
            
            if ([categoryName isEqualToString:@"FAVORITES"]) {
                groups = [self safeGroupsForCategory:@"FAVORITES"];
            } else if ([categoryName isEqualToString:@"TV"]) {
                groups = [self safeTVGroups];
            } else if ([categoryName isEqualToString:@"MOVIES"]) {
                groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
            } else if ([categoryName isEqualToString:@"SERIES"]) {
                groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
            } else if ([categoryName isEqualToString:@"SETTINGS"]) {
                groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
            }
            
            if (groups && groupIndex >= 0 && groupIndex < [groups count]) {
                self.hoveredGroupIndex = groupIndex;
            }
        }
    }
    } // Close the if-block opened earlier for restricting hover reset
    
    // Define exact channel list boundaries for clarity
    CGFloat channelListStartX = catWidth + groupWidth;
    CGFloat channelListEndX = channelListStartX + channelListWidth;
    
    // Check if we're in the channel list area
    BOOL isInChannelListArea = (point.x >= channelListStartX && point.x < channelListEndX);
   // NSLog(@"Mouse is %s channel list area", isInChannelListArea ? "in" : "outside");
    
    // If we're in grid view, handle channel hovering differently
    if (isGridViewActive && isInChannelListArea) {
        NSInteger gridIndex = [self gridItemIndexAtPoint:point];
        if (gridIndex != self.hoveredChannelIndex) {
            self.hoveredChannelIndex = gridIndex;
            [self setNeedsDisplay:YES];
            
            // If valid grid item is hovered, initiate movie info loading
            if (gridIndex >= 0) {
                NSArray *channels = [self getChannelsForCurrentGroup];
                if (channels && gridIndex < channels.count) {
                    VLCChannel *channel = [channels objectAtIndex:gridIndex];
                    // REMOVED: Don't auto-download on hover - handled by validateMovieInfoForVisibleItems
                    // [self queueAsyncLoadForGridChannel:channel atIndex:gridIndex];
                }
            }
        }
    } else if (isInChannelListArea) {
        // In list view, use the regular channel hover logic - only when actually in the channel list area
    NSInteger channelIndex = [self simpleChannelIndexAtPoint:point];
        //NSLog(@"Channel index at point: %ld", (long)channelIndex);
    
    if (channelIndex != self.hoveredChannelIndex) {
        // Cancel any pending movie info timer if the user moved to a different channel
        if (movieInfoHoverTimer) {
            [movieInfoHoverTimer invalidate];
            movieInfoHoverTimer = nil;
            self.isPendingMovieInfoFetch = NO;
        }
        
        self.hoveredChannelIndex = channelIndex;
        
        // Add debug logging to check if channel hover is detected
        if (channelIndex >= 0) {
            //NSLog(@"Hovering over channel index: %ld", (long)channelIndex);
            
            // Get the actual channel object to show more info
            VLCChannel *channel = [self getChannelAtHoveredIndex];
            if (channel) {
                //NSLog(@"Hover channel: %@, logo: %@, category: %@", 
                //      channel.name, channel.logo ? channel.logo : @"No logo", 
                //      channel.category ? channel.category : @"No category");
                
                // If it's a movie channel, set up delayed fetch
                if ([channel.category isEqualToString:@"MOVIES"] && !channel.hasLoadedMovieInfo) {
                    // Store the current hovered channel index and timestamp
                    lastHoveredChannelIndex = channelIndex;
                    lastHoverTime = [NSDate timeIntervalSinceReferenceDate];
                    
                    // Set flag to indicate a pending fetch
                    self.isPendingMovieInfoFetch = YES;
                    
                    // Create a timer that will trigger after the hover delay (0.7 seconds)
                    if (movieInfoHoverTimer) {
                        [movieInfoHoverTimer invalidate];
                    }
                    
                    movieInfoHoverTimer = [NSTimer scheduledTimerWithTimeInterval:0.7
                                                                          target:self
                                                                        selector:@selector(checkAndFetchMovieInfo:)
                                                                        userInfo:nil
                                                                         repeats:NO];
                }
            }
        } else {
            //NSLog(@"No channel hovered");
        }
        
        [self setNeedsDisplay:YES];
        }
    }
    
    // Only redraw if the hover state changed
    if (prevHoveredCategoryIndex != self.hoveredCategoryIndex || 
        prevHoveredGroupIndex != self.hoveredGroupIndex || 
        prevHoveredChannelIndex != self.hoveredChannelIndex) {
        [self setNeedsDisplay:YES];
    }
    
    // Handle dropdown hover states
    [self handleDropdownHover:point];
}
// Timer callback to check if we should fetch movie info
- (void)checkAndFetchMovieInfo:(NSTimer *)timer {
    // Only proceed if still hovering on same channel
    if (self.hoveredChannelIndex == lastHoveredChannelIndex && self.isPendingMovieInfoFetch) {
        VLCChannel *channel = [self getChannelAtHoveredIndex];
        if (channel && [channel.category isEqualToString:@"MOVIES"] && !channel.hasLoadedMovieInfo) {
            NSLog(@"Hover timer elapsed - fetching movie info for: %@", channel.name);
            
            // Check if movie info is already cached in user defaults first
            BOOL loadedFromCache = [self loadMovieInfoFromCacheForChannel:channel];
            
            // Only fetch from network if not successfully loaded from cache
            if (!loadedFromCache) {
                // Add a property to track that fetching has started but not completed
                channel.hasStartedFetchingMovieInfo = YES;
                // Don't mark hasLoadedMovieInfo as true yet - wait until fetch completes
                
                // Use GCD to perform the fetch in background
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                    [self fetchMovieInfoForChannelAsync:channel];
                });
            }
        }
    }
    
    // Reset the flag
    self.isPendingMovieInfoFetch = NO;
    movieInfoHoverTimer = nil;
}

// Add a method to save movie info to cache
- (void)saveMovieInfoToCache:(VLCChannel *)channel {
    if (!channel || !channel.name) return;
    
    // CRITICAL FIX: Only save to cache if we have useful data
    // Check if we have at least a meaningful description OR sufficient metadata
    BOOL hasUsefulDescription = (channel.movieDescription && [channel.movieDescription length] > 10); // At least 10 chars
    BOOL hasUsefulMetadata = ((channel.movieYear && [channel.movieYear length] > 0) || 
                             (channel.movieGenre && [channel.movieGenre length] > 0) || 
                             (channel.movieDirector && [channel.movieDirector length] > 0) || 
                             (channel.movieRating && [channel.movieRating length] > 0));
    
    if (!hasUsefulDescription && !hasUsefulMetadata) {
        NSLog(@"üö´ NOT saving incomplete movie info to cache for '%@' (desc: %ld chars, has metadata: %@)", 
              channel.name, (long)[channel.movieDescription length], hasUsefulMetadata ? @"YES" : @"NO");
        return;
    }
    
    // Get the movie info cache directory
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *movieInfoCacheDir = [appSupportDir stringByAppendingPathComponent:@"MovieInfo"];
    
    // Create the directory if it doesn't exist
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:movieInfoCacheDir]) {
        NSError *dirError = nil;
        [fileManager createDirectoryAtPath:movieInfoCacheDir 
                withIntermediateDirectories:YES 
                                 attributes:nil 
                                      error:&dirError];
        if (dirError) {
            //NSLog(@"Error creating movie info cache directory: %@", dirError);
            return;
        } else {
            //NSLog(@"Created movie info cache directory: %@", movieInfoCacheDir);
        }
    }
    
    // Create a safe filename from the channel name
    NSString *safeFilename = [self md5HashForString:channel.name];
    NSString *cacheFilePath = [movieInfoCacheDir stringByAppendingPathComponent:
                              [NSString stringWithFormat:@"%@.plist", safeFilename]];
    
    // Create dictionary with all movie properties
    NSMutableDictionary *movieInfo = [NSMutableDictionary dictionary];
    if (channel.movieId) [movieInfo setObject:channel.movieId forKey:@"movieId"];
    if (channel.movieDescription) [movieInfo setObject:channel.movieDescription forKey:@"description"];
    if (channel.movieGenre) [movieInfo setObject:channel.movieGenre forKey:@"genre"];
    if (channel.movieYear) [movieInfo setObject:channel.movieYear forKey:@"year"];
    if (channel.movieRating) [movieInfo setObject:channel.movieRating forKey:@"rating"];
    if (channel.movieDuration) [movieInfo setObject:channel.movieDuration forKey:@"duration"];
    if (channel.movieDirector) [movieInfo setObject:channel.movieDirector forKey:@"director"];
    if (channel.movieCast) [movieInfo setObject:channel.movieCast forKey:@"cast"];
    if (channel.logo) [movieInfo setObject:channel.logo forKey:@"logo"];
    
    // Only save if we have some data (this check should now always pass due to validation above)
    if (movieInfo.count > 0) {
        // Add timestamp for cache invalidation
        [movieInfo setObject:@([[NSDate date] timeIntervalSince1970]) forKey:@"timestamp"];
        
        // Write to a temporary file first for atomicity
        NSString *tempPath = [cacheFilePath stringByAppendingString:@".temp"];
        BOOL success = [movieInfo writeToFile:tempPath atomically:YES];
        
        if (success) {
            NSError *moveError = nil;
            // Remove existing file if it exists
            if ([fileManager fileExistsAtPath:cacheFilePath]) {
                [fileManager removeItemAtPath:cacheFilePath error:nil];
            }
            // Move the temp file to the final location
            BOOL moveSuccess = [fileManager moveItemAtPath:tempPath toPath:cacheFilePath error:&moveError];
            
            if (moveSuccess) {
                NSLog(@"üíæ Saved USEFUL movie info for '%@' to cache - desc: %ld chars, metadata: %@", 
                      channel.name, (long)[channel.movieDescription length], hasUsefulMetadata ? @"YES" : @"NO");
            } else {
                //NSLog(@"Failed to move temp file to cache path: %@, error: %@", cacheFilePath, moveError);
            }
        } else {
            //NSLog(@"Failed to write movie info to temp file: %@", tempPath);
        }
    }
}

// Add a method to load movie info from cache
- (BOOL)loadMovieInfoFromCacheForChannel:(VLCChannel *)channel {
    if (!channel || !channel.name) return NO;
    
    // Get the movie info cache directory
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *movieInfoCacheDir = [appSupportDir stringByAppendingPathComponent:@"MovieInfo"];
    
    // Create a safe filename from the channel name
    NSString *safeFilename = [self md5HashForString:channel.name];
    NSString *cacheFilePath = [movieInfoCacheDir stringByAppendingPathComponent:
                               [NSString stringWithFormat:@"%@.plist", safeFilename]];
    
    // Check if cache file exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cacheFilePath]) {
        NSLog(@"No cache file found for channel: %@ at path: %@", channel.name, cacheFilePath);
        return NO;
    }
    
    // Load the plist file
    NSDictionary *movieInfo = [NSDictionary dictionaryWithContentsOfFile:cacheFilePath];
    
    // Check if we have cached data and it's not too old (30 days)
    if (movieInfo) {
        NSNumber *timestamp = [movieInfo objectForKey:@"timestamp"];
        if (timestamp) {
            NSTimeInterval cacheAge = [[NSDate date] timeIntervalSince1970] - [timestamp doubleValue];
            if (cacheAge < (30 * 24 * 60 * 60)) { // 30 days in seconds (extended from 7 days)
                
                // CRITICAL FIX: Validate that cached data is actually useful before loading it
                NSString *cachedDescription = [movieInfo objectForKey:@"description"];
                NSString *cachedYear = [movieInfo objectForKey:@"year"];
                NSString *cachedGenre = [movieInfo objectForKey:@"genre"];
                NSString *cachedDirector = [movieInfo objectForKey:@"director"];
                NSString *cachedRating = [movieInfo objectForKey:@"rating"];
                
                // Check if we have at least a meaningful description OR sufficient metadata
                BOOL hasUsefulDescription = (cachedDescription && [cachedDescription length] > 10); // At least 10 chars
                BOOL hasUsefulMetadata = ((cachedYear && [cachedYear length] > 0) || 
                                         (cachedGenre && [cachedGenre length] > 0) || 
                                         (cachedDirector && [cachedDirector length] > 0) || 
                                         (cachedRating && [cachedRating length] > 0));
                
                if (!hasUsefulDescription && !hasUsefulMetadata) {
                    NSLog(@"‚ùå Cached data for '%@' is incomplete (desc: %ld chars, has metadata: %@) - removing cache and allowing fresh fetch", 
                          channel.name, (long)[cachedDescription length], hasUsefulMetadata ? @"YES" : @"NO");
                    
                    // Remove the incomplete cache file
                    [fileManager removeItemAtPath:cacheFilePath error:nil];
                    return NO;
                }
                
                // Load data from cache only if it passes validation
                channel.movieId = [movieInfo objectForKey:@"movieId"];
                channel.movieDescription = cachedDescription;
                channel.movieGenre = cachedGenre;
                channel.movieYear = cachedYear;
                channel.movieRating = cachedRating;
                channel.movieDuration = [movieInfo objectForKey:@"duration"];
                channel.movieDirector = [movieInfo objectForKey:@"director"];
                channel.movieCast = [movieInfo objectForKey:@"cast"];
                
                // Mark as loaded
                channel.hasStartedFetchingMovieInfo = YES;
                channel.hasLoadedMovieInfo = YES;
                
                // Also try to load cached poster image from disk
                [self loadCachedPosterImageForChannel:channel];
                
                NSLog(@"‚úÖ Successfully loaded USEFUL movie info from cache for '%@': %ld chars description, metadata: %@", 
                      channel.name, (long)[channel.movieDescription length], hasUsefulMetadata ? @"YES" : @"NO");
                return YES;
            } else {
                NSLog(@"Cache file too old for channel: %@ (%.1f days old)", channel.name, cacheAge / (24 * 60 * 60));
                // Remove old cache file
                [fileManager removeItemAtPath:cacheFilePath error:nil];
            }
        } else {
            NSLog(@"No timestamp in cache file for channel: %@", channel.name);
        }
    } else {
        NSLog(@"Failed to load plist data from cache file for channel: %@", channel.name);
    }
    
    return NO;
}

// Add methods for persistent image caching
- (NSString *)cacheDirectoryPath {
    // Use Application Support instead of NSCachesDirectory for better persistence
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *cacheDir = [appSupportDir stringByAppendingPathComponent:@"Cache"];
    
    // Create directory if it doesn't exist
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cacheDir]) {
        NSError *error = nil;
        [fileManager createDirectoryAtPath:cacheDir withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            //NSLog(@"Error creating cache directory: %@", [error localizedDescription]);
        } else {
            //NSLog(@"Created cache directory: %@", cacheDir);
        }
    }
    
    return cacheDir;
}

// Get the posters cache directory
- (NSString *)postersCacheDirectory {
    NSString *postersDir = [[self cacheDirectoryPath] stringByAppendingPathComponent:@"Posters"];
    
    // Create directory if it doesn't exist
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:postersDir]) {
        NSError *error = nil;
        [fileManager createDirectoryAtPath:postersDir withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            //NSLog(@"Error creating posters cache directory: %@", [error localizedDescription]);
        } else {
            //NSLog(@"Created posters cache directory: %@", postersDir);
        }
    }
    
    return postersDir;
}

- (NSString *)cachePathForImageURL:(NSString *)url {
    if (!url || url.length == 0) return nil;
    
    // Create a unique filename based on the URL
    NSString *filename = [self md5HashForString:url];
    
    // Add the original extension if it exists
    NSString *extension = [url pathExtension];
    if (extension && extension.length > 0) {
        filename = [filename stringByAppendingFormat:@".%@", extension];
    } else {
        filename = [filename stringByAppendingString:@".png"];
    }
    
    return [[self postersCacheDirectory] stringByAppendingPathComponent:filename];
}

// Save poster image to disk cache
- (void)savePosterImageToDiskCache:(NSImage *)image forURL:(NSString *)url {
    if (!image || !url || url.length == 0) return;
    
    NSString *cachePath = [self cachePathForImageURL:url];
    if (cachePath) {
        // Make sure the directory exists
        NSString *directory = [cachePath stringByDeletingLastPathComponent];
        NSFileManager *fileManager = [NSFileManager defaultManager];
        if (![fileManager fileExistsAtPath:directory]) {
            NSError *dirError = nil;
            [fileManager createDirectoryAtPath:directory 
                    withIntermediateDirectories:YES 
                                     attributes:nil 
                                          error:&dirError];
            if (dirError) {
                //NSLog(@"Error creating movie poster cache directory: %@", dirError);
                return;
            }
        }
        
        // Convert NSImage to data using TIFF representation
        NSData *imageData = [image TIFFRepresentation];
        if (!imageData) {
            //NSLog(@"Failed to get TIFF representation for image");
            return;
        }
        
        NSBitmapImageRep *imageRep = [NSBitmapImageRep imageRepWithData:imageData];
        if (!imageRep) {
            //NSLog(@"Failed to create bitmap rep from image data");
            return;
        }
        
        NSDictionary *imageProps = @{NSImageCompressionFactor: @0.8};
        NSData *pngData = [imageRep representationUsingType:NSPNGFileType properties:imageProps];
        
        if (pngData) {
            // Write to a temporary file first, then move to final location for atomicity
            NSString *tempPath = [cachePath stringByAppendingString:@".temp"];
            BOOL tempSuccess = [pngData writeToFile:tempPath atomically:YES];
            
            if (tempSuccess) {
                NSError *moveError = nil;
                // Remove existing file if it exists
                if ([fileManager fileExistsAtPath:cachePath]) {
                    [fileManager removeItemAtPath:cachePath error:nil];
                }
                // Move the temp file to the final location
                BOOL moveSuccess = [fileManager moveItemAtPath:tempPath toPath:cachePath error:&moveError];
                
                if (moveSuccess) {
                    //NSLog(@"Successfully saved image to disk cache: %@", cachePath);
                } else {
                    //NSLog(@"Failed to move temp file to cache path: %@, error: %@", cacheFilePath, moveError);
                }
            } else {
                //NSLog(@"Failed to write image to temp path: %@", tempPath);
            }
        } else {
            //NSLog(@"Failed to create PNG data from image representation");
        }
    } else {
        //NSLog(@"Invalid cache path for URL: %@", url);
    }
}

// Load poster image from disk cache - Improved lazy loading version with memory management
- (void)loadCachedPosterImageForChannel:(VLCChannel *)channel {
    if (!channel || !channel.logo || channel.logo.length == 0) return;
    
    // Don't load if already in memory - this prevents unnecessary disk I/O
    if (channel.cachedPosterImage) {
        return;
    }
    
    NSString *cachePath = [self cachePathForImageURL:channel.logo];
    if (cachePath) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        if ([fileManager fileExistsAtPath:cachePath]) {
            // Check file age to ensure cache is still valid (e.g., not older than 30 days)
            NSError *error;
            NSDictionary *attributes = [fileManager attributesOfItemAtPath:cachePath error:&error];
            if (attributes && !error) {
                NSDate *modificationDate = [attributes fileModificationDate];
                NSTimeInterval age = [[NSDate date] timeIntervalSinceDate:modificationDate];
                
                // Cache expires after 30 days (2592000 seconds)
                if (age > 2592000) {
                    NSLog(@"Cache file expired for %@, removing", channel.name);
                    [fileManager removeItemAtPath:cachePath error:nil];
                    return;
                }
            }
            
            // Load the cached image data
            NSData *imageData = [NSData dataWithContentsOfFile:cachePath];
            if (imageData && imageData.length > 0) {
                NSImage *cachedImage = [[NSImage alloc] initWithData:imageData];
                if (cachedImage) {
                    channel.cachedPosterImage = cachedImage;
                    //NSLog(@"Loaded poster image from disk cache for channel: %@ (%.1f KB)", 
                    //      channel.name, (float)imageData.length / 1024.0);
                    [cachedImage release];
                } else {
                    //NSLog(@"Failed to create image from cached data for %@, removing corrupt cache", channel.name);
                    [fileManager removeItemAtPath:cachePath error:nil];
                }
            } else {
                //NSLog(@"Empty or corrupt cache file for %@, removing", channel.name);
                [fileManager removeItemAtPath:cachePath error:nil];
            }
        }
    }
}

// Improve fetchMovieInfoForChannelAsync to properly mark hasLoadedMovieInfo and save to cache
- (void)fetchMovieInfoForChannelAsync:(VLCChannel *)channel {
    if (!channel) return;
    
    NSLog(@"Starting async movie info fetch for: %@", channel.name);
    
    // Fetch movie info synchronously on background thread
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Call the actual movie info fetching logic from ChannelManagement category
        [self fetchMovieInfoForChannel:channel];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            // Always clear the fetching flag when done (success or failure)
            channel.hasStartedFetchingMovieInfo = NO;
            
            // Check if we actually got useful movie info
            BOOL hasUsefulInfo = NO;
            if (channel.movieDescription && [channel.movieDescription length] > 0) {
                hasUsefulInfo = YES;
            } else if (channel.movieYear && [channel.movieYear length] > 0) {
                hasUsefulInfo = YES;
            } else if (channel.movieGenre && [channel.movieGenre length] > 0) {
                hasUsefulInfo = YES;
            } else if (channel.movieDirector && [channel.movieDirector length] > 0) {
                hasUsefulInfo = YES;
            } else if (channel.movieRating && [channel.movieRating length] > 0) {
                hasUsefulInfo = YES;
            }
            
            // Handle the result
            if (hasUsefulInfo) {
                channel.hasLoadedMovieInfo = YES;
                
                // Save the info to cache after successful fetching
                [self saveMovieInfoToCache:channel];
                
                NSLog(@"‚úÖ Successfully fetched movie info for '%@' - Description: %ld chars, Year: %@, Genre: %@", 
                      channel.name, (long)[channel.movieDescription length], channel.movieYear, channel.movieGenre);
            } else {
                // No useful info found - reset flags to allow retry later
                channel.hasLoadedMovieInfo = NO;
                channel.hasStartedFetchingMovieInfo = NO;
                
                NSLog(@"‚ùå No useful movie info found for '%@' - flags reset for retry", channel.name);
            }
            
            // Trigger UI update to show the new information
            [self setNeedsDisplay:YES];
        });
    });
}

- (void)mouseExited:(NSEvent *)event {
    // Cancel any pending movie info timer
    if (movieInfoHoverTimer) {
        [movieInfoHoverTimer invalidate];
        movieInfoHoverTimer = nil;
        self.isPendingMovieInfoFetch = NO;
    }
    
    // Store the last valid hover states before clearing them
    if (self.hoveredChannelIndex >= 0) {
        lastValidHoveredChannelIndex = self.hoveredChannelIndex;
        isPersistingHoverState = YES;
        
        //NSLog(@"Stored last hovered channel index: %ld", (long)lastValidHoveredChannelIndex);
    }
    
    if (self.hoveredGroupIndex >= 0) {
        lastValidHoveredGroupIndex = self.hoveredGroupIndex;
        isPersistingHoverState = YES;
    }
    
    // Only clear the hover indices but don't redraw yet
    // This allows the movie info panel or EPG panel to continue showing content
    // based on the last hovered channel
    self.hoveredChannelIndex = -1;
    self.hoveredGroupIndex = -1;
    
    // Only redraw if we're not preserving hover state
    // We'll keep the movie info panel or EPG panel visible with the last selected channel
    if (!isPersistingHoverState) {
        [self setNeedsDisplay:YES];
    }
}

- (void)scrollWheel:(NSEvent *)event {
    [self markUserInteraction];
    
    // Check for dropdown scrolling first
    if (self.dropdownManager && [self.dropdownManager handleScrollWheel:event]) {
        return; // Dropdown handled the scroll, don't process other scrolling
    }
    
    // If menu is not visible, don't process any menu-related scrolling
    if (!self.isChannelListVisible) {
        return;
    }
    
    // Set a flag to indicate we're scrolling (to disable movie info fetching)
    static BOOL isScrolling = NO;
    isScrolling = YES;
    
    // Cancel any pending movie info requests when scrolling starts
    if (movieInfoHoverTimer) {
        [movieInfoHoverTimer invalidate];
        movieInfoHoverTimer = nil;
        self.isPendingMovieInfoFetch = NO;
    }
    
    // Make scroll bars visible when scrolling starts
    scrollBarAlpha = 1.0;
    
    // Reset fade timer if it exists
    if (scrollBarFadeTimer) {
        [scrollBarFadeTimer invalidate];
        scrollBarFadeTimer = nil;
    }
    
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // Determine which panel to scroll
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    // Calculate channelListWidth dynamically based on content type
    CGFloat programGuideWidth = 350; // Width reserved for program guide
    CGFloat channelListWidth;
    CGFloat movieInfoX;
    
    // Check if we're displaying movies in grid or stacked view (which should take full width)
    BOOL isMovieViewMode = (isGridViewActive || isStackedViewActive) && 
                          ((self.selectedCategoryIndex == CATEGORY_MOVIES) ||
                           (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]));
    
    if (isMovieViewMode) {
        // Movies in grid/stacked view take the full available space
        channelListWidth = self.bounds.size.width - catWidth - groupWidth;
        movieInfoX = self.bounds.size.width; // No movie info panel when in movie view modes
    } else {
        // Regular layout with program guide
        channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
        movieInfoX = catWidth + groupWidth + channelListWidth;
    }
    
    // Check for EPG panel scrolling - using programGuideWidth value that matches drawProgramGuideForHoveredChannel
    programGuideWidth = 400; // Match the width used in drawProgramGuideForHoveredChannel
    CGFloat guidePanelX = catWidth + groupWidth + channelListWidth;
    CGFloat guideEndX = self.bounds.size.width; // EPG panel extends to the right edge
    
    // Check if mouse is in program guide area
    BOOL isInEpgPanelArea = (point.x >= guidePanelX);
    
    // Handle EPG panel scrolling or search movie results scrolling
    if (isInEpgPanelArea) {
        // Check if we're in search mode with movie results
        if (self.selectedCategoryIndex == CATEGORY_SEARCH && self.searchMovieResults && [self.searchMovieResults count] > 0) {
            // Calculate scroll amount for search movie results
            CGFloat scrollAmount = -[event deltaY] * 12;
            
            // Calculate max scroll for movie search results
            CGFloat rowHeight = 120; // Match the row height from drawSearchMovieResults
            CGFloat totalContentHeight = [self.searchMovieResults count] * rowHeight;
            CGFloat visibleHeight = self.bounds.size.height - 30; // Account for header
            CGFloat maxScroll = MAX(0, totalContentHeight - visibleHeight);
            
            // Update scroll position
            self.searchMovieScrollPosition += scrollAmount;
            self.searchMovieScrollPosition = MAX(0, self.searchMovieScrollPosition);
            self.searchMovieScrollPosition = MIN(maxScroll, self.searchMovieScrollPosition);
            
            // Redraw
            [self setNeedsDisplay:YES];
            
            // Return here to prevent other panels from scrolling
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                isScrolling = NO;
            });
            return;
        }
        // Handle regular EPG panel scrolling
        else if (self.hoveredChannelIndex >= 0 || self.selectedChannelIndex >= 0) {
            // Calculate scroll amount exactly like the channel list, using -deltaY * 12
            CGFloat scrollAmount = -[event deltaY] * 12;
            
            // Get the appropriate channel for calculations
            VLCChannel *channel = nil;
            if (self.hoveredChannelIndex >= 0) {
                channel = [self getChannelAtHoveredIndex];
            } 
            else if (self.selectedChannelIndex >= 0) {
                channel = [self getChannelAtIndex:self.selectedChannelIndex];
            }
            
            if (channel && channel.programs) {
                // Calculate program count and dimensions exactly as in the drawing code
                NSInteger programCount = [channel.programs count];
                CGFloat entryHeight = 65;
                CGFloat entrySpacing = 8;
                
                // Calculate total content height
                CGFloat totalContentHeight = (programCount * (entryHeight + entrySpacing));
                
                // Calculate visible height
                CGFloat visibleHeight = self.bounds.size.height;
                
                // Calculate maxScroll
                CGFloat maxScroll = MAX(0, totalContentHeight - visibleHeight);
                
                // Update scroll position
                self.epgScrollPosition += scrollAmount;
                self.epgScrollPosition = MAX(0, self.epgScrollPosition);
                self.epgScrollPosition = MIN(maxScroll, self.epgScrollPosition);
                
                // Mark that user has manually scrolled the EPG
                hasUserScrolledEpg = YES;
                
                //NSLog(@"EPG scrolling: position=%.1f, maxScroll=%.1f, programs=%ld, contentHeight=%.1f", 
                //      self.epgScrollPosition, maxScroll, (long)programCount, totalContentHeight);
            }
            
            // Redraw
            [self setNeedsDisplay:YES];
            
            // Return here to prevent other panels from scrolling
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                isScrolling = NO;
            });
            return;
        }
    }
    
    // Check movie info area
    if (point.x >= movieInfoX) {
        // We're in the movie info panel area - only scroll this panel if it's active
        if (self.selectedChannelIndex >= 0) {
            //NSLog(@"Scrolling movie info panel");
            // Calculate scroll amount (inverted for natural scroll direction)
            CGFloat scrollAmount = -[event deltaY] * 20; // Doubled scroll speed for better responsiveness
            
            // Get the selected channel
            VLCChannel *selectedChannel = [self getChannelAtIndex:self.selectedChannelIndex];
            if (selectedChannel) {
                // Adjust the movie info scroll position
                self.movieInfoScrollPosition += scrollAmount;
                self.movieInfoScrollPosition = MAX(0, self.movieInfoScrollPosition);
                
                // Calculate maximum scroll position based on content
                // Set to a very high value to ensure sufficient scrolling range
                CGFloat contentHeight = 5000; // Significantly increased to guarantee scrollable content
                
                // Adjust based on actual content (description length, etc.)
                if (selectedChannel.movieDescription) {
                    // Much more aggressive scaling factor to ensure scrolling works
                    NSInteger descriptionLength = [selectedChannel.movieDescription length];
                    // Using a much higher scaling factor - this is key to making scrolling work
                    contentHeight = MAX(contentHeight, 1000 + (descriptionLength * 5.0)); // Very aggressive approximation
                    
                    //NSLog(@"SCROLL EVENT: Movie description length: %ld, calculated content height: %.1f, current scroll pos: %.1f", 
                          //(long)descriptionLength, contentHeight, self.movieInfoScrollPosition);
                }
                
                // Calculate max scroll with extra buffer
                CGFloat maxScroll = MAX(0, contentHeight - self.bounds.size.height);
                CGFloat oldScrollPos = self.movieInfoScrollPosition;
                self.movieInfoScrollPosition = MIN(maxScroll, self.movieInfoScrollPosition);
                
                NSLog(@"Movie info scrolling: oldPos=%.1f, newPos=%.1f, delta=%.1f, maxScroll=%.1f", 
                      oldScrollPos, self.movieInfoScrollPosition, 
                      self.movieInfoScrollPosition - oldScrollPos, maxScroll);
                
                // Use throttled update instead of immediate redraw during scrolling
                [self throttledDisplayUpdate];
            }
            
            // Return here to prevent scrolling other panels when mouse is in movie info area
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                isScrolling = NO;
            });
            return;
        }
    }
    
    // Calculate scroll amount (inverted for natural scroll direction)
    CGFloat scrollAmount = -[event deltaY] * 10; // Negative sign inverts direction
    
    if (point.x < catWidth) {
        // Scroll categories
        categoryScrollPosition += scrollAmount;
        
        // Limit scrolling
        categoryScrollPosition = MAX(0, categoryScrollPosition);
        // Add extra space to ensure the last item is fully visible
        CGFloat maxScroll = MAX(0, ([self.categories count] * 40 + 40) - self.bounds.size.height);
        categoryScrollPosition = MIN(maxScroll, categoryScrollPosition);
    } else if (point.x < catWidth + groupWidth) {
        // Scroll groups
        if (self.selectedCategoryIndex < 0 || self.selectedCategoryIndex >= [self.categories count]) {
            return;
        }
        
        groupScrollPosition += scrollAmount;
        
        // Limit scrolling
        groupScrollPosition = MAX(0, groupScrollPosition);
        
        NSArray *groups;
        NSString *categoryName = [self.categories objectAtIndex:self.selectedCategoryIndex];
        
        if ([categoryName isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([categoryName isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([categoryName isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([categoryName isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        } else if ([categoryName isEqualToString:@"SETTINGS"]) {
            groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        } else {
            return;
        }
        
        // Add extra space to ensure the last item is fully visible
        CGFloat maxScroll = MAX(0, ([groups count] * 40 + 40) - self.bounds.size.height);
        groupScrollPosition = MIN(maxScroll, groupScrollPosition);
    } else {
        // Calculate channel list boundaries
        CGFloat channelListStartX = catWidth + groupWidth;
        CGFloat channelListEndX = channelListStartX + channelListWidth;
        
        // Only scroll the channel list if the mouse is actually in the channel list area
        BOOL isInChannelListArea = (point.x >= channelListStartX && point.x < channelListEndX);
        
        // Only scroll if in the channel list section
        if (isInChannelListArea) {
            // Scroll channels or grid
            if (isGridViewActive) {
                // For grid view, get the content dimensions
                NSArray *channels = [self getChannelsForCurrentGroup];
                if (channels && channels.count > 0) {
                    // Calculate grid metrics
                    CGFloat gridX = catWidth + groupWidth;
                    CGFloat gridWidth = self.bounds.size.width - gridX;
                    CGFloat itemPadding = 10;
                    CGFloat itemWidth = MIN(180, (gridWidth / 2) - (itemPadding * 2));
                    CGFloat itemHeight = itemWidth * 1.5;
                    CGFloat contentHeight = self.bounds.size.height - 40; // Account for header
                    
                    // Calculate how many columns and rows
                    NSInteger maxColumns = MAX(1, (NSInteger)((gridWidth - itemPadding) / (itemWidth + itemPadding)));
                    NSInteger numRows = (NSInteger)ceilf((float)channels.count / (float)maxColumns);
                    CGFloat totalGridHeight = numRows * (itemHeight + itemPadding) + itemPadding;
                    
                    // Add extra padding to ensure last row is fully visible 
                    totalGridHeight += itemHeight;
                    
                    // Update scroll position
                    channelScrollPosition += scrollAmount;
                    channelScrollPosition = MAX(0, channelScrollPosition);
                    CGFloat maxScroll = MAX(0, totalGridHeight - contentHeight);
                    channelScrollPosition = MIN(maxScroll, channelScrollPosition);
                    
                    // Immediately validate movie info for newly visible items in grid mode
                    // This ensures cover images load as they become visible during scrolling
                    if ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                        (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels])) {
                        [self validateMovieInfoForVisibleItems];
                    }
                }
            } else {
                // Scroll channel list - need to calculate max scroll based on current view mode
                if (self.selectedCategoryIndex == CATEGORY_SEARCH) {
                    // Handle search mode scrolling
                    self.searchChannelScrollPosition += scrollAmount;
                    self.searchChannelScrollPosition = MAX(0, self.searchChannelScrollPosition);
                    
                    // Calculate max scroll for search results
                    CGFloat maxScroll = MAX(0, ([self.searchChannelResults count] * 40 + 40) - (self.bounds.size.height));
                    self.searchChannelScrollPosition = MIN(maxScroll, self.searchChannelScrollPosition);
                } else {
                    // Regular channel list scrolling
                    channelScrollPosition += scrollAmount;
                    
                    // Limit scrolling
                    channelScrollPosition = MAX(0, channelScrollPosition);
                    
                    // Calculate max scroll based on current view mode
                    CGFloat maxScroll = 0;
                    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
                    
                    if (isStackedViewActive && channelsInCurrentGroup && channelsInCurrentGroup.count > 0) {
                        // For stacked view - use EXACT same calculation as drawStackedView
                        CGFloat stackedRowHeight = 400; // Match drawStackedView row height
                        
                        // Calculate stacked view visible height - exactly as in drawStackedView
                        CGFloat catWidth = 200;
                        CGFloat groupWidth = 250;
                        CGFloat stackedViewX = catWidth + groupWidth;
                        CGFloat stackedViewWidth = self.bounds.size.width - stackedViewX;
                        NSRect stackedRect = NSMakeRect(stackedViewX, 0, stackedViewWidth, self.bounds.size.height);
                        
                        // Account for potential rowHeight adjustment (matches drawStackedView logic)
                        NSInteger minVisibleRows = 4;
                        CGFloat requiredHeight = minVisibleRows * stackedRowHeight;
                        if (stackedRect.size.height < requiredHeight) {
                            // Adjust row height if window is too small (matches drawStackedView)
                            stackedRowHeight = MAX(80, stackedRect.size.height / minVisibleRows);
                        }
                        
                        CGFloat totalContentHeight = channelsInCurrentGroup.count * stackedRowHeight;
                        // Add extra space at bottom to ensure last item is fully visible (matches drawStackedView)
                        totalContentHeight += stackedRowHeight;
                        
                        maxScroll = MAX(0, totalContentHeight - stackedRect.size.height);
                    } else {
                        // For regular list view - use the original calculation
                        maxScroll = MAX(0, ([self.simpleChannelNames count] * 40 + 40) - (self.bounds.size.height));
                    }
                    
                    channelScrollPosition = MIN(maxScroll, channelScrollPosition);
                }
            }
        } else {
            // We're not in the channel list area, but should still allow scrolling 
            // in the movie info panel if it's active and the mouse is in that area
            if (point.x >= movieInfoX && self.selectedChannelIndex >= 0) {
                NSLog(@"Handling scroll in movie info section");
                
                // Calculate scroll amount (inverted for natural scroll direction)
                CGFloat scrollAmount = -[event deltaY] * 20; // Doubled scroll speed for better responsiveness
                
                // Get the selected channel
                VLCChannel *selectedChannel = [self getChannelAtIndex:self.selectedChannelIndex];
                if (selectedChannel) {
                    // Adjust the movie info scroll position
                    self.movieInfoScrollPosition += scrollAmount;
                    self.movieInfoScrollPosition = MAX(0, self.movieInfoScrollPosition);
                    
                    // Calculate maximum scroll position based on content
                    // Set to a very high value to ensure sufficient scrolling range
                    CGFloat contentHeight = 5000; // Significantly increased to guarantee scrollable content
                    
                    // Adjust based on actual content (description length, etc.)
                    if (selectedChannel.movieDescription) {
                        // Much more aggressive scaling factor to ensure scrolling works
                        NSInteger descriptionLength = [selectedChannel.movieDescription length];
                        // Using a much higher scaling factor - this is key to making scrolling work
                        contentHeight = MAX(contentHeight, 1000 + (descriptionLength * 5.0)); // Very aggressive approximation
                        
                        NSLog(@"SCROLL EVENT: Movie description length: %ld, calculated content height: %.1f, current scroll pos: %.1f", 
                              (long)descriptionLength, contentHeight, self.movieInfoScrollPosition);
                    }
                    
                    // Calculate max scroll with extra buffer
                    CGFloat maxScroll = MAX(0, contentHeight - self.bounds.size.height);
                    CGFloat oldScrollPos = self.movieInfoScrollPosition;
                    self.movieInfoScrollPosition = MIN(maxScroll, self.movieInfoScrollPosition);
                    
                    NSLog(@"Movie info scrolling: oldPos=%.1f, newPos=%.1f, delta=%.1f, maxScroll=%.1f", 
                          oldScrollPos, self.movieInfoScrollPosition, 
                          self.movieInfoScrollPosition - oldScrollPos, maxScroll);
                    
                    // Use throttled update instead of immediate redraw during scrolling
                    [self throttledDisplayUpdate];
                }
            }
            // If not in channel list or movie info area, ignore scroll event
        }
    }
    
    // Use throttled update instead of immediate redraw during scrolling
    [self throttledDisplayUpdate];
    
    // Reset scrolling flag after a short delay (to prevent fetching immediately after scroll)
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        isScrolling = NO;
        
        // When scrolling stops, check if any new movies became visible and need info/cache checking
        if ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
            (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels])) {
            [self validateMovieInfoForVisibleItems];
        }
        
        // Start fading out scroll bars after scrolling ends
        if (scrollBarFadeTimer) {
            [scrollBarFadeTimer invalidate];
        }
        scrollBarFadeTimer = [NSTimer scheduledTimerWithTimeInterval:0.1
                                                             target:self
                                                           selector:@selector(fadeScrollBars:)
                                                           userInfo:nil
                                                            repeats:YES];
    });
}

// Throttled display update to prevent too many redraws during scrolling
- (void)throttledDisplayUpdate {
    // This properly cancels previous requests without accessing potentially corrupted references
    [NSObject cancelPreviousPerformRequestsWithTarget:self 
                                             selector:@selector(performDisplayUpdate) 
                                               object:nil];

    [self performDisplayUpdate];
    return;
    // This schedules a new request safely with higher refresh rate for smoother scrolling
    [self performSelector:@selector(performDisplayUpdate)
               withObject:nil
               afterDelay:0.008]; // ~120fps for smoother scrolling
}

// Actual display update method
- (void)performDisplayUpdate {
    [self setNeedsDisplay:YES];
}

#pragma mark - Context Menu

- (void)rightMouseDown:(NSEvent *)event {
    [self markUserInteraction];
    
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // Check if right-click was in the EPG panel first
    if ([self handleEpgProgramRightClick:point withEvent:event]) {
        return;
    }
    
    // Check if right-click was in a text field
    if ((self.m3uFieldActive || NSPointInRect(point, self.m3uFieldRect)) ||
        (self.epgFieldActive || NSPointInRect(point, self.epgFieldRect))) {
        
        // Activate the appropriate field if not already active
        if (NSPointInRect(point, self.m3uFieldRect)) {
            self.m3uFieldActive = YES;
            self.epgFieldActive = NO;
        } else if (NSPointInRect(point, self.epgFieldRect)) {
            self.m3uFieldActive = NO;
            self.epgFieldActive = YES;
        }
        
        // Create a context menu
        NSMenu *menu = [[NSMenu alloc] init];
        
        // Add menu items
        NSMenuItem *pasteItem = [[NSMenuItem alloc] initWithTitle:@"Paste" 
                                                         action:@selector(paste:) 
                                                  keyEquivalent:@"v"];
        [pasteItem setKeyEquivalentModifierMask:NSCommandKeyMask];
        [pasteItem setTarget:self];
        [menu addItem:pasteItem];
        [pasteItem release];
        
        // Only add Copy if there's text to copy
        NSString *active = self.m3uFieldActive ? self.tempM3uUrl : self.tempEpgUrl;
        if (active && [active length] > 0) {
            NSMenuItem *copyItem = [[NSMenuItem alloc] initWithTitle:@"Copy" 
                                                             action:@selector(copy:) 
                                                      keyEquivalent:@"c"];
            [copyItem setKeyEquivalentModifierMask:NSCommandKeyMask];
            [copyItem setTarget:self];
            [menu addItem:copyItem];
            [copyItem release];
        }
        
        // Show the menu
        [NSMenu popUpContextMenu:menu withEvent:event forView:self];
        [menu release];
        
        [self setNeedsDisplay:YES];
        return;
    }
    
    // Check if right-click was on a group
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    if (point.x >= catWidth && point.x < catWidth + groupWidth) {
        // Calculate which group was clicked
        CGFloat effectiveY = self.bounds.size.height - point.y;
        NSInteger itemsScrolled = (NSInteger)floor(groupScrollPosition / 40);
        NSInteger visibleIndex = (NSInteger)floor(effectiveY / 40);
        NSInteger groupIndex = visibleIndex + itemsScrolled;
        
        // Get the appropriate groups based on current category
        NSArray *groups = nil;
        NSString *categoryName = nil;
        
        if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
            categoryName = [self.categories objectAtIndex:self.selectedCategoryIndex];
            
            if ([categoryName isEqualToString:@"FAVORITES"]) {
                groups = [self safeGroupsForCategory:@"FAVORITES"];
            } else if ([categoryName isEqualToString:@"TV"]) {
                groups = [self safeTVGroups];
            } else if ([categoryName isEqualToString:@"MOVIES"]) {
                groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
            } else if ([categoryName isEqualToString:@"SERIES"]) {
                groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
            }
        }
        
        // Check if the index is valid
        if (groups && groupIndex >= 0 && groupIndex < [groups count]) {
            NSString *groupName = [groups objectAtIndex:groupIndex];
            [self showContextMenuForGroup:groupName category:categoryName atPoint:point];
            return;
        }
    }
    
    // Check if right-click was on a channel
    NSInteger channelIndex = [self simpleChannelIndexAtPoint:point];
    if (channelIndex >= 0 && channelIndex < [self.simpleChannelNames count]) {
        // Find the actual channel object
        NSString *currentGroup = nil;
        NSArray *groups = nil;
        
        // Get current category and group
        NSString *currentCategory = nil;
        if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
            currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
        }
        
        // Get the appropriate groups based on category
        if ([currentCategory isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([currentCategory isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([currentCategory isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        }
        
        // Get the current group from the selected index
        if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
            currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
        }
        
        // Get the channel
        VLCChannel *channel = nil;
        if (currentGroup) {
            NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
            if (channelsInGroup && channelIndex < channelsInGroup.count) {
                channel = [channelsInGroup objectAtIndex:channelIndex];
            }
        }
        
        // If we found the channel, show the context menu
        if (channel) {
            [self showContextMenuForChannel:channel atPoint:point];
        }
    }
}

- (void)showContextMenuForChannel:(VLCChannel *)channel atPoint:(NSPoint)point {
    NSMenu *menu = [[NSMenu alloc] init];
    
    // Play option
    NSMenuItem *playItem = [[NSMenuItem alloc] initWithTitle:@"Play Channel" 
                                                     action:@selector(playChannelFromMenu:) 
                                              keyEquivalent:@""];
    [playItem setTarget:self];
    [playItem setRepresentedObject:channel];
    [menu addItem:playItem];
    [playItem release];
    
    // Add separator
    [menu addItem:[NSMenuItem separatorItem]];
    
    // Timeshift options if channel supports catchup
    if (channel.supportsCatchup) {
        // Add timeshift menu item
        NSString *timeshiftTitle = [NSString stringWithFormat:@"Timeshift (%ld days available)", (long)channel.catchupDays];
        NSMenuItem *timeshiftItem = [[NSMenuItem alloc] initWithTitle:timeshiftTitle 
                                                              action:@selector(showTimeshiftOptionsForChannel:) 
                                                       keyEquivalent:@""];
        [timeshiftItem setTarget:self];
        [timeshiftItem setRepresentedObject:channel];
        [menu addItem:timeshiftItem];
        [timeshiftItem release];
        
        // Add separator after timeshift options
        [menu addItem:[NSMenuItem separatorItem]];
    }
    
    // Channel info
    NSMenuItem *infoItem = [[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Channel: %@", channel.name] 
                                                     action:nil 
                                              keyEquivalent:@""];
    [infoItem setEnabled:NO]; // Disabled, just for display
    [menu addItem:infoItem];
    [infoItem release];
    
    // Add separator
    [menu addItem:[NSMenuItem separatorItem]];
    
    // Favorites options
    BOOL isInFavorites = [self isChannelInFavorites:channel];
    
    if (isInFavorites) {
        NSMenuItem *removeItem = [[NSMenuItem alloc] initWithTitle:@"Remove from Favorites" 
                                                           action:@selector(removeChannelFromFavoritesAction:) 
                                                    keyEquivalent:@""];
        [removeItem setTarget:self];
        [removeItem setRepresentedObject:channel];
        [menu addItem:removeItem];
        [removeItem release];
    } else {
        NSMenuItem *addItem = [[NSMenuItem alloc] initWithTitle:@"Add to Favorites" 
                                                        action:@selector(addChannelToFavoritesAction:) 
                                                 keyEquivalent:@""];
        [addItem setTarget:self];
        [addItem setRepresentedObject:channel];
        [menu addItem:addItem];
        [addItem release];
    }
    
    // Show menu
    [NSMenu popUpContextMenu:menu withEvent:[NSApp currentEvent] forView:self];
    [menu release];
}

- (void)showContextMenuForGroup:(NSString *)groupName category:(NSString *)category atPoint:(NSPoint)point {
    if (!groupName) return;
    
    NSMenu *menu = [[NSMenu alloc] init];
    
    // Add group title
    NSMenuItem *titleItem = [[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Group: %@", groupName] 
                                                      action:nil 
                                               keyEquivalent:@""];
    [titleItem setEnabled:NO]; // Disabled, just for display
    [menu addItem:titleItem];
    [titleItem release];
    
    // Add separator
    [menu addItem:[NSMenuItem separatorItem]];
    
    // Get channels in this group
    NSArray *channelsInGroup = [self.channelsByGroup objectForKey:groupName];
    
    // Add "Play First Channel" option if the group has channels
    if (channelsInGroup && [channelsInGroup count] > 0) {
        NSMenuItem *playItem = [[NSMenuItem alloc] initWithTitle:@"Play First Channel" 
                                                         action:@selector(playFirstChannelInGroupAction:) 
                                                  keyEquivalent:@""];
        [playItem setTarget:self];
        [playItem setRepresentedObject:groupName];
        [menu addItem:playItem];
        [playItem release];
        
        // Add separator after play option
        [menu addItem:[NSMenuItem separatorItem]];
    }
    
    // Favorites options - only show if not already in FAVORITES category
    if (![category isEqualToString:@"FAVORITES"]) {
        // Check if group is already in favorites
        BOOL isInFavorites = [self isGroupInFavorites:groupName];
        
        if (isInFavorites) {
            NSMenuItem *removeItem = [[NSMenuItem alloc] initWithTitle:@"Remove Group from Favorites" 
                                                               action:@selector(removeGroupFromFavoritesAction:) 
                                                        keyEquivalent:@""];
            [removeItem setTarget:self];
            [removeItem setRepresentedObject:groupName];
            [menu addItem:removeItem];
            [removeItem release];
        } else {
            NSMenuItem *addItem = [[NSMenuItem alloc] initWithTitle:@"Add Group to Favorites" 
                                                            action:@selector(addGroupToFavoritesAction:) 
                                                     keyEquivalent:@""];
            [addItem setTarget:self];
            [addItem setRepresentedObject:groupName];
            [menu addItem:addItem];
            [addItem release];
            
            // Add debugging log to verify menu item creation
            NSLog(@"Added 'Add to Favorites' menu item for group: %@", groupName);
        }
    } else {
        // If in favorites category, only show remove option
        NSMenuItem *removeItem = [[NSMenuItem alloc] initWithTitle:@"Remove Group from Favorites" 
                                                           action:@selector(removeGroupFromFavoritesAction:) 
                                                    keyEquivalent:@""];
        [removeItem setTarget:self];
        [removeItem setRepresentedObject:groupName];
        [menu addItem:removeItem];
        [removeItem release];
    }
    
    // Add channels count
    NSMenuItem *infoItem = [[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Channels: %ld", (long)[channelsInGroup count]] 
                                                     action:nil 
                                              keyEquivalent:@""];
    [infoItem setEnabled:NO]; // Disabled, just for display
    [menu addItem:infoItem];
    [infoItem release];
    
    // Show menu
    [NSMenu popUpContextMenu:menu withEvent:[NSApp currentEvent] forView:self];
    [menu release];
}

- (void)playChannelFromMenu:(NSMenuItem *)sender {
    VLCChannel *channel = [sender representedObject];
    if (channel) {
        [self playChannelWithUrl:channel.url];
    }
}

- (void)showTimeshiftOptionsForChannel:(NSMenuItem *)sender {
    VLCChannel *channel = [sender representedObject];
    if (!channel || !channel.supportsCatchup) {
        return;
    }
    
    NSMenu *timeshiftMenu = [[NSMenu alloc] init];
    
    // Add title
    NSMenuItem *titleItem = [[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Timeshift: %@", channel.name] 
                                                      action:nil 
                                               keyEquivalent:@""];
    [titleItem setEnabled:NO];
    [timeshiftMenu addItem:titleItem];
    [titleItem release];
    
    // Add separator
    [timeshiftMenu addItem:[NSMenuItem separatorItem]];
    
    // Add timeshift options for different time periods
    NSArray *timeshiftOptions = @[
        @{@"title": @"Go back 1 hour", @"hours": @1},
        @{@"title": @"Go back 2 hours", @"hours": @2},
        @{@"title": @"Go back 4 hours", @"hours": @4},
        @{@"title": @"Go back 8 hours", @"hours": @8},
        @{@"title": @"Go back 12 hours", @"hours": @12},
        @{@"title": @"Go back 24 hours", @"hours": @24}
    ];
    
    for (NSDictionary *option in timeshiftOptions) {
        NSInteger hours = [[option objectForKey:@"hours"] integerValue];
        NSString *title = [option objectForKey:@"title"];
        
        // Only show options that are within the catchup window
        if (hours <= (channel.catchupDays * 24)) {
            NSMenuItem *timeshiftOptionItem = [[NSMenuItem alloc] initWithTitle:title 
                                                                        action:@selector(playTimeshiftFromMenu:) 
                                                                 keyEquivalent:@""];
            [timeshiftOptionItem setTarget:self];
            
            // Store both channel and hours in a dictionary
            NSDictionary *timeshiftData = @{
                @"channel": channel,
                @"hours": @(hours)
            };
            [timeshiftOptionItem setRepresentedObject:timeshiftData];
            [timeshiftMenu addItem:timeshiftOptionItem];
            [timeshiftOptionItem release];
        }
    }
    
    // Show the submenu
    [NSMenu popUpContextMenu:timeshiftMenu withEvent:[NSApp currentEvent] forView:self];
    [timeshiftMenu release];
}

- (void)playTimeshiftFromMenu:(NSMenuItem *)sender {
    NSDictionary *timeshiftData = [sender representedObject];
    VLCChannel *channel = [timeshiftData objectForKey:@"channel"];
    NSNumber *hoursBack = [timeshiftData objectForKey:@"hours"];
    
    if (!channel || !hoursBack) {
        return;
    }
    
    // Calculate target time
    NSTimeInterval hoursBackInterval = [hoursBack doubleValue] * 3600; // Convert hours to seconds
    NSDate *targetTime = [[NSDate date] dateByAddingTimeInterval:-hoursBackInterval];
    
    // Generate timeshift URL
    NSString *timeshiftUrl = [self generateTimeshiftUrlForChannel:channel atTime:targetTime];
    
    if (timeshiftUrl) {
        NSLog(@"Playing timeshift for channel '%@' going back %@ hours", channel.name, hoursBack);
        
        // Stop current playback
        if (self.player) {
            [self saveCurrentPlaybackPosition];
            [self.player stop];
        }
        
        // Brief pause to allow VLC to reset
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // Create media object with timeshift URL
            NSURL *url = [NSURL URLWithString:timeshiftUrl];
            VLCMedia *media = [VLCMedia mediaWithURL:url];
            
            // Set the media to the player
            [self.player setMedia:media];
            
            // Apply subtitle settings
            if ([VLCSubtitleSettings respondsToSelector:@selector(applyCurrentSettingsToPlayer:)]) {
                [VLCSubtitleSettings applyCurrentSettingsToPlayer:self.player];
            }
            
            // Start playing
            [self.player play];
            
            NSLog(@"Started timeshift playback for URL: %@", timeshiftUrl);
            
            // Force UI update
            [self setNeedsDisplay:YES];
        });
        
        // Save the timeshift URL as last played for resume functionality
        [self saveLastPlayedChannelUrl:timeshiftUrl];
        
        // Hide the channel list after starting playback
        [self hideChannelListWithFade];
    } else {
        NSLog(@"Failed to generate timeshift URL for channel: %@", channel.name);
    }
}

- (void)showEpgForChannel:(VLCChannel *)channel {
    // This method is no longer used as the EPG panel has been removed
    // We'll leave it in place to avoid breaking anything
    // but it won't do anything when called
}

- (void)playFirstChannelInGroupAction:(NSMenuItem *)sender {
    NSString *groupName = [sender representedObject];
    if (groupName) {
        // Get channels in this group
        NSArray *channelsInGroup = [self.channelsByGroup objectForKey:groupName];
        if (channelsInGroup && [channelsInGroup count] > 0) {
            // Get the first channel
            VLCChannel *firstChannel = [channelsInGroup objectAtIndex:0];
            if (firstChannel && firstChannel.url) {
                // Play the first channel
                [self playChannelWithUrl:firstChannel.url];
                
                // Select the group
                NSInteger categoryIndex = -1;
                NSArray *groups = nil;
                
                // Find which category contains this group
                for (NSInteger i = 0; i < [self.categories count]; i++) {
                    NSString *category = [self.categories objectAtIndex:i];
                    NSArray *categoryGroups = [self.groupsByCategory objectForKey:category];
                    
                    if ([categoryGroups containsObject:groupName]) {
                        categoryIndex = i;
                        groups = categoryGroups;
                        break;
                    }
                }
                
                // If found, update selection
                if (categoryIndex >= 0 && groups) {
                    // Hide all controls before changing category
                    [self hideControls];
                    
                    self.selectedCategoryIndex = categoryIndex;
                    self.selectedGroupIndex = [groups indexOfObject:groupName];
                    
                    // Select the first channel
                    [self prepareSimpleChannelLists];
                    if ([self.simpleChannelNames count] > 0) {
                        self.selectedChannelIndex = 0;
                    }
                    
                    [self setNeedsDisplay:YES];
                }
            }
        }
    }
}

- (void)keyDown:(NSEvent *)event {
    [self markUserInteraction];
    
    // Handle escape key to hide the menu
    unichar key = [[event charactersIgnoringModifiers] characterAtIndex:0];
    if (key == 27) { // ESC key
        // Hide the menu immediately
        if (self.isChannelListVisible) {
            // Hide all controls before hiding the menu
            [self hideControls];
            self.isChannelListVisible = NO;
            [self setNeedsDisplay:YES];
            return;
        }
        
        // If channel list is already hidden, hide player controls
        if (playerControlsVisible) {
            [self hidePlayerControls:nil];
            //NSLog(@"Player controls hidden");
            return;
        }
        
        // If both are hidden, log that there's nothing to hide
        NSLog(@"Nothing to hide");
    }
    
    // Handle 'V' key to cycle through views
    if (key == 'v' || key == 'V') {
        // Cycle through view modes: Stacked, Grid, List
        currentViewMode = (currentViewMode + 1) % 3;
        
        // Update view mode based on currentViewMode
        switch (currentViewMode) {
            case 0: // Stacked
            isGridViewActive = NO;
                isStackedViewActive = YES;
                break;
            case 1: // Grid
                isGridViewActive = YES;
                isStackedViewActive = NO;
                break;
            case 2: // List
                isGridViewActive = NO;
                isStackedViewActive = NO;
                break;
            }
            
            // Reset hover state and scroll position
            self.hoveredChannelIndex = -1;
            channelScrollPosition = 0;
            
        // Save view mode preference
        [self saveViewModePreference];
        
            [self setNeedsDisplay:YES];
            return;
    }
    
    // Handle editing in settings text fields
    if (self.m3uFieldActive || self.epgFieldActive) {
        unichar key = [[event charactersIgnoringModifiers] characterAtIndex:0];
        NSString *active = self.m3uFieldActive ? self.tempM3uUrl : self.tempEpgUrl;
        NSInteger currentCursorPosition = self.m3uFieldActive ? self.m3uCursorPosition : self.epgCursorPosition;
        NSInteger textLength = active ? [active length] : 0;
        
        // Handle keyboard shortcuts with command key
        if ([event modifierFlags] & NSCommandKeyMask) {
            // Handle copy/paste
            if (key == 'v') {
                // Paste from clipboard
                NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
                NSString *string = [pasteboard stringForType:NSPasteboardTypeString];
                
                if (string != nil) {
                    // Insert clipboard contents at cursor position
                    NSString *newValue;
                    if (active) {
                        NSString *beforeCursor = [active substringToIndex:MIN(currentCursorPosition, textLength)];
                        NSString *afterCursor = [active substringFromIndex:MIN(currentCursorPosition, textLength)];
                        newValue = [NSString stringWithFormat:@"%@%@%@", beforeCursor, string, afterCursor];
                    } else {
                        newValue = string;
                    }
                    
                    if (self.m3uFieldActive) {
                        self.tempM3uUrl = newValue;
                        
                        // Automatically update EPG URL as user types in M3U URL
                        // Only do this if the EPG URL is empty or hasn't been manually edited
                        if (!self.tempEpgUrl || [self.tempEpgUrl length] == 0) {
                            // Generate EPG URL using helper method
                            NSString *epgUrl = [self generateEpgUrlFromM3uUrl:newValue];
                            if (epgUrl) {
                                self.tempEpgUrl = epgUrl;
                            }
                        }
                    } else {
                        self.tempEpgUrl = newValue;
                    }
                    
                    // Move cursor position after the pasted text
                    currentCursorPosition += [string length];
                    if (self.m3uFieldActive) {
                        self.m3uCursorPosition = currentCursorPosition;
                    } else {
                        self.epgCursorPosition = currentCursorPosition;
                    }
                    
                    [self setNeedsDisplay:YES];
                }
                return;
            } else if (key == 'c') {
                // Copy to clipboard
                if (active && [active length] > 0) {
                    NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
                    [pasteboard clearContents];
                    [pasteboard setString:active forType:NSPasteboardTypeString];
                }
                return;
            } else if (key == 'a') {
                // Select all (not currently implemented visually, but we could add this)
                return;
            }
        }
        
        // Handle navigation keys
        if (key == NSLeftArrowFunctionKey) {
            // Move cursor left if possible
            if (currentCursorPosition > 0) {
                currentCursorPosition--;
                if (self.m3uFieldActive) {
                    self.m3uCursorPosition = currentCursorPosition;
                } else {
                    self.epgCursorPosition = currentCursorPosition;
                }
                [self setNeedsDisplay:YES];
            }
            return;
        } else if (key == NSRightArrowFunctionKey) {
            // Move cursor right if possible
            if (currentCursorPosition < textLength) {
                currentCursorPosition++;
                if (self.m3uFieldActive) {
                    self.m3uCursorPosition = currentCursorPosition;
                } else {
                    self.epgCursorPosition = currentCursorPosition;
                }
                [self setNeedsDisplay:YES];
            }
            return;
        } else if (key == NSHomeFunctionKey) {
            // Move cursor to beginning
            if (self.m3uFieldActive) {
                self.m3uCursorPosition = 0;
            } else {
                self.epgCursorPosition = 0;
            }
            [self setNeedsDisplay:YES];
            return;
        } else if (key == NSEndFunctionKey) {
            // Move cursor to end
            if (self.m3uFieldActive) {
                self.m3uCursorPosition = textLength;
            } else {
                self.epgCursorPosition = textLength;
            }
            [self setNeedsDisplay:YES];
            return;
        }
        
        if (key == 13) { // Enter
            // Apply the current values
            if (self.m3uFieldActive) {
                self.m3uFieldActive = NO;
                
                // Generate EPG URL from M3U URL if we have a valid URL and EPG field is empty
                if (self.tempM3uUrl && [self.tempM3uUrl length] > 0) {
                    // Set the actual m3u file path 
                    NSString *urlToLoad = self.tempM3uUrl;
                    if (![urlToLoad hasPrefix:@"http://"] && ![urlToLoad hasPrefix:@"https://"]) {
                        urlToLoad = [@"http://" stringByAppendingString:urlToLoad];
                        self.tempM3uUrl = urlToLoad;
                    }
                    self.m3uFilePath = urlToLoad;
                
                    if (!self.tempEpgUrl || [self.tempEpgUrl length] == 0) {
                        // Generate EPG URL using helper method
                        NSString *epgUrl = [self generateEpgUrlFromM3uUrl:self.tempM3uUrl];
                        if (epgUrl) {
                            self.tempEpgUrl = epgUrl;
                            self.epgUrl = epgUrl;
                        }
                    }
                    
                    // Save settings
                    [self saveSettings];
                }
            } else if (self.epgFieldActive) {
                self.epgFieldActive = NO;
                
                // Update EPG URL if valid
                if (self.tempEpgUrl && [self.tempEpgUrl length] > 0) {
                    NSString *epgUrl = self.tempEpgUrl;
                    if (![epgUrl hasPrefix:@"http://"] && ![epgUrl hasPrefix:@"https://"]) {
                        epgUrl = [@"http://" stringByAppendingString:epgUrl];
                        self.tempEpgUrl = epgUrl;
                    }
                    self.epgUrl = epgUrl;
                    
                    // Save settings
                    [self saveSettings];
                    
                    // Load EPG data
                    [self loadEpgData];
                }
            }
            [self setNeedsDisplay:YES];
        } else if (key == 27) { // Escape
            // Cancel input
            self.m3uFieldActive = NO;
            self.epgFieldActive = NO;
            self.epgTimeOffsetDropdownActive = NO;
            [self setNeedsDisplay:YES];
        } else if (key == 126 || key == 125) { // Up arrow (126) or Down arrow (125)
            if (self.epgTimeOffsetDropdownActive) {
                // Navigate dropdown with arrow keys
                if (key == 126) { // Up arrow
                    if (self.epgTimeOffsetHours < 12) {
                        self.epgTimeOffsetHours++;
                        [self saveSettings];
                        NSLog(@"EPG time offset changed to: %+d hours", (int)self.epgTimeOffsetHours);
                    }
                } else { // Down arrow
                    if (self.epgTimeOffsetHours > -12) {
                        self.epgTimeOffsetHours--;
                        [self saveSettings];
                        NSLog(@"EPG time offset changed to: %+d hours", (int)self.epgTimeOffsetHours);
                    }
                }
                [self setNeedsDisplay:YES];
            }
        } else if (key == 9) { // Tab - switch between fields
            if (self.m3uFieldActive) {
                self.m3uFieldActive = NO;
                self.epgFieldActive = YES;
                self.epgTimeOffsetDropdownActive = NO;
                self.epgCursorPosition = self.tempEpgUrl ? [self.tempEpgUrl length] : 0;
            } else if (self.epgFieldActive) {
                self.epgFieldActive = NO;
                self.m3uFieldActive = NO;
                self.epgTimeOffsetDropdownActive = YES;
            } else if (self.epgTimeOffsetDropdownActive) {
                self.epgTimeOffsetDropdownActive = NO;
                self.m3uFieldActive = YES;
                self.m3uCursorPosition = self.tempM3uUrl ? [self.tempM3uUrl length] : 0;
            } else {
                self.m3uFieldActive = YES;
                self.epgFieldActive = NO;
                self.epgTimeOffsetDropdownActive = NO;
                self.m3uCursorPosition = self.tempM3uUrl ? [self.tempM3uUrl length] : 0;
            }
            [self setNeedsDisplay:YES];
        } else if (key == NSDeleteCharacter || key == NSBackspaceCharacter) {
            // Delete/backspace
            if (textLength > 0 && currentCursorPosition > 0) {
                // Delete character before cursor
                NSString *beforeCursor = [active substringToIndex:currentCursorPosition - 1];
                NSString *afterCursor = [active substringFromIndex:currentCursorPosition];
                NSString *newValue = [beforeCursor stringByAppendingString:afterCursor];
                
                if (self.m3uFieldActive) {
                    self.tempM3uUrl = newValue;
                    
                    // Automatically update EPG URL as user types in M3U URL
                    // Only do this if the EPG URL is empty or hasn't been manually edited
                    if (!self.tempEpgUrl || [self.tempEpgUrl length] == 0) {
                        // Generate EPG URL using helper method
                        NSString *epgUrl = [self generateEpgUrlFromM3uUrl:newValue];
                        if (epgUrl) {
                            self.tempEpgUrl = epgUrl;
                        }
                    }
                } else {
                    self.tempEpgUrl = newValue;
                }
                
                // Move cursor back
                currentCursorPosition--;
                if (self.m3uFieldActive) {
                    self.m3uCursorPosition = currentCursorPosition;
                } else {
                    self.epgCursorPosition = currentCursorPosition;
                }
                
                [self setNeedsDisplay:YES];
            }
        } else {
            // Regular character - insert at cursor position
            NSString *character = [event characters];
            if (character) {
                NSString *newValue;
                if (active) {
                    NSString *beforeCursor = [active substringToIndex:MIN(currentCursorPosition, textLength)];
                    NSString *afterCursor = [active substringFromIndex:MIN(currentCursorPosition, textLength)];
                    newValue = [NSString stringWithFormat:@"%@%@%@", beforeCursor, character, afterCursor];
                } else {
                    newValue = character;
                }
                
                if (self.m3uFieldActive) {
                    self.tempM3uUrl = newValue;
                    
                    // Automatically update EPG URL as user types in M3U URL
                    // Only do this if the EPG URL is empty or hasn't been manually edited
                    if (!self.tempEpgUrl || [self.tempEpgUrl length] == 0) {
                        // Generate EPG URL using helper method
                        NSString *epgUrl = [self generateEpgUrlFromM3uUrl:newValue];
                        if (epgUrl) {
                            self.tempEpgUrl = epgUrl;
                        }
                    }
                } else {
                    self.tempEpgUrl = newValue;
                }
                
                // Move cursor forward
                currentCursorPosition += [character length];
                if (self.m3uFieldActive) {
                    self.m3uCursorPosition = currentCursorPosition;
                } else {
                    self.epgCursorPosition = currentCursorPosition;
                }
                
                [self setNeedsDisplay:YES];
            }
        }
        
        return;
    }
    
    // Handle keyboard input for URL field
    if (self.isTextFieldActive) {
        unichar key = [[event charactersIgnoringModifiers] characterAtIndex:0];
        
        if (key == 13) { // Enter
            // Process the URL
            [self processUrlInput];
            
            // Hide the input field
            self.isTextFieldActive = NO;
            [self setNeedsDisplay:YES];
        } else if (key == 27) { // Escape
            // Cancel input
            self.isTextFieldActive = NO;
            [self setNeedsDisplay:YES];
        } else if (key == NSDeleteCharacter || key == NSBackspaceCharacter) {
            // Delete/backspace
            if ([self.inputUrlString length] > 0) {
                self.inputUrlString = [[self.inputUrlString substringToIndex:[self.inputUrlString length] - 1] retain];
                [self setNeedsDisplay:YES];
            }
        } else {
            // Append character
            NSString *character = [event characters];
            if (character) {
                self.inputUrlString = [[self.inputUrlString stringByAppendingString:character] retain];
                [self setNeedsDisplay:YES];
            }
        }
    } else {
        // Regular keyboard shortcuts
        unichar key = [[event charactersIgnoringModifiers] characterAtIndex:0];
        
        switch (key) {
            case 'f':
                // Toggle fullscreen
                break;
                
            case 's':
                // Show settings
                // Hide all controls before changing to settings
                [self hideControls];
                
                self.selectedCategoryIndex = CATEGORY_SETTINGS;
                self.selectedGroupIndex = 0; // General settings
                [self setNeedsDisplay:YES];
                break;
                
            case 'o':
                // Open URL
                self.isTextFieldActive = YES;
                self.inputUrlString = [@"" retain];
                [self setNeedsDisplay:YES];
                break;
                
            default:
                break;
        }
    }
}
- (void)mouseDragged:(NSEvent *)event {
    [self markUserInteraction];
    
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // Check if we're in the settings panel
    if (self.selectedCategoryIndex == CATEGORY_SETTINGS) {
        NSString *selectedGroup = nil;
        NSArray *settingsGroups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        
        if (self.selectedGroupIndex >= 0 && self.selectedGroupIndex < [settingsGroups count]) {
            selectedGroup = [settingsGroups objectAtIndex:self.selectedGroupIndex];
        }
        
        // Handle transparency slider dragging (only in Themes group)
        if (selectedGroup && [selectedGroup isEqualToString:@"Themes"]) {
            // Handle RGB sliders dragging (only when Custom theme is selected)
            if (self.currentTheme == VLC_THEME_CUSTOM) {
                // Red slider dragging
                NSRect expandedRedRect = NSMakeRect(self.redSliderRect.origin.x - 20, 
                                                   self.redSliderRect.origin.y - 20, 
                                                   self.redSliderRect.size.width + 40, 
                                                   self.redSliderRect.size.height + 40);
                
                if (NSPointInRect(point, expandedRedRect)) {
                    CGFloat value = [VLCSliderControl valueForPoint:point
                                                       sliderRect:self.redSliderRect
                                                        minValue:0.0
                                                        maxValue:1.0];
                    
                    if (self.customThemeRed != value) {
                        self.customThemeRed = value;
                        [self updateThemeColors];
                        [self setNeedsDisplay:YES];
                    }
                    return;
                }
                
                // Green slider dragging
                NSRect expandedGreenRect = NSMakeRect(self.greenSliderRect.origin.x - 20, 
                                                     self.greenSliderRect.origin.y - 20, 
                                                     self.greenSliderRect.size.width + 40, 
                                                     self.greenSliderRect.size.height + 40);
                
                if (NSPointInRect(point, expandedGreenRect)) {
                    CGFloat value = [VLCSliderControl valueForPoint:point
                                                       sliderRect:self.greenSliderRect
                                                        minValue:0.0
                                                        maxValue:1.0];
                    
                    if (self.customThemeGreen != value) {
                        self.customThemeGreen = value;
                        [self updateThemeColors];
                        [self setNeedsDisplay:YES];
                    }
                    return;
                }
                
                // Blue slider dragging
                NSRect expandedBlueRect = NSMakeRect(self.blueSliderRect.origin.x - 20, 
                                                    self.blueSliderRect.origin.y - 20, 
                                                    self.blueSliderRect.size.width + 40, 
                                                    self.blueSliderRect.size.height + 40);
                
                if (NSPointInRect(point, expandedBlueRect)) {
                    CGFloat value = [VLCSliderControl valueForPoint:point
                                                       sliderRect:self.blueSliderRect
                                                        minValue:0.0
                                                        maxValue:1.0];
                    
                    if (self.customThemeBlue != value) {
                        self.customThemeBlue = value;
                        [self updateThemeColors];
                        [self setNeedsDisplay:YES];
                    }
                    return;
                }
            }
            
            // Selection Color RGB sliders dragging (always available in Themes group)
            // Selection Red slider dragging
            NSRect expandedSelectionRedRect = NSMakeRect(self.selectionRedSliderRect.origin.x - 20, 
                                                        self.selectionRedSliderRect.origin.y - 20, 
                                                        self.selectionRedSliderRect.size.width + 40, 
                                                        self.selectionRedSliderRect.size.height + 40);
            
            if (NSPointInRect(point, expandedSelectionRedRect)) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.selectionRedSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customSelectionRed != value) {
                    self.customSelectionRed = value;
                    [self updateSelectionColors];
                    [self setNeedsDisplay:YES];
                }
                return;
            }
            
            // Selection Green slider dragging
            NSRect expandedSelectionGreenRect = NSMakeRect(self.selectionGreenSliderRect.origin.x - 20, 
                                                          self.selectionGreenSliderRect.origin.y - 20, 
                                                          self.selectionGreenSliderRect.size.width + 40, 
                                                          self.selectionGreenSliderRect.size.height + 40);
            
            if (NSPointInRect(point, expandedSelectionGreenRect)) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.selectionGreenSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customSelectionGreen != value) {
                    self.customSelectionGreen = value;
                    [self updateSelectionColors];
                    [self setNeedsDisplay:YES];
                }
                return;
            }
            
            // Selection Blue slider dragging
            NSRect expandedSelectionBlueRect = NSMakeRect(self.selectionBlueSliderRect.origin.x - 20, 
                                                         self.selectionBlueSliderRect.origin.y - 20, 
                                                         self.selectionBlueSliderRect.size.width + 40, 
                                                         self.selectionBlueSliderRect.size.height + 40);
            
            if (NSPointInRect(point, expandedSelectionBlueRect)) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.selectionBlueSliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                if (self.customSelectionBlue != value) {
                    self.customSelectionBlue = value;
                    [self updateSelectionColors];
                    [self setNeedsDisplay:YES];
                }
                return;
            }
            
            // Transparency slider dragging
            // Allow dragging even if mouse is slightly outside the slider for better UX
            NSRect expandedRect = NSMakeRect(self.transparencySliderRect.origin.x - 20, 
                                           self.transparencySliderRect.origin.y - 20, 
                                           self.transparencySliderRect.size.width + 40, 
                                           self.transparencySliderRect.size.height + 40);
            
            if (NSPointInRect(point, expandedRect)) {
                CGFloat value = [VLCSliderControl valueForPoint:point
                                                   sliderRect:self.transparencySliderRect
                                                    minValue:0.0
                                                    maxValue:1.0];
                
                // Use the exact slider value instead of converting to discrete levels
                // This provides smooth transparency adjustment
                if (self.themeAlpha != value) {
                    self.themeAlpha = value;
                    [self updateThemeColors];
                    [self saveThemeSettings];
                    [self setNeedsDisplay:YES];
                }
                return;
            }
        }
        
        // Handle subtitle slider dragging (only in Subtitles group)
        if (selectedGroup && [selectedGroup isEqualToString:@"Subtitles"]) {
            NSValue *sliderRectValue = objc_getAssociatedObject(self, "subtitleFontSizeSliderRect");
            if (sliderRectValue) {
                NSRect sliderRect = [sliderRectValue rectValue];
                
                // Allow dragging even if mouse is slightly outside the slider for better UX
                NSRect expandedRect = NSMakeRect(sliderRect.origin.x - 20, sliderRect.origin.y - 20, 
                                               sliderRect.size.width + 40, sliderRect.size.height + 40);
                
                if (NSPointInRect(point, expandedRect)) {
                    // Calculate new font size based on drag position
                    NSRect actualSliderRect = NSMakeRect(sliderRect.origin.x + 10, sliderRect.origin.y + 10, 
                                                        sliderRect.size.width - 20, sliderRect.size.height - 20);
                    
                    CGFloat clickProgress = (point.x - actualSliderRect.origin.x) / actualSliderRect.size.width;
                    clickProgress = MAX(0.0, MIN(1.0, clickProgress)); // Clamp to 0-1
                    
                    // Convert to font scale factor (5-30 range, where 10 = 1.0x scale)
                    NSInteger newFontSize = (NSInteger)(5 + (clickProgress * (30 - 5)));
                    
                    // Update settings and apply to player immediately
                    VLCSubtitleSettings *settings = [VLCSubtitleSettings sharedInstance];
                    if (settings.fontSize != newFontSize) {
                        settings.fontSize = newFontSize;
                        [settings saveSettings];
                        
                        // Apply to VLC player in real-time
                        if (self.player) {
                            [settings applyToPlayer:self.player];
                        }
                        
                        NSLog(@"Subtitle font scale dragged to: %ld (%.2fx)", (long)newFontSize, (float)newFontSize / 10.0f);
                        
                        // Redraw to show updated slider position
                        [self setNeedsDisplay:YES];
                    }
                    return;
                }
            }
        }
    }
    
    // Call super for other drag handling
    [super mouseDragged:event];
}

- (void)processUrlInput {
    if ([self.inputUrlString length] > 0) {
        [self playChannelWithUrl:self.inputUrlString];
    }
}

// Add a method to handle paste from contextual menu
- (IBAction)paste:(id)sender {
    if (self.m3uFieldActive || self.epgFieldActive) {
        NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
        NSString *string = [pasteboard stringForType:NSPasteboardTypeString];
        
        if (string != nil) {
            NSString *active = self.m3uFieldActive ? self.tempM3uUrl : self.tempEpgUrl;
            NSString *newValue = active ? [active stringByAppendingString:string] : string;
            
            if (self.m3uFieldActive) {
                self.tempM3uUrl = newValue;
                
                // Automatically update EPG URL as user types in M3U URL
                // Only do this if the EPG URL is empty or hasn't been manually edited
                if (!self.tempEpgUrl || [self.tempEpgUrl length] == 0) {
                    // Generate EPG URL using helper method
                    NSString *epgUrl = [self generateEpgUrlFromM3uUrl:newValue];
                    if (epgUrl) {
                        self.tempEpgUrl = epgUrl;
                    }
                }
            } else {
                self.tempEpgUrl = newValue;
            }
            
            [self setNeedsDisplay:YES];
        }
    }
}

// Override to support cut/copy/paste menu items
- (BOOL)validateMenuItem:(NSMenuItem *)menuItem {
    SEL action = [menuItem action];
    
    if (action == @selector(paste:)) {
        return (self.m3uFieldActive || self.epgFieldActive) && 
               [[NSPasteboard generalPasteboard] availableTypeFromArray:@[NSPasteboardTypeString]] != nil;
    } else if (action == @selector(copy:) || action == @selector(cut:)) {
        NSString *active = self.m3uFieldActive ? self.tempM3uUrl : self.tempEpgUrl;
        return (self.m3uFieldActive || self.epgFieldActive) && active && [active length] > 0;
    }
    
    return [super validateMenuItem:menuItem];
}

// Add copy method
- (IBAction)copy:(id)sender {
    if (self.m3uFieldActive || self.epgFieldActive) {
        NSString *active = self.m3uFieldActive ? self.tempM3uUrl : self.tempEpgUrl;
        
        if (active && [active length] > 0) {
            NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
            [pasteboard clearContents];
            [pasteboard setString:active forType:NSPasteboardTypeString];
        }
    }
}

// Override to become first responder
- (BOOL)acceptsFirstResponder {
    return YES;
}

// Override to maintain responder chain
- (BOOL)becomeFirstResponder {
    return YES;
}

// Override to properly handle key events
- (BOOL)performKeyEquivalent:(NSEvent *)event {
    // Handle CMD+V paste
    if (([event modifierFlags] & NSCommandKeyMask) && 
        [[event charactersIgnoringModifiers] isEqualToString:@"v"] &&
        (self.m3uFieldActive || self.epgFieldActive)) {
        [self paste:self];
        return YES;
    }
    
    // Handle CMD+C copy
    if (([event modifierFlags] & NSCommandKeyMask) && 
        [[event charactersIgnoringModifiers] isEqualToString:@"c"] &&
        (self.m3uFieldActive || self.epgFieldActive)) {
        [self copy:self];
        return YES;
    }
    
    return [super performKeyEquivalent:event];
}

// Helper method to generate EPG URL from M3U URL following XMLTV standards
- (NSString *)generateEpgUrlFromM3uUrl:(NSString *)m3uUrl {
    if (!m3uUrl || [m3uUrl length] == 0) {
        return nil;
    }
    
    // Parse the M3U URL to extract components
    NSURL *url = [NSURL URLWithString:m3uUrl];
    if (!url) {
        // If not a valid URL, try adding http://
        if (![m3uUrl hasPrefix:@"http://"] && ![m3uUrl hasPrefix:@"https://"]) {
            url = [NSURL URLWithString:[@"http://" stringByAppendingString:m3uUrl]];
        }
        
        if (!url) {
            return nil; // Still not a valid URL
        }
    }
    
    // Extract the basic URL components
    NSString *host = [url host];
    if (!host) {
        return nil;
    }
    
    NSString *scheme = [url scheme] ?: @"http";
    NSNumber *port = [url port];
    NSString *portString = port ? [NSString stringWithFormat:@":%@", port] : @"";
    
    // Extract query parameters to find username and password
    NSString *username = @"";
    NSString *password = @"";
    
    // Parse the query string
    NSString *query = [url query];
    if (query) {
        NSArray *queryItems = [query componentsSeparatedByString:@"&"];
        for (NSString *item in queryItems) {
            NSArray *keyValue = [item componentsSeparatedByString:@"="];
            if (keyValue.count == 2) {
                NSString *key = keyValue[0];
                NSString *value = keyValue[1];
                
                if ([key isEqualToString:@"username"]) {
                    username = value;
                } else if ([key isEqualToString:@"password"]) {
                    password = value;
                }
            }
        }
    }
    
    // If no username/password in query, look for them in the URL path
    if (username.length == 0 || password.length == 0) {
        NSString *path = [url path];
        if (path) {
            // Look for patterns like /path/username/password/ or /path/username/password/stream
            NSArray *pathComponents = [path pathComponents];
            if (pathComponents.count >= 3) {
                // Try to identify username and password components
                // Typically, username and password are consecutive path components
                for (NSInteger i = 1; i < pathComponents.count - 1; i++) {
                    // Check for common username patterns (non-empty, not standard directories)
                    NSString *potentialUsername = pathComponents[i];
                    if (potentialUsername.length > 0 && 
                        ![potentialUsername isEqualToString:@"live"] &&
                        ![potentialUsername isEqualToString:@"iptv"] &&
                        ![potentialUsername isEqualToString:@"api"] &&
                        ![potentialUsername isEqualToString:@"xmltv"]) {
                        username = potentialUsername;
                        
                        // Next component might be password
                        if (i + 1 < pathComponents.count) {
                            NSString *potentialPassword = pathComponents[i+1];
                            if (potentialPassword.length > 0) {
                                password = potentialPassword;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Build the EPG URL in the standard format
    // http://SERVER_URL:PORT/xmltv.php?username=YOUR_USERNAME&password=YOUR_PASSWORD&type=m3u_plus&output=ts
    NSString *epgUrl = [NSString stringWithFormat:@"%@://%@%@/xmltv.php", scheme, host, portString];
    
    // Add query parameters if we have username/password
    if (username.length > 0 || password.length > 0) {
        epgUrl = [epgUrl stringByAppendingFormat:@"?username=%@&password=%@&type=m3u_plus&output=ts", 
                  username, password];
    }
    
    return epgUrl;
}
// Draw program guide panel for hovered channel
- (void)drawProgramGuideForHoveredChannel {
    // Get the hovered channel
    VLCChannel *channel = nil;
    NSString *currentGroup = nil;
    NSArray *groups = nil;
    
    // Get current category and group
    NSString *currentCategory = nil;
    if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
        currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
        
        // Get the appropriate groups based on category
        if ([currentCategory isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([currentCategory isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([currentCategory isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        }
        
        // Get the current group
        if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
            currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
            
            // Get channels for this group
            NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
            if (channelsInGroup && self.hoveredChannelIndex < channelsInGroup.count) {
                channel = [channelsInGroup objectAtIndex:self.hoveredChannelIndex];
            }
        }
    }
    
    if (!channel) {
        return;
    }
    
    // Calculate position for the panel
    CGFloat rowHeight = 400;
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat channelListX = catWidth + groupWidth;
    
    // Calculate channel list width as specified in drawChannelList
    CGFloat programGuideWidth = 400; // Increased width for program guide
    CGFloat channelListWidth = self.bounds.size.width - channelListX - programGuideWidth;
    
    // Guide panel starts after channel list
    CGFloat guidePanelX = channelListX + channelListWidth;
    CGFloat guidePanelWidth = programGuideWidth;
    CGFloat guidePanelHeight = self.bounds.size.height;
    
    // Draw background with glassmorphism effect to match the rest of the interface
    NSRect guidePanelRect = NSMakeRect(guidePanelX, 0, guidePanelWidth, guidePanelHeight);
    
    // Use glassmorphism background instead of solid gradient
    [self drawGlassmorphismPanel:guidePanelRect opacity:0.6 cornerRadius:0];
    
    // No header with channel name
    NSMutableParagraphStyle *headerStyle = [[NSMutableParagraphStyle alloc] init];
    [headerStyle setAlignment:NSTextAlignmentCenter];
    [headerStyle release];
    
    // Check if this is a movie channel (category = MOVIES)
    BOOL isMovie = [channel.category isEqualToString:@"MOVIES"];
    
    // For movie channels, show movie info with enhanced styling
    if (isMovie) {
        // Make sure we load the movie information if not already loaded
        if (!channel.hasLoadedMovieInfo && !channel.hasStartedFetchingMovieInfo) {
            // Check cache first
            BOOL loadedFromCache = [self loadMovieInfoFromCacheForChannel:channel];
            
            // If not in cache, trigger an async load
            if (!loadedFromCache) {
                channel.hasStartedFetchingMovieInfo = YES;
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                    [self fetchMovieInfoForChannel:channel];
                    
                    // Save to cache
                    [self saveMovieInfoToCache:channel];
                    
                    // Trigger redraw on main thread
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [self setNeedsDisplay:YES];
                    });
                });
            }
        }
        
        [self drawMovieInfoForChannel:channel inRect:guidePanelRect];
        return;
    }
    
    // Continue with regular program guide display for non-movies
    if (!channel.programs || [channel.programs count] == 0) {
        // No program data available
        NSRect messageRect = NSMakeRect(guidePanelX + 20, 
                                      guidePanelHeight / 2, 
                                      guidePanelWidth - 40, 
                                      20);
        
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *msgAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:14],
            NSForegroundColorAttributeName: [NSColor lightGrayColor],
            NSParagraphStyleAttributeName: style
        };
        
        [@"No program data available for this channel" drawInRect:messageRect withAttributes:msgAttrs];
        [style release];
        return;
    }
    
    // Sort programs by start time
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    // Get current time to highlight current program
    NSDate *now = [NSDate date];
    // Apply EPG time offset to current time for program detection
    // NOTE: Apply offset in opposite direction to correctly find current program
    NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600;
    NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
    NSInteger currentProgramIndex = -1;
    
    // Check if we're playing timeshift content and get the timeshift playing program
    BOOL isTimeshiftPlaying = [self isCurrentlyPlayingTimeshift];
    VLCProgram *timeshiftPlayingProgram = nil;
    NSInteger timeshiftProgramIndex = -1;
    
    if (isTimeshiftPlaying) {
        timeshiftPlayingProgram = [self getCurrentTimeshiftPlayingProgram];
        
        // Find the index of the timeshift playing program
        if (timeshiftPlayingProgram && channel.programs) {
            for (NSInteger i = 0; i < channel.programs.count; i++) {
                VLCProgram *program = [channel.programs objectAtIndex:i];
                if ([program.title isEqualToString:timeshiftPlayingProgram.title] &&
                    [program.startTime isEqualToDate:timeshiftPlayingProgram.startTime]) {
                    timeshiftProgramIndex = i;
                    break;
                }
            }
        }
    }
    
    // Find current live program index (for non-timeshift highlighting)
    if (channel.programs && channel.programs.count > 0) {
        for (NSInteger i = 0; i < channel.programs.count; i++) {
            VLCProgram *program = [channel.programs objectAtIndex:i];
            if (program.startTime && program.endTime) {
                if ([adjustedNow compare:program.startTime] != NSOrderedAscending && 
                    [adjustedNow compare:program.endTime] == NSOrderedAscending) {
                    currentProgramIndex = i;
                    break;
                }
            }
        }
    }
    
    // If we couldn't find current program, find the next program
    if (currentProgramIndex == -1) {
        for (NSInteger i = 0; i < [sortedPrograms count]; i++) {
            VLCProgram *program = [sortedPrograms objectAtIndex:i];
            if ([adjustedNow compare:program.startTime] == NSOrderedAscending) {
                currentProgramIndex = i;
                break;
            }
        }
    }
    
    // If we still couldn't find a program, use the first one
    if (currentProgramIndex == -1 && [sortedPrograms count] > 0) {
        currentProgramIndex = 0;
    }
    
    // Create paragraph styles for program items
    NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
    [titleStyle setAlignment:NSTextAlignmentLeft];
    
    NSMutableParagraphStyle *timeStyle = [[NSMutableParagraphStyle alloc] init];
    [timeStyle setAlignment:NSTextAlignmentRight];
    
    NSMutableParagraphStyle *descStyle = [[NSMutableParagraphStyle alloc] init];
    [descStyle setAlignment:NSTextAlignmentLeft];
    
    // Draw programs
    NSInteger visiblePrograms = 10; // Number of programs to show
    NSInteger startProgram = MAX(0, currentProgramIndex - 1); // Start 1 program before current
    
    // No program guide title or header
    NSMutableParagraphStyle *programListStyle = [[NSMutableParagraphStyle alloc] init];
    [programListStyle setAlignment:NSTextAlignmentLeft];
    
    [programListStyle release];
    
    // Draw actual program entries with modern card-based design
    CGFloat entryHeight = 65;
    CGFloat entrySpacing = 8;
    
    // Calculate content height with proper scaling
    CGFloat totalContentHeight = ([sortedPrograms count] * (entryHeight + entrySpacing));
    
    // Get visible height (guidePanelHeight is full height of the panel)
    CGFloat visibleContentHeight = guidePanelHeight;
    
    // Calculate correct maxScroll
    CGFloat maxScrollPosition = MAX(0, totalContentHeight - visibleContentHeight);
    
    // Auto-scroll to current program when EPG is first displayed for a new channel
    // Only auto-scroll if this is a new channel being hovered or user hasn't manually scrolled
    if (currentProgramIndex >= 0 && 
        (lastAutoScrolledChannelIndex != self.hoveredChannelIndex || !hasUserScrolledEpg)) {
        
        // Calculate the Y position of the current program
        CGFloat currentProgramY = guidePanelHeight - ((currentProgramIndex + 1) * (entryHeight + entrySpacing));
        
        // Calculate the center of the visible area
        CGFloat visibleCenter = visibleContentHeight / 2;
        
        // Calculate the desired scroll position to center the current program
        CGFloat desiredScrollPosition = -(currentProgramY - visibleCenter + (entryHeight / 2));
        
        // Ensure the desired position is within valid bounds
        desiredScrollPosition = MAX(0, desiredScrollPosition);
        desiredScrollPosition = MIN(maxScrollPosition, desiredScrollPosition);
        
        // Set the scroll position to center the current program
        self.epgScrollPosition = desiredScrollPosition;
        
        // Mark that we've auto-scrolled for this channel
        lastAutoScrolledChannelIndex = self.hoveredChannelIndex;
        hasUserScrolledEpg = NO; // Reset user scroll flag for new channel
    }
    
    // Ensure scroll position is within bounds
    self.epgScrollPosition = MIN(self.epgScrollPosition, maxScrollPosition);
    self.epgScrollPosition = MAX(0, self.epgScrollPosition);
    
    // Show all programs, not just a limited number
    NSInteger endProgram = [sortedPrograms count];
    
    // Create a clipping rect for the panel to ensure nothing draws outside
    NSGraphicsContext *context = [NSGraphicsContext currentContext];
    [context saveGraphicsState];
    
    NSBezierPath *clipPath = [NSBezierPath bezierPathWithRect:guidePanelRect];
    [clipPath setClip];
    
    for (NSInteger i = 0; i < endProgram; i++) {
        VLCProgram *program = [sortedPrograms objectAtIndex:i];
        
        // Calculate Y position for this item
        // Items start from the top and go down, accounting for scroll position
        CGFloat itemY = guidePanelHeight - ((i + 1) * (entryHeight + entrySpacing)) + self.epgScrollPosition;
        
        // Skip items that are completely outside the visible area
        if (itemY + entryHeight < 0 || itemY > guidePanelHeight) {
            continue;
        }
        
        // Draw program entry as a card with rounded corners
        NSRect entryRect = NSMakeRect(
            guidePanelX + 10,
            itemY,
            guidePanelWidth - 20,
            entryHeight
        );
        
        // Draw card background with gradient
        NSColor *cardBgColor;
        NSColor *cardBorderColor;
        NSColor *timeColor;
        NSColor *titleColor;
        NSColor *descColor;
        CGFloat cornerRadius = 8.0;
        
        // Style based on current program, timeshift program, catch-up availability, or standard
        if (isTimeshiftPlaying && i == timeshiftProgramIndex) {
            // Timeshift playing program gets special orange/amber highlight
            cardBgColor = [NSColor colorWithCalibratedRed:0.35 green:0.25 blue:0.10 alpha:0.7];
            cardBorderColor = [NSColor colorWithCalibratedRed:1.0 green:0.6 blue:0.2 alpha:0.9];
            timeColor = [NSColor colorWithCalibratedRed:1.0 green:0.8 blue:0.4 alpha:1.0];
            titleColor = [NSColor whiteColor];
            descColor = [NSColor colorWithCalibratedWhite:0.9 alpha:1.0];
        } else if (i == currentProgramIndex) {
            // Current live program gets theme-based highlight colors
            if (program.hasArchive) {
                // Current program with catch-up: use theme colors with green tint
                if (self.currentTheme == VLC_THEME_GREEN) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.08 green:0.25 blue:0.15 alpha:0.6];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.2 green:0.7 blue:0.4 alpha:0.8];
                } else if (self.currentTheme == VLC_THEME_BLUE) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.08 green:0.20 blue:0.32 alpha:0.6];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.2 green:0.6 blue:0.9 alpha:0.8];
                } else if (self.currentTheme == VLC_THEME_PURPLE) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.20 green:0.12 blue:0.25 alpha:0.6];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.6 green:0.3 blue:0.8 alpha:0.8];
                } else {
                    // Dark themes get blue-green tint
                    cardBgColor = [NSColor colorWithCalibratedRed:0.10 green:0.28 blue:0.35 alpha:0.6];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.3 green:0.8 blue:0.6 alpha:0.8];
                }
            } else {
                // Current program without catch-up: theme-based highlight
                if (self.currentTheme == VLC_THEME_BLUE) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.10 green:0.20 blue:0.35 alpha:0.5];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.3 green:0.6 blue:1.0 alpha:0.7];
                } else if (self.currentTheme == VLC_THEME_GREEN) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.08 green:0.25 blue:0.15 alpha:0.5];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.2 green:0.8 blue:0.4 alpha:0.7];
                } else if (self.currentTheme == VLC_THEME_PURPLE) {
                    cardBgColor = [NSColor colorWithCalibratedRed:0.20 green:0.12 blue:0.30 alpha:0.5];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.6 green:0.3 blue:0.9 alpha:0.7];
                } else {
                    // Dark themes get standard blue highlight
                    cardBgColor = [NSColor colorWithCalibratedRed:0.12 green:0.24 blue:0.4 alpha:0.5];
                    cardBorderColor = [NSColor colorWithCalibratedRed:0.4 green:0.7 blue:1.0 alpha:0.7];
                }
            }
            timeColor = [NSColor colorWithCalibratedRed:0.6 green:0.9 blue:1.0 alpha:1.0];
            titleColor = [NSColor whiteColor];
            descColor = [NSColor colorWithCalibratedWhite:0.85 alpha:1.0];
        } else if (program.hasArchive) {
            // Non-current program with catch-up: theme-based light tint
            if (self.currentTheme == VLC_THEME_GREEN) {
                cardBgColor = [NSColor colorWithCalibratedRed:0.08 green:0.18 blue:0.12 alpha:0.5];
                cardBorderColor = [NSColor colorWithCalibratedRed:0.15 green:0.4 blue:0.25 alpha:0.5];
                timeColor = [NSColor colorWithCalibratedRed:0.6 green:0.9 blue:0.7 alpha:1.0];
            } else if (self.currentTheme == VLC_THEME_BLUE) {
                cardBgColor = [NSColor colorWithCalibratedRed:0.08 green:0.15 blue:0.20 alpha:0.5];
                cardBorderColor = [NSColor colorWithCalibratedRed:0.15 green:0.35 blue:0.5 alpha:0.5];
                timeColor = [NSColor colorWithCalibratedRed:0.6 green:0.8 blue:0.9 alpha:1.0];
            } else if (self.currentTheme == VLC_THEME_PURPLE) {
                cardBgColor = [NSColor colorWithCalibratedRed:0.15 green:0.10 blue:0.18 alpha:0.5];
                cardBorderColor = [NSColor colorWithCalibratedRed:0.3 green:0.2 blue:0.4 alpha:0.5];
                timeColor = [NSColor colorWithCalibratedRed:0.8 green:0.7 blue:0.9 alpha:1.0];
            } else {
                // Dark themes get default green tint
                cardBgColor = [NSColor colorWithCalibratedRed:0.12 green:0.22 blue:0.15 alpha:0.5];
                cardBorderColor = [NSColor colorWithCalibratedRed:0.2 green:0.5 blue:0.3 alpha:0.5];
                timeColor = [NSColor colorWithCalibratedRed:0.7 green:0.9 blue:0.7 alpha:1.0];
            }
            titleColor = [NSColor colorWithCalibratedWhite:0.95 alpha:1.0];
            descColor = [NSColor colorWithCalibratedRed:0.8 green:0.9 blue:0.8 alpha:1.0];
        } else {
            // Other programs get theme-based standard card colors
            if (self.themeChannelStartColor && self.themeChannelEndColor) {
                // Use a slightly lighter version of the theme colors for cards
                CGFloat cardAlpha = self.themeAlpha * 0.7;
                cardBgColor = [self.themeChannelStartColor colorWithAlphaComponent:cardAlpha];
                cardBorderColor = [self.themeChannelEndColor colorWithAlphaComponent:cardAlpha * 0.8];
            } else {
                // Fallback to standard colors
                cardBgColor = [NSColor colorWithCalibratedRed:0.15 green:0.15 blue:0.15 alpha:0.5];
                cardBorderColor = [NSColor colorWithCalibratedRed:0.3 green:0.3 blue:0.3 alpha:0.4];
            }
            timeColor = [NSColor colorWithCalibratedRed:0.7 green:0.7 blue:0.7 alpha:1.0];
            titleColor = [NSColor whiteColor];
            descColor = [NSColor colorWithCalibratedWhite:0.75 alpha:1.0];
        }
        
        // Draw rounded rectangle for card
        NSBezierPath *cardPath = [NSBezierPath bezierPathWithRoundedRect:entryRect xRadius:cornerRadius yRadius:cornerRadius];
        [cardBgColor set];
        [cardPath fill];
        
        // Draw a subtle border
        [cardPath setLineWidth:1.0];
        [cardBorderColor set];
        [cardPath stroke];
        
        // Create proper text styles
        NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
        [titleStyle setAlignment:NSTextAlignmentLeft];
        [titleStyle setLineBreakMode:NSLineBreakByTruncatingTail];
        
        NSMutableParagraphStyle *timeStyle = [[NSMutableParagraphStyle alloc] init];
        [timeStyle setAlignment:NSTextAlignmentLeft];
        
        NSMutableParagraphStyle *descStyle = [[NSMutableParagraphStyle alloc] init];
        [descStyle setAlignment:NSTextAlignmentLeft];
        [descStyle setLineBreakMode:NSLineBreakByTruncatingTail];
        
        // Calculate padding inside card
        CGFloat padding = 10;
        CGFloat timeHeight = 15;
        CGFloat titleHeight = 20;
        CGFloat descHeight = 18;
        
        // Draw time at the top
        NSString *timeString = [program formattedTimeRangeWithOffset:self.epgTimeOffsetHours];
        if (!timeString) {
            timeString = @"";
        }
        
        // Debug: Log what times we're showing in the program guide
        //if (i == currentProgramIndex) {
            //NSLog(@"PROGRAM GUIDE - Current program: %@ (%@ - %@)", program.title, program.startTime, program.endTime);
            //NSLog(@"PROGRAM GUIDE - Formatted time: %@", timeString);
            //NSLog(@"PROGRAM GUIDE - EPG offset: %ld hours", (long)self.epgTimeOffsetHours);
        //}
        
        NSDictionary *timeAttrs = @{
            NSFontAttributeName: [NSFont fontWithName:@"HelveticaNeue-Medium" size:12] ?: [NSFont systemFontOfSize:12],
            NSForegroundColorAttributeName: timeColor,
            NSParagraphStyleAttributeName: timeStyle
        };
        
        NSRect timeRect = NSMakeRect(
            entryRect.origin.x + padding,
            entryRect.origin.y + entryHeight - timeHeight - padding,
            entryRect.size.width - (padding * 2),
            timeHeight
        );
        
        [timeString drawInRect:timeRect withAttributes:timeAttrs];
        
        // Draw title below time
        NSString *titleString = program.title ? program.title : @"Unknown Program";
        
        NSDictionary *titleAttrs = @{
            NSFontAttributeName: [NSFont fontWithName:@"HelveticaNeue-Bold" size:14] ?: [NSFont boldSystemFontOfSize:14],
            NSForegroundColorAttributeName: titleColor,
            NSParagraphStyleAttributeName: titleStyle
        };
        
        NSRect titleRect = NSMakeRect(
            entryRect.origin.x + padding,
            timeRect.origin.y - titleHeight,
            entryRect.size.width - (padding * 2),
            titleHeight
        );
        
        [titleString drawInRect:titleRect withAttributes:titleAttrs];
        
        // Draw description at the bottom with extra padding from title
        NSString *descText = program.programDescription;
        if (!descText) descText = @"No description available";
        if ([descText length] > 110) { // Allow longer descriptions
            descText = [[descText substringToIndex:107] stringByAppendingString:@"..."];
        }
        
        // Make description text lighter and more readable
        NSColor *lighterDescColor = [NSColor colorWithCalibratedRed:0.9 green:0.9 blue:0.9 alpha:1.0];
        if (i == currentProgramIndex) {
            // For current program, use a brighter color
            lighterDescColor = [NSColor colorWithCalibratedWhite:0.95 alpha:1.0];
        } else {
            // For other programs, use a lighter gray
            lighterDescColor = [NSColor colorWithCalibratedWhite:0.9 alpha:1.0];
        }
        
        NSDictionary *descAttrs = @{
            NSFontAttributeName: [NSFont fontWithName:@"HelveticaNeue-Light" size:12] ?: [NSFont systemFontOfSize:12],
            NSForegroundColorAttributeName: lighterDescColor,
            NSParagraphStyleAttributeName: descStyle
        };
        
        // Add 6 pixels of padding between title and description
        NSRect descRect = NSMakeRect(
            entryRect.origin.x + padding,
            entryRect.origin.y + padding,
            entryRect.size.width - (padding * 2),
            descHeight
        );
        
        // Move the description down by 6 pixels from its base position
        descRect.origin.y -= 6;
        
        [descText drawInRect:descRect withAttributes:descAttrs];
        
        // Draw catch-up indicator if available
        if (program.hasArchive) {
            // Draw a small "C" indicator in the top-right corner
            NSRect catchupIndicatorRect = NSMakeRect(
                entryRect.origin.x + entryRect.size.width - 25,
                entryRect.origin.y + entryHeight - 20,
                18,
                15
            );
            
            // Draw background circle for the indicator
            NSBezierPath *indicatorBg = [NSBezierPath bezierPathWithOvalInRect:catchupIndicatorRect];
            [[NSColor colorWithCalibratedRed:0.2 green:0.6 blue:0.3 alpha:0.8] set];
            [indicatorBg fill];
            
            // Draw "C" text
            NSDictionary *catchupTextAttrs = @{
                NSFontAttributeName: [NSFont fontWithName:@"HelveticaNeue-Bold" size:10] ?: [NSFont boldSystemFontOfSize:10],
                NSForegroundColorAttributeName: [NSColor whiteColor]
            };
            
            NSRect catchupTextRect = NSMakeRect(
                catchupIndicatorRect.origin.x + 5,
                catchupIndicatorRect.origin.y + 2,
                catchupIndicatorRect.size.width - 10,
                catchupIndicatorRect.size.height - 4
            );
            
            [@"C" drawInRect:catchupTextRect withAttributes:catchupTextAttrs];
        }
        
        // If it's the current program, draw a little indicator
        if (i == currentProgramIndex) {
            NSRect indicatorRect = NSMakeRect(
                entryRect.origin.x,
                entryRect.origin.y,
                4,
                entryHeight
            );
            
            if (program.hasArchive) {
                // Current program with catch-up: green-blue indicator
                [[NSColor colorWithCalibratedRed:0.3 green:0.8 blue:0.6 alpha:0.8] set];
            } else {
                // Current program without catch-up: standard blue indicator
                [[NSColor colorWithCalibratedRed:0.4 green:0.7 blue:1.0 alpha:0.7] set];
            }
            
            NSBezierPath *indicatorPath = [NSBezierPath bezierPathWithRoundedRect:indicatorRect 
                                                                          xRadius:2 
                                                                          yRadius:2];
            [indicatorPath fill];
        }
        
        // Highlight the timeshift playing program with reduced transparency
        if (isTimeshiftPlaying && timeshiftProgramIndex == i) {
            NSColor *highlightColor = [NSColor colorWithCalibratedRed:0.1 green:0.2 blue:0.3 alpha:0.3];
            [highlightColor set];
            NSRectFillUsingOperation(entryRect, NSCompositeSourceOver);
        }
        
        [titleStyle release];
        [timeStyle release];
        [descStyle release];
    }
    
    // Restore graphics state after clipping
    [context restoreGraphicsState];
    
    // Draw scroll indicator if content is scrollable
    if (totalContentHeight > visibleContentHeight) { // Show scroll indicator if content exceeds visible area
        // Use the standard drawScrollBar method to match channel list appearance
        NSRect contentRect = NSMakeRect(guidePanelX, 0, guidePanelWidth, guidePanelHeight);
        
        // Make scroll bar visible when there's content to scroll
        if (scrollBarAlpha < 1.0) {
            scrollBarAlpha = 1.0; // Ensure scrollbar is visible
        }
        
        [self drawScrollBar:contentRect contentHeight:totalContentHeight scrollPosition:self.epgScrollPosition];
    }
}
// Draw movie info when hovering over a movie item - fix the top bar and title overlapping
- (void)drawMovieInfoForChannel:(VLCChannel *)channel inRect:(NSRect)panelRect {
    if (!channel) return;
    
    // Debug logging
    NSLog(@"Drawing movie info for channel: %@", channel.name);
    NSLog(@"Channel logo URL: %@", channel.logo);
    NSLog(@"Channel category: %@", channel.category);
    
    // Define constant for the increased background height
    CGFloat backgroundHeightIncrease = 30.0;
    
    // Determine loading status based on channel properties
    BOOL isFetchingInfo = channel.hasStartedFetchingMovieInfo && !channel.hasLoadedMovieInfo;
    
    // Calculate base measurements based on available space
    CGFloat padding = MAX(10, panelRect.size.width * 0.02); // Responsive padding (min 10px)
    CGFloat rowHeight = 400;
    
    // Apply scroll position with debugging
    NSGraphicsContext *context = [NSGraphicsContext currentContext];
    [context saveGraphicsState];
    
    // Use the standard panel rect for clipping to avoid issues
    NSBezierPath *clipPath = [NSBezierPath bezierPathWithRect:panelRect];
    [clipPath setClip];
    
    // Apply the scroll offset to the content - this is critical for scrolling to work
    CGFloat scrollOffset = self.movieInfoScrollPosition;
    NSLog(@"Applying scroll offset: %.1f to movie info panel", scrollOffset);
    
    NSAffineTransform *transform = [NSAffineTransform transform];
    [transform translateXBy:0 yBy:scrollOffset];
    [transform concat];
    
    // Get the available space (no header)
    CGFloat availableHeight = panelRect.size.height;
    CGFloat availableWidth = panelRect.size.width - (padding * 2);
    
    // Create paragraph styles
    NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
    [titleStyle setAlignment:NSTextAlignmentCenter];
    
    NSMutableParagraphStyle *descStyle = [[NSMutableParagraphStyle alloc] init];
    [descStyle setAlignment:NSTextAlignmentCenter];
    
    NSMutableParagraphStyle *metadataStyle = [[NSMutableParagraphStyle alloc] init];
    [metadataStyle setAlignment:NSTextAlignmentLeft];
    
    // Draw background - standard height to avoid clipping issues
    NSColor *bgColor = self.isHoveringMovieInfoPanel ? 
                      [self.backgroundColor colorWithAlphaComponent:1.0] : 
                      [self.backgroundColor colorWithAlphaComponent:0.9];
    [bgColor set];
    NSRectFill(panelRect);
    
    // If hovering, draw a subtle border to indicate this panel is active
    if (self.isHoveringMovieInfoPanel) {
        NSBezierPath *borderPath = [NSBezierPath bezierPathWithRect:NSInsetRect(panelRect, 1, 1)];
        [borderPath setLineWidth:2.0];
        [[NSColor colorWithWhite:0.5 alpha:0.3] set];
        [borderPath stroke];
    }
    
    // Declare the posterImage variable and initialize it to nil
    NSImage *posterImage = nil;
    
    // Draw movie title (height of 40px or 5% of available height, whichever is larger)
    CGFloat titleHeight = MAX(40, availableHeight * 0.05);
    NSRect titleRect = NSMakeRect(
        panelRect.origin.x + padding,
        panelRect.size.height - titleHeight,
        availableWidth,
        titleHeight
    );
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:18],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: titleStyle
    };
    
    // Use a more specific title to avoid duplication with the one already on screen
    [channel.name drawInRect:titleRect withAttributes:titleAttrs];
    
    // Check if we have a logo URL (movie poster)
    BOOL hasLogo = (channel.logo != nil && [channel.logo length] > 0);
    NSLog(@"Has logo: %@", hasLogo ? @"YES" : @"NO");
    
    // Calculate poster dimensions with proper aspect ratio - making it much larger
    CGFloat posterHeightPercent = 0.6; // Increase the poster height percentage significantly
    CGFloat posterHeight = MIN(MAX(270, availableHeight * posterHeightPercent), availableHeight * 0.8); // Make much taller
    CGFloat posterWidth = posterHeight * 0.75; // Standard movie poster aspect ratio
    
    // Add extra height to match user request
    CGFloat extraHeight = 40.0; // 40px taller as requested
    posterHeight += extraHeight;
    
    // Update width to maintain aspect ratio with the taller height
    posterWidth = posterHeight * 0.75; // Maintain proper movie poster aspect ratio
    
    // Calculate total content height needed to ensure proper spacing - with reduced space for other elements
    CGFloat metadataHeight = MIN(45, availableHeight * 0.1); // Reduced slightly for better fit
    CGFloat descriptionMinHeight = 80; // Reduced minimum height for description to accommodate larger poster
    
    // Calculate the vertical space needed for all elements except poster
    CGFloat nonPosterVerticalSpace = titleHeight + metadataHeight + descriptionMinHeight + (padding * 3);
    
    // Calculate space available for poster with equal top/bottom margins
    CGFloat posterAvailableSpace = availableHeight - nonPosterVerticalSpace;
    
    // Position poster higher on the screen
    CGFloat topMargin = MAX(padding, 15); // Use a smaller top margin to position poster higher
    
    // Position poster higher up after the title with reduced margin
    CGFloat posterY = panelRect.size.height - titleHeight - topMargin - posterHeight;
    
    // Center the poster horizontally with even left/right margins
    CGFloat horizontalMargin = (availableWidth - posterWidth) / 2;
    NSRect posterRect = NSMakeRect(
        panelRect.origin.x + padding + horizontalMargin,
        posterY,
        posterWidth,
        posterHeight
    );
    
    // Draw poster area with border - ensure it stays within actual visible bounds
    NSRect safeRect = NSIntersectionRect(posterRect, panelRect);
    [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:0.8] set];
    NSRectFill(safeRect);
    [[NSColor lightGrayColor] set];
    NSFrameRect(safeRect);
    
    // Draw movie poster if available, or a placeholder
    if (hasLogo) {
        // Try to load image from URL
        NSString *logoUrl = channel.logo;
        // Sometimes logos have spaces or special characters - encode the URL properly
        if (logoUrl && ![logoUrl stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]].length == 0) {
            // First try to use the URL encoding API available in newer macOS versions
            if ([logoUrl respondsToSelector:@selector(stringByAddingPercentEncodingWithAllowedCharacters:)]) {
                // Create a character set specifically for URLs
                NSCharacterSet *urlAllowedSet = [NSCharacterSet URLQueryAllowedCharacterSet];
                logoUrl = [logoUrl stringByAddingPercentEncodingWithAllowedCharacters:urlAllowedSet];
            } else {
                // Fallback to older encoding method for backward compatibility
                logoUrl = [logoUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
            }
            NSLog(@"Encoded URL: %@", logoUrl);
        }
        
        NSLog(@"Attempting to load image from: %@", logoUrl);
        
        // Try to load the image from the URL
        if (logoUrl && [logoUrl length] > 0) {
            NSLog(@"Loading from web URL: %@", logoUrl);
            
            // Create a URL object
            NSURL *imageUrl = [NSURL URLWithString:logoUrl];
            if (!imageUrl) {
                NSLog(@"Invalid URL format: %@", logoUrl);
            } else {
                // If we already have a cached image from a previous load, use it
                if (channel.cachedPosterImage) {
                    posterImage = channel.cachedPosterImage;
                } 
                // If no cached image, start an asynchronous download
                else {
                    // Draw a placeholder indicating image is loading
                    NSString *loadingPlaceholder = @"Loading image...";
                    NSDictionary *placeholderAttrs = @{
                        NSFontAttributeName: [NSFont systemFontOfSize:12],
                        NSForegroundColorAttributeName: [NSColor lightGrayColor],
                        NSParagraphStyleAttributeName: titleStyle
                    };
                    
                    [loadingPlaceholder drawInRect:NSInsetRect(posterRect, 5, 5) withAttributes:placeholderAttrs];
                    
                    // Use our new asynchronous method to load the image
                    [self loadImageAsynchronously:logoUrl forChannel:channel];
                }
            }
        }
    }
    
    // If we have a posterImage (from cache), draw it
        if (posterImage) {
            // Calculate the image size to maintain aspect ratio
            NSSize imageSize = [posterImage size];
            CGFloat aspectRatio = imageSize.width / imageSize.height;
            
            // Create a slightly smaller rectangle inside the poster rect with reduced padding for larger image
            CGFloat imagePadding = 6.0; // Reduce padding to allow image to fill more of the frame
            NSRect innerRect = NSInsetRect(posterRect, imagePadding, imagePadding);
            
            NSRect drawRect;
            if (aspectRatio > (innerRect.size.width / innerRect.size.height)) {
                // Image is wider than the target area
                CGFloat scaledHeight = innerRect.size.width / aspectRatio;
                CGFloat yOffset = (innerRect.size.height - scaledHeight) / 2;
                drawRect = NSMakeRect(innerRect.origin.x, innerRect.origin.y + yOffset, innerRect.size.width, scaledHeight);
            } else {
                // Image is taller than the target area
                CGFloat scaledWidth = innerRect.size.height * aspectRatio;
                CGFloat xOffset = (innerRect.size.width - scaledWidth) / 2;
                drawRect = NSMakeRect(innerRect.origin.x + xOffset, innerRect.origin.y, scaledWidth, innerRect.size.height);
            }
            
            // Ensure image is drawn only within panelRect boundaries
            NSRect safeDrawRect = NSIntersectionRect(drawRect, panelRect);
            
            // Apply rounded corners to the movie poster - larger radius for the bigger poster
            [NSGraphicsContext saveGraphicsState];
            NSBezierPath *clipPath = [NSBezierPath bezierPathWithRoundedRect:innerRect xRadius:5 yRadius:5];
            [clipPath setClip];
            
            NSLog(@"Drawing image in rect: %@", NSStringFromRect(safeDrawRect));
            [posterImage drawInRect:safeDrawRect fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0];
            
            [NSGraphicsContext restoreGraphicsState];
    } else if (!channel.hasStartedFetchingMovieInfo || !hasLogo) {
        // Only draw background when there's no logo - using exact poster rect which is visible
        NSRect safeRect = posterRect;
        [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0] set];
        NSRectFill(safeRect);
        NSLog(@"Drawing placeholder background - no logo available");
    } else if (channel.hasStartedFetchingMovieInfo && !channel.hasLoadedMovieInfo) {
        // Show loading indicator when fetching image - using exact poster rect
        NSRect safeRect = posterRect;
        [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0] set];
        NSRectFill(safeRect);
        
        NSString *loadingText = @"Loading...";
        NSDictionary *loadingAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:12],
            NSForegroundColorAttributeName: [NSColor lightGrayColor],
            NSParagraphStyleAttributeName: titleStyle
        };
        
        [loadingText drawInRect:NSInsetRect(safeRect, 5, 5) withAttributes:loadingAttrs];
    }
    
    // Calculate metadata position relative to poster bottom with reduced spacing
    CGFloat metadataY = posterRect.origin.y - metadataHeight - (padding * 0.7); // Use 70% of normal padding to fit everything
    
    // Calculate metadata area below poster with dynamic sizing
    NSRect metadataRect = NSMakeRect(
        panelRect.origin.x + padding,
        metadataY,
        availableWidth,
        metadataHeight
    );
    
    // Draw metadata if available - in a horizontal row below the poster
    if (channel.hasLoadedMovieInfo && 
        (channel.movieGenre || channel.movieYear || channel.movieRating || channel.movieDuration)) {
        
        // Draw a subtle background for metadata section - extend to full panel width
        NSRect fullMetadataRect = NSMakeRect(
            panelRect.origin.x,  // Start from panel edge, not with padding
            metadataRect.origin.y,
            panelRect.size.width,  // Use full panel width
            metadataRect.size.height
        );
        [[NSColor colorWithCalibratedRed:0.15 green:0.15 blue:0.15 alpha:0.7] set];
        NSRectFill(fullMetadataRect);
        
        // Create a horizontal layout for metadata
        CGFloat metadataItemWidth = availableWidth / 4; // 4 items: genre, year, rating, duration
        CGFloat metadataItemHeight = metadataRect.size.height;
        CGFloat yPos = metadataRect.origin.y + (metadataItemHeight / 2) - 10; // Center vertically
        
        NSMutableParagraphStyle *metadataHeaderStyle = [[NSMutableParagraphStyle alloc] init];
        [metadataHeaderStyle setAlignment:NSTextAlignmentCenter];
        
        NSMutableParagraphStyle *metadataValueStyle = [[NSMutableParagraphStyle alloc] init];
        [metadataValueStyle setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *metadataHeaderAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:12],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: metadataHeaderStyle
        };
        
        NSDictionary *metadataValueAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:12],
            NSForegroundColorAttributeName: [NSColor lightGrayColor],
            NSParagraphStyleAttributeName: metadataValueStyle
        };
        
        // Position for drawing metadata items
        CGFloat itemX = metadataRect.origin.x;
        
        // Draw Genre
        if (channel.movieGenre) {
            NSRect genreHeaderRect = NSMakeRect(itemX, yPos, metadataItemWidth, 16);
            NSRect genreValueRect = NSMakeRect(itemX, yPos - 20, metadataItemWidth, 16);
            
            [@"Genre" drawInRect:genreHeaderRect withAttributes:metadataHeaderAttrs];
            [channel.movieGenre drawInRect:genreValueRect withAttributes:metadataValueAttrs];
            
            itemX += metadataItemWidth;
        }
        
        // Draw Year
        if (channel.movieYear) {
            NSRect yearHeaderRect = NSMakeRect(itemX, yPos, metadataItemWidth, 16);
            NSRect yearValueRect = NSMakeRect(itemX, yPos - 20, metadataItemWidth, 16);
            
            [@"Year" drawInRect:yearHeaderRect withAttributes:metadataHeaderAttrs];
            // Ensure we have a string before drawing
            NSString *yearString = [channel.movieYear isKindOfClass:[NSString class]] ? 
                                  channel.movieYear : 
                                  [NSString stringWithFormat:@"%@", channel.movieYear];
            [yearString drawInRect:yearValueRect withAttributes:metadataValueAttrs];
            
            itemX += metadataItemWidth;
        }
        
        // Draw Rating
        if (channel.movieRating) {
            NSRect ratingHeaderRect = NSMakeRect(itemX, yPos, metadataItemWidth, 16);
            NSRect ratingValueRect = NSMakeRect(itemX, yPos - 20, metadataItemWidth, 16);
            
            [@"Rating" drawInRect:ratingHeaderRect withAttributes:metadataHeaderAttrs];
            // Ensure we have a string before drawing
            NSString *ratingString = [channel.movieRating isKindOfClass:[NSString class]] ? 
                                    channel.movieRating : 
                                    [NSString stringWithFormat:@"%@", channel.movieRating];
            [ratingString drawInRect:ratingValueRect withAttributes:metadataValueAttrs];
            
            itemX += metadataItemWidth;
        }
        
        // Draw Duration
        if (channel.movieDuration) {
            NSRect durationHeaderRect = NSMakeRect(itemX, yPos, metadataItemWidth, 16);
            NSRect durationValueRect = NSMakeRect(itemX, yPos - 20, metadataItemWidth, 16);
            
            // Format the duration nicely if it's in seconds
            NSString *formattedDuration = nil;
            
            // Handle case where movieDuration might be an NSNumber instead of NSString
            if ([channel.movieDuration isKindOfClass:[NSNumber class]]) {
                NSInteger seconds = [(NSNumber *)channel.movieDuration integerValue];
                NSInteger hours = seconds / 3600;
                NSInteger minutes = (seconds % 3600) / 60;
                
                if (hours > 0) {
                    formattedDuration = [NSString stringWithFormat:@"%ldh %ldm", (long)hours, (long)minutes];
                } else {
                    formattedDuration = [NSString stringWithFormat:@"%ldm", (long)minutes];
                }
            } else if ([channel.movieDuration isKindOfClass:[NSString class]]) {
                NSString *durationString = (NSString *)channel.movieDuration;
                if ([self isNumeric:durationString]) {
                    NSInteger seconds = [durationString integerValue];
                    NSInteger hours = seconds / 3600;
                    NSInteger minutes = (seconds % 3600) / 60;
                    
                    if (hours > 0) {
                        formattedDuration = [NSString stringWithFormat:@"%ldh %ldm", (long)hours, (long)minutes];
                    } else {
                        formattedDuration = [NSString stringWithFormat:@"%ldm", (long)minutes];
                    }
                } else {
                    formattedDuration = durationString;
                }
            } else {
                // Fallback for any other type
                formattedDuration = [NSString stringWithFormat:@"%@", channel.movieDuration];
            }
            
            [@"Duration" drawInRect:durationHeaderRect withAttributes:metadataHeaderAttrs];
            [formattedDuration drawInRect:durationValueRect withAttributes:metadataValueAttrs];
        }
        
        [metadataHeaderStyle release];
        [metadataValueStyle release];
    }
    
    // Calculate description area to fit in remaining space
    CGFloat descriptionY = metadataRect.origin.y - padding;
    CGFloat descriptionHeight = descriptionY - panelRect.origin.y - (2 * padding);
    
    // Ensure description has at least minimal height
    if (descriptionHeight < 50) {
        descriptionHeight = MIN(50, panelRect.origin.y + padding);
        descriptionY = panelRect.origin.y + descriptionHeight + padding;
    }
    
    NSRect descriptionRect = NSMakeRect(
        panelRect.origin.x + padding,
        panelRect.origin.y + padding,
        availableWidth,
        descriptionHeight
    );
    
    // Draw description in remaining space
    if (descriptionHeight >= 50) {
        // Draw description header
        NSDictionary *descHeaderAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: titleStyle
        };
        
        NSRect descHeaderRect = NSMakeRect(
            descriptionRect.origin.x,
            descriptionRect.origin.y + descriptionRect.size.height - 20,
            descriptionRect.size.width,
            20
        );
        
        [@"Description:" drawInRect:descHeaderRect withAttributes:descHeaderAttrs];
        
        // Draw movie description content
        NSMutableParagraphStyle *descContentStyle = [[NSMutableParagraphStyle alloc] init];
        [descContentStyle setAlignment:NSTextAlignmentLeft];
        
        NSDictionary *descContentAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:12],
            NSForegroundColorAttributeName: [NSColor lightGrayColor],
            NSParagraphStyleAttributeName: descContentStyle
        };
        
        NSRect descContentRect = NSMakeRect(
            descriptionRect.origin.x,
            descriptionRect.origin.y,
            descriptionRect.size.width,
            descriptionRect.size.height - 25
        );
        
        // Get description text from API data if available, or fallback
        NSString *description = nil;
        
        // Try to get description from API data first
        if (channel.movieDescription) {
            // Make sure it's a string
            if ([channel.movieDescription isKindOfClass:[NSString class]]) {
                NSString *descStr = (NSString *)channel.movieDescription;
                if (descStr.length > 0) {
                    description = descStr;
                }
            } else {
                // If it's some other type, convert it to string
                description = [NSString stringWithFormat:@"%@", channel.movieDescription];
            }
        }
        // Then try to get from program data
        else if (channel.programs && channel.programs.count > 0) {
            VLCProgram *program = [channel.programs objectAtIndex:0];
            if (program.programDescription && program.programDescription.length > 0) {
                description = program.programDescription;
            }
        }
        
        // If no description was found, create a placeholder based on fetch status
        if (!description || description.length == 0) {
            if (isFetchingInfo) {
                description = @"Loading movie information...\n\nPlease wait while we fetch movie details.";
            } else if (channel.hasLoadedMovieInfo) {
                description = @"No description available for this movie.\n\nClick to play this movie.";
            } else {
                description = @"Hover for a moment to load movie information...\n\nClick to play this movie.";
            }
        }
        
        // Final safety check - ensure description is actually a string
        if (![description isKindOfClass:[NSString class]]) {
            description = [NSString stringWithFormat:@"%@", description];
        }
        
        // Ensure we don't try to draw in a negative space
        if (descContentRect.size.height > 0) {
            [description drawInRect:descContentRect withAttributes:descContentAttrs];
        }
        
        [descContentStyle release];
    }
    
    // Only draw file info if there's enough space
    if (panelRect.size.height > 300) {
        // Small footnote with file info
        NSMutableParagraphStyle *fileInfoStyle = [[NSMutableParagraphStyle alloc] init];
        [fileInfoStyle setAlignment:NSTextAlignmentLeft];
        
        NSDictionary *fileInfoAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:9],
            NSForegroundColorAttributeName: [NSColor darkGrayColor],
            NSParagraphStyleAttributeName: fileInfoStyle
        };
        
        NSString *fileExtension = [self fileExtensionFromUrl:channel.url];
        NSString *fileInfo = [NSString stringWithFormat:@"File Type: %@ | Movie ID: %@", 
                            fileExtension ? fileExtension : @"Unknown",
                            channel.movieId ? channel.movieId : @"Unknown"];
        
        NSRect fileInfoRect = NSMakeRect(
            panelRect.origin.x + padding,
            panelRect.origin.y + 2,
            availableWidth,
            12
        );
        
        [fileInfo drawInRect:fileInfoRect withAttributes:fileInfoAttrs];
        [fileInfoStyle release];
    }
    
    [titleStyle release];
    [descStyle release];
    [metadataStyle release];
    
    // Restore the graphics state to undo clipping and scrolling transform
    [context restoreGraphicsState];
    
    // Draw scroll indicator if hovering over movie info panel
    if (self.isHoveringMovieInfoPanel) {
        // Calculate content height based on description length
        // Using the same highly aggressive calculation as our scroll handler
        CGFloat contentHeight = 5000; // Significantly increased default
        if (channel.movieDescription) {
            NSInteger descriptionLength = [channel.movieDescription length];
            // Using a much higher scaling factor to ensure scrolling works
            contentHeight = MAX(contentHeight, 1000 + (descriptionLength * 5.0)); // Very aggressive approximation
            
            NSLog(@"Scroll indicator: content height = %.1f, scroll pos = %.1f", 
                  contentHeight, self.movieInfoScrollPosition);
        }
        
        CGFloat visibleHeight = panelRect.size.height;
        CGFloat maxScroll = MAX(0, contentHeight - visibleHeight);
        
        // Only draw scroll indicator if content is scrollable
        if (maxScroll > 0) {
            // Draw scroll indicator track
            NSRect scrollTrackRect = NSMakeRect(
                panelRect.origin.x + panelRect.size.width - 8,
                panelRect.origin.y,
                6,
                panelRect.size.height
            );
            
            [[NSColor colorWithWhite:0.3 alpha:0.3] set];
            NSRectFill(scrollTrackRect);
            
            // Calculate scroll thumb position and size
            CGFloat thumbRatio = visibleHeight / contentHeight;
            CGFloat thumbHeight = MAX(40, visibleHeight * thumbRatio);
            CGFloat scrollRatio = scrollOffset / maxScroll;
            CGFloat thumbY = panelRect.origin.y + (visibleHeight - thumbHeight) * (1.0 - scrollRatio);
            
            NSRect scrollThumbRect = NSMakeRect(
                panelRect.origin.x + panelRect.size.width - 8,
                thumbY,
                6,
                thumbHeight
            );
            
            [[NSColor colorWithWhite:0.7 alpha:0.7] set];
            NSBezierPath *thumbPath = [NSBezierPath bezierPathWithRoundedRect:scrollThumbRect xRadius:3 yRadius:3];
            [thumbPath fill];
        }
    }
}

// Helper to check if a string is numeric (for duration formatting)
- (BOOL)isNumeric:(NSString *)string {
    if (!string) return NO;
    NSCharacterSet *nonNumbers = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    return [string rangeOfCharacterFromSet:nonNumbers].location == NSNotFound;
}

- (void)mouseEntered:(NSEvent *)event {
    // Get the current mouse position
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    
    // Calculate 10% of the window width
    CGFloat activationZone = self.bounds.size.width * 0.1;
    
    // Only mark user interaction when in the activation zone
    if (point.x <= activationZone) {
        [self markUserInteraction];
    } else {
        // When outside the activation zone, we don't want to show the menu
        // Do nothing, which will keep the menu hidden if it's already hidden
    }
}

// Helper method to get file extensions in the UI category
- (NSString *)fileExtensionFromUrl:(NSString *)urlString {
    if (!urlString || [urlString length] == 0) {
        return nil;
    }
    
    // Remove query parameters
    NSRange queryRange = [urlString rangeOfString:@"?"];
    if (queryRange.location != NSNotFound) {
        urlString = [urlString substringToIndex:queryRange.location];
    }
    
    // Check for file extension in the path
    NSString *extension = nil;
    NSRange lastDotRange = [urlString rangeOfString:@"." options:NSBackwardsSearch];
    
    if (lastDotRange.location != NSNotFound) {
        // Get everything after the last dot
        extension = [urlString substringFromIndex:lastDotRange.location];
        
        // Only consider it an extension if it's short and contains only valid chars
        // (This helps avoid false positives like domain names)
        if ([extension length] <= 5) {
            NSCharacterSet *validExtChars = [NSCharacterSet alphanumericCharacterSet];
            NSString *extensionChars = [extension substringFromIndex:1]; // Skip the dot
            
            // Check if all characters are valid for a file extension
            BOOL isValid = YES;
            for (NSUInteger i = 0; i < [extensionChars length]; i++) {
                unichar c = [extensionChars characterAtIndex:i];
                if (![validExtChars characterIsMember:c]) {
                    isValid = NO;
                    break;
                }
            }
            
            if (isValid) {
                return [extension uppercaseString];
            }
        }
    }
    
    return nil;
}

// Modify the markUserInteraction method to check if media is playing
- (void)markUserInteraction {
    // Call the new method with showMenu = NO by default
    [self markUserInteractionWithMenuShow:NO];
}

// New method that controls whether to show the menu
- (void)markUserInteractionWithMenuShow:(BOOL)shouldShowMenu {
    NSTimeInterval currentTime = [NSDate timeIntervalSinceReferenceDate];
    lastInteractionTime = currentTime;
    
    // Set the user interaction flag
    isUserInteracting = YES;
    
    // If not already scheduled, schedule the interaction check
    if (!autoHideTimer) {
        [self scheduleInteractionCheck];
    }
    
    // Check if fade-out is in progress - if so, cancel it
    extern BOOL isFadingOut;
    extern NSTimeInterval lastFadeOutTime;
    if (isFadingOut) {
        // Don't try to show menu during fade-out
        return;
    }
    
    // Check if we're within the fade-out cooldown period to prevent immediate fade-in after fade-out
    CGFloat fadeOutCooldown = 0.5; // Half-second cooldown to prevent immediate fade-in
    BOOL isInFadeOutCooldown = (currentTime - lastFadeOutTime < fadeOutCooldown);
    if (isInFadeOutCooldown) {
        // Don't show menu if we just faded out
        return;
    }
    
    // Only show menu if explicitly requested (like from activation zone)
    if (shouldShowMenu) {
        // Only show UI if we're not in the middle of playing a newly selected channel
        // We need a small delay after a channel is clicked before showing the UI again
        static NSTimeInterval lastChannelClickTime = 0;
        NSTimeInterval timeSinceLastChannelClick = currentTime - lastChannelClickTime;
        
        // If channel was clicked very recently (within 1 second), don't show UI yet
        BOOL wasRecentlyClicked = (timeSinceLastChannelClick < 1.0);
        
        // Add smooth but quick fade-in animation when showing the menu
        if (!self.isChannelListVisible && !wasRecentlyClicked) {
            // Start with zero alpha for fade-in
            [self setAlphaValue:0.0];
            
            // Mark as visible first so it will be drawn
            self.isChannelListVisible = YES;
            [self setNeedsDisplay:YES];
            
            // Perform quick fade-in animation
            [NSAnimationContext beginGrouping];
            [[NSAnimationContext currentContext] setDuration:0.3]; // Faster 0.3 second fade-in
            [[self animator] setAlphaValue:1.0];
            [NSAnimationContext endGrouping];
        }
        //self.player.cu
        // Update the last channel click time when we play a channel
        if (self.player && [self.player isPlaying] && !self.isChannelListVisible) {
            lastChannelClickTime = currentTime;
        }
    }
}


// Fade out the UI after 2 seconds of inactivity with a short fade
- (void)checkUserInteraction:(NSTimer*)timer {
    // Check if we're already in the process of fading out
    extern BOOL isFadingOut;
    extern NSTimeInterval lastFadeOutTime;
    
    if (isFadingOut) {
        // Don't interrupt an ongoing fade-out
        return;
    }
    
    NSTimeInterval currentTime = [NSDate timeIntervalSinceReferenceDate];
    CGFloat inactivityDuration = currentTime - lastInteractionTime;
    
    // Start fading out after 2 seconds of inactivity
    if (inactivityDuration > 2.0) {
        // Only proceed if the UI is visible
        if (self.isChannelListVisible) {
            // Hide all controls before hiding the menu
            [self hideControls];
            // Mark as not visible immediately to prevent race conditions
            self.isChannelListVisible = NO;
            
            // Set flag to prevent mouse movement from interrupting
            isFadingOut = YES;
            
            // Record when we started the fade-out
            lastFadeOutTime = currentTime;
            
            // Use a shorter fade time
            [NSAnimationContext beginGrouping];
            [[NSAnimationContext currentContext] setDuration:0.5]; // Quicker 0.5 second fade
            [[self animator] setAlphaValue:0.0];
            [NSAnimationContext endGrouping];
            
            // After animation completes, reset everything cleanly
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                // Reset the view alpha
                [self setAlphaValue:1.0];
                
                // Reset interaction flags to allow menu to be shown again
                isFadingOut = NO;
                isUserInteracting = NO;
                
                // Force redraw
                [self setNeedsDisplay:YES];
            });
        }
    }
}
// Improved simpleChannelIndexAtPoint method with exact boundary calculations
- (NSInteger)simpleChannelIndexAtPoint:(NSPoint)point {
    // Determine which region the mouse is in
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    // Calculate channelListWidth dynamically based on content type
    CGFloat programGuideWidth = 350; // Width reserved for program guide
    CGFloat channelListWidth;
    CGFloat movieInfoX;
    
    // Check if we're displaying movies in grid or stacked view (which should take full width)
    BOOL isMovieViewMode = (isGridViewActive || isStackedViewActive) && 
                          ((self.selectedCategoryIndex == CATEGORY_MOVIES) ||
                           (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]));
    
    if (isMovieViewMode) {
        // Movies in grid/stacked view take the full available space
        channelListWidth = self.bounds.size.width - catWidth - groupWidth;
        movieInfoX = self.bounds.size.width; // No movie info panel when in movie view modes
    } else {
        // Regular layout with program guide
        channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
        movieInfoX = catWidth + groupWidth + channelListWidth;
    }
    
    // Define exact boundaries for the channel list area
    CGFloat channelListStartX = catWidth + groupWidth;
    CGFloat channelListEndX = channelListStartX + channelListWidth;
    
    // Check if the mouse is actually within the channel list area
    if (point.x < channelListStartX || point.x >= channelListEndX) {
        return -1; // Mouse is outside channel list area
    }
    
    // Use the correct row height based on view mode
    CGFloat rowHeight = 40; // Default for regular list view
    
    // Check if we're in stacked view mode for movies
    if (isStackedViewActive && isMovieViewMode) {
        rowHeight = 400; // Default stacked view row height
        
        // Apply the same row height adjustment logic as in drawStackedView
        NSRect stackedRect = NSMakeRect(channelListStartX, 0, channelListWidth, self.bounds.size.height);
        NSInteger minVisibleRows = 4;
        CGFloat requiredHeight = minVisibleRows * rowHeight;
        if (stackedRect.size.height < requiredHeight) {
            rowHeight = MAX(80, stackedRect.size.height / minVisibleRows);
        }
    }
    
    if (isStackedViewActive) {
        // Use the exact positioning logic from drawStackedView for stacked view
        NSRect stackedRect = NSMakeRect(channelListStartX, 0, channelListWidth, self.bounds.size.height);
        
        // Get current movies count
        NSArray *moviesInCurrentGroup = [self getChannelsForCurrentGroup];
        if (!moviesInCurrentGroup || moviesInCurrentGroup.count == 0) {
            return -1;
        }
        
        // Apply the EXACT same scroll calculations as drawStackedView
        CGFloat totalContentHeight = moviesInCurrentGroup.count * rowHeight;
        totalContentHeight += rowHeight; // Add extra space at bottom
        
        CGFloat maxScroll = MAX(0, totalContentHeight - stackedRect.size.height);
        CGFloat scrollPosition = MIN(channelScrollPosition, maxScroll); // Apply same scroll limits
        
        // Check each movie position to find which one the mouse is over
        for (NSInteger i = 0; i < moviesInCurrentGroup.count; i++) {
            // Use the exact same calculation as drawStackedView
            CGFloat movieYPosition = stackedRect.size.height - ((i + 1) * rowHeight) + scrollPosition;
            
            NSRect itemRect = NSMakeRect(channelListStartX, 
                                         movieYPosition, 
                                         channelListWidth, 
                                         rowHeight);
            
            // Check if the mouse point is within this movie's rect
            if (NSPointInRect(point, itemRect)) {
                return i;
            }
        }
        
        return -1;
    } else {
      // Regular list view calculation - must match exactly how drawChannelList positions items
        
        // Get the appropriate scroll position (same logic as drawChannelList)
        CGFloat currentScrollPosition;
        if (self.selectedCategoryIndex == CATEGORY_SEARCH) {
            currentScrollPosition = self.searchChannelScrollPosition;
        } else {
            currentScrollPosition = channelScrollPosition;
        }
        
        // Get channel list dimensions (same as drawChannelList)
        CGFloat catWidth = 200;
        CGFloat groupWidth = 250;
        CGFloat channelListX = catWidth + groupWidth;
        CGFloat programGuideWidth = 400; // Same as drawChannelList
        CGFloat channelListWidth = self.bounds.size.width - channelListX - programGuideWidth;
        
        // Get current channels
        NSArray *channels = [self getChannelsForCurrentGroup];
        if (!channels || channels.count == 0) {
            return -1;
        }
        
        // Calculate total content height and max scroll (same as drawChannelList)
        CGFloat totalContentHeight = channels.count * rowHeight;
        totalContentHeight += rowHeight; // Add extra space at bottom
        CGFloat maxScroll = MAX(0, totalContentHeight - self.bounds.size.height);
        CGFloat scrollPosition = MAX(0, MIN(currentScrollPosition, maxScroll));
        
        // Check each channel's actual position (matching drawChannelList logic exactly)
        for (NSInteger i = 0; i < channels.count; i++) {
            // Calculate visible position accounting for scroll (same as drawChannelList)
            NSInteger visibleIndex = i - (NSInteger)floor(scrollPosition / rowHeight);
            
            // Skip items that are scrolled out of view
            if (visibleIndex < 0) {
                continue;
            }
            
            // Calculate item rect (same positioning as drawChannelList)
            NSRect itemRect = NSMakeRect(channelListX, 
                                       self.bounds.size.height - ((visibleIndex+1) * rowHeight), 
                                       channelListWidth, 
                                       rowHeight);
            
            // Check if mouse point is within this item's rect
            if (NSPointInRect(point, itemRect)) {
                return i;
            }
        }
    }
}

// Helper method to determine which grid item is at a given point
- (NSInteger)gridItemIndexAtPoint:(NSPoint)point {
    // Calculate grid area dimensions
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat gridX = catWidth + groupWidth;
    CGFloat gridWidth = self.bounds.size.width - gridX;
    
    // If point is outside grid area, return -1
    if (point.x < gridX) {
        return -1;
    }
    
    // Calculate grid metrics
    CGFloat itemPadding = 10;
    CGFloat itemWidth = MIN(180, (gridWidth / 2) - (itemPadding * 2));
    CGFloat itemHeight = itemWidth * 1.5;
    
    // Calculate columns
    NSInteger maxColumns = (NSInteger)((gridWidth - itemPadding) / (itemWidth + itemPadding));
    maxColumns = MAX(1, maxColumns);
    
    // Get channels
    NSArray *channels = [self getChannelsForCurrentGroup];
    if (!channels || channels.count == 0) {
        return -1;
    }
    
    // Calculate number of rows and total height
    NSInteger numRows = (NSInteger)ceilf((float)channels.count / (float)maxColumns);
    CGFloat totalGridHeight = numRows * (itemHeight + itemPadding) + itemPadding;
    
    // Calculate scroll offset
    CGFloat scrollOffset = MAX(0, MIN(channelScrollPosition, totalGridHeight - self.bounds.size.height));
    
    // Calculate grid item positions and check if point is inside any of them
    for (NSInteger i = 0; i < channels.count; i++) {
        NSInteger row = i / maxColumns;
        NSInteger col = i % maxColumns;
        
        // Calculate position with centering
        CGFloat totalGridWidth = maxColumns * (itemWidth + itemPadding) + itemPadding;
        CGFloat leftMargin = gridX + (gridWidth - totalGridWidth) / 2;
        
        CGFloat x = leftMargin + itemPadding + col * (itemWidth + itemPadding);
        CGFloat y = self.bounds.size.height - 60 - itemHeight - (row * (itemHeight + itemPadding)) + scrollOffset;
        
        // Create rect for this grid item
        NSRect itemRect = NSMakeRect(x, y, itemWidth, itemHeight);
        
        // Check if point is inside this rect
            if (NSPointInRect(point, itemRect)) {
                return i;
            }
        }
        
        return -1;
    }

// Add back the helper method to get the channel at the hovered index
- (VLCChannel *)getChannelAtHoveredIndex {
    if (self.hoveredChannelIndex < 0 || self.selectedCategoryIndex < 0 || self.selectedGroupIndex < 0) {
        return nil;
    }
    
    // Get the appropriate groups based on category
    NSArray *groups = nil;
    NSString *currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
    
    if ([currentCategory isEqualToString:@"FAVORITES"]) {
        groups = [self safeGroupsForCategory:@"FAVORITES"];
    } else if ([currentCategory isEqualToString:@"TV"]) {
        groups = [self safeTVGroups];
    } else if ([currentCategory isEqualToString:@"MOVIES"]) {
        groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
    } else if ([currentCategory isEqualToString:@"SERIES"]) {
        groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
    } else if ([currentCategory isEqualToString:@"SETTINGS"]) {
        groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    }
    
    // Get the current group
    if (groups && self.selectedGroupIndex < groups.count) {
        NSString *currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
        
        // Get channels for this group
        NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
        if (channelsInGroup && self.hoveredChannelIndex < channelsInGroup.count) {
            return [channelsInGroup objectAtIndex:self.hoveredChannelIndex];
        }
    }
    
    return nil;
}

// Add a new method for asynchronous image loading
- (void)loadImageAsynchronously:(NSString *)imageUrl forChannel:(VLCChannel *)channel {
    // Thorough validation to prevent empty URL errors
    if (!imageUrl || !channel || [imageUrl length] == 0 || 
        [imageUrl isEqualToString:@"(null)"] || [imageUrl isEqualToString:@"null"]) {
        //NSLog(@"Cannot load image: Invalid or empty URL or channel");
        // Clear loading flag to prevent hanging state
        if (channel) {
            objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        }
        return;
    }
    
    // Don't reload if we already have a cached image
    if (channel.cachedPosterImage) {
        NSLog(@"Image already cached for channel: %@", channel.name);
        return;
    }
    
    // We use a separate property to track image loading
    if (objc_getAssociatedObject(channel, "imageLoadingInProgress")) {
        NSLog(@"Image loading already in progress for channel: %@", channel.name);
        return;
    }
    
    // Mark that we're starting image loading using associated objects
    objc_setAssociatedObject(channel, "imageLoadingInProgress", @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
    // Try to load from disk cache first
    [self loadCachedPosterImageForChannel:channel];
    
    // If successfully loaded from disk cache, return early
    if (channel.cachedPosterImage) {
        //NSLog(@"Using image from disk cache for channel: %@", channel.name);
        
        // Trigger redraw
        [self setNeedsDisplay:YES];
        return;
    }
    
    // Additional validation for URL string format
    if (![imageUrl hasPrefix:@"http://"] && ![imageUrl hasPrefix:@"https://"]) {
        NSLog(@"URL doesn't have http/https prefix, adding http://: %@", imageUrl);
        imageUrl = [@"http://" stringByAppendingString:imageUrl];
    }
    
    NSLog(@"Starting image download for channel: %@ from URL: %@", channel.name, imageUrl);
    
    // Create URL object with validation
    NSURL *url = [NSURL URLWithString:imageUrl];
    if (!url) {
        NSLog(@"Invalid image URL format: %@", imageUrl);
        // Clear loading state
        objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        return;
    }
    
    // Final URL validation to prevent empty host issues
    if (!url.host || [url.host length] == 0) {
        NSLog(@"URL has no valid host: %@", imageUrl);
        // Clear loading state
        objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        return;
    }
    
    // Create and start asynchronous download task with extra error handling
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLRequest *request = [NSURLRequest requestWithURL:url 
                                           cachePolicy:NSURLRequestUseProtocolCachePolicy 
                                       timeoutInterval:15.0];
    
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request 
                                           completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        // Handle errors
        if (error) {
            NSLog(@"Error loading image data for channel %@: %@", channel.name, [error localizedDescription]);
            
            // Clear the loading flag on error
        dispatch_async(dispatch_get_main_queue(), ^{
                objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            });
            return;
        }
        
        // Check HTTP status
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        if (httpResponse.statusCode != 200) {
            NSLog(@"HTTP error loading image for channel %@: %ld", channel.name, (long)httpResponse.statusCode);
            
            // Clear the loading flag on HTTP error
            dispatch_async(dispatch_get_main_queue(), ^{
                objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            });
            return;
        }
        
        // Process the image on the main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            // Create image from data
            NSImage *downloadedImage = [[NSImage alloc] initWithData:data];
            if (!downloadedImage) {
                NSLog(@"Failed to create image from downloaded data for channel: %@", channel.name);
                
                // Clear loading flag even on failure
                objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
                return;
            }
            
            // Cache the image in the channel
            channel.cachedPosterImage = downloadedImage;
            
            // Also save to disk cache for persistence across app restarts
            [self savePosterImageToDiskCache:downloadedImage forURL:imageUrl];
            
            [downloadedImage release]; // release local reference, channel will retain it
            
            // Clear the loading flag
            objc_setAssociatedObject(channel, "imageLoadingInProgress", nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            
            // Trigger a redraw
            [self setNeedsDisplay:YES];
            
            NSLog(@"Successfully downloaded and cached image for channel: %@", channel.name);
        });
    }];
    
    [task resume];
}

int cnt=0;
// Now modify the drawRect method to conditionally use grid view
- (void)drawRect:(NSRect)dirtyRect {
    // Original existing implementation...
    // This is where the view is drawn
   // NSLog(@"drawRect called %d- playerControlsVisible: %@, menu: %@",cnt++,
   //      playerControlsVisible ? @"YES" : @"NO",
   //        self.isChannelListVisible ? @"visible" : @"hidden");
    // Clear the background
    [self.backgroundColor set];
    //NSRectFill(dirtyRect);
    
    // Draw the channel list if it's visible
    if (self.isChannelListVisible) {
        // Draw the components
        [self drawCategories:dirtyRect];
        [self drawGroups:dirtyRect];
        
        // Adjust based on selected category
        if (self.selectedCategoryIndex == CATEGORY_SETTINGS) {
            [self drawSettingsPanel:dirtyRect];
        } else if (self.showEpgPanel) {
            [self drawEpgPanel:dirtyRect];
        } else {
            // For content categories, either draw grid or channel list
            if (isGridViewActive && ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                                   (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]))) {
                [self drawGridView:dirtyRect];
                
                // When movies become visible in grid view, check cache and fetch missing info
                [self validateMovieInfoForVisibleItems];
            } else if (isStackedViewActive && ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                                             (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]))) {
                [self drawStackedView:dirtyRect];
                
                // When movies become visible in stacked view, check cache and fetch missing info
                [self validateMovieInfoForVisibleItems];
            } else {
                [self drawChannelList:dirtyRect];
                
                // Also check for visible movies in list view if current group contains movies
                if ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                    (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels])) {
                    [self validateMovieInfoForVisibleItems];
                }
                
                // REMOVED: No longer bulk process ranges of channels - only visible movies handled above
                // All movie info fetching is now handled by validateMovieInfoForVisibleItems method
            }
        }
    }
    
    // Draw loading indicator if needed
    if (self.isLoading) {
        [self drawLoadingIndicator:dirtyRect];
    }
    
    // Draw URL input field if active
    if (self.isTextFieldActive) {
        [self drawURLInputField:dirtyRect];
    }
    
    // Draw the player controls if player exists and is playing
    if (/*self.player &&*/ playerControlsVisible) {
        [self drawPlayerControls:dirtyRect];
    }
    [self drawDropdowns:dirtyRect];
}

// Add method to show/hide player controls
- (void)togglePlayerControls {
    playerControlsVisible = !playerControlsVisible;
    [self setNeedsDisplay:YES];
    
    // Reset timer when toggling
    if (playerControlsTimer) {
        [playerControlsTimer invalidate];
        playerControlsTimer = nil;
    }
    
    // Set a timer to auto-hide the controls
    if (playerControlsVisible) {
        playerControlsTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
                                                            target:self
                                                         selector:@selector(hidePlayerControls:)
                                                          userInfo:nil
                                                          repeats:NO];
    }
}
/*
- (void)hidePlayerControls:(NSTimer *)timer {
    playerControlsVisible = NO;
    [self setNeedsDisplay:YES];
    playerControlsTimer = nil;
}
*/
// Add a helper method to get the channel at a specific index
- (VLCChannel *)getChannelAtIndex:(NSInteger)index {
    if (index < 0 || self.selectedCategoryIndex < 0 || self.selectedGroupIndex < 0) {
        return nil;
    }
    
    // Get the appropriate groups based on category
    NSArray *groups = nil;
    NSString *currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
    
    if ([currentCategory isEqualToString:@"FAVORITES"]) {
        groups = [self safeGroupsForCategory:@"FAVORITES"];
    } else if ([currentCategory isEqualToString:@"TV"]) {
        groups = [self safeTVGroups];
    } else if ([currentCategory isEqualToString:@"MOVIES"]) {
        groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
    } else if ([currentCategory isEqualToString:@"SERIES"]) {
        groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
    }
    
    // Get the current group
    if (groups && self.selectedGroupIndex < groups.count) {
        NSString *currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
        
        // Get channels for this group
        NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
        if (channelsInGroup && index < channelsInGroup.count) {
            return [channelsInGroup objectAtIndex:index];
        }
    }
    
    return nil;
}

// Add a new method to draw the grid view
- (void)drawGridView:(NSRect)dirtyRect {
    // Calculate dimensions for grid area (only in the channel/info space)
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat gridX = catWidth + groupWidth; // Start after categories and groups
    CGFloat gridWidth = self.bounds.size.width - gridX;
    
    // Draw background for grid area using theme colors
    NSRect gridBackground = NSMakeRect(gridX, 0, gridWidth, self.bounds.size.height);
    
    // Use theme colors for grid background (consistent with other panels)
    NSColor *gridStartColor, *gridEndColor;
    if (self.themeChannelStartColor && self.themeChannelEndColor) {
        // Use theme colors with proper alpha adjustment
        CGFloat gridAlpha = self.themeAlpha * 0.85;
        gridStartColor = [self.themeChannelStartColor colorWithAlphaComponent:gridAlpha];
        gridEndColor = [self.themeChannelEndColor colorWithAlphaComponent:gridAlpha];
    } else {
        // Fallback colors consistent with theme system defaults
        gridStartColor = [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.7];
        gridEndColor = [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.7];
    }
    
    NSGradient *gridGradient = [[NSGradient alloc] initWithStartingColor:gridStartColor endingColor:gridEndColor];
    [gridGradient drawInRect:gridBackground angle:90];
    [gridGradient release];
    
    // Define the content area (accounts for header space)
    NSRect contentRect = NSMakeRect(gridX, 0, gridWidth, self.bounds.size.height - 40);
    
    // Get the current group's channels
    NSArray *channelsToShow = [self getChannelsForCurrentGroup];
    
    if (!channelsToShow || channelsToShow.count == 0) {
        // If no channels, draw a message
        NSString *message = @"No channels to display in grid view";
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:16],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        NSRect messageRect = NSMakeRect(gridX, self.bounds.size.height/2 - 10, gridWidth, 20);
        [message drawInRect:messageRect withAttributes:attrs];
        [style release];
        return;
    }
    
    // Calculate grid metrics - adapted for the narrower space
    CGFloat itemPadding = 10;
    CGFloat itemWidth = MIN(180, (gridWidth / 2) - (itemPadding * 2)); // Adjust size to fit at least 2 columns
    CGFloat itemHeight = itemWidth * 1.5; // Keep reasonable aspect ratio
    
    // Calculate how many columns fit in the available width
    NSInteger maxColumns = (NSInteger)((gridWidth - itemPadding) / (itemWidth + itemPadding));
    maxColumns = MAX(1, maxColumns); // At least 1 column
    
    // Calculate row spacing based on available height
    NSInteger numRows = (NSInteger)ceilf((float)channelsToShow.count / (float)maxColumns);
    CGFloat totalGridHeight = numRows * (itemHeight + itemPadding) + itemPadding;
    
    // Add extra space at the bottom to ensure last row is fully visible when scrolled to the end
    totalGridHeight += itemHeight;
    
    // Calculate vertical offset for scrolling with improved limits
    CGFloat maxScroll = MAX(0, totalGridHeight - contentRect.size.height);
    CGFloat scrollOffset = MAX(0, MIN(channelScrollPosition, maxScroll));
    
    // Draw a header showing the current category and group
    //NSString *headerText = @"Grid View";
    //NSString *currentGroup = [self getCurrentGroupName];
   // if (currentGroup) {
   //     headerText = [NSString stringWithFormat:@"Grid View: %@", currentGroup];
   // }
    /*
    NSMutableParagraphStyle *headerStyle = [[NSMutableParagraphStyle alloc] init];
    [headerStyle setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *headerAttrs = @{
        NSFontAttributeName: [NSFont fontWithName:@"HelveticaNeue-Light" size:16] ?: [NSFont systemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: headerStyle
    };
    
    //NSRect headerRect = NSMakeRect(gridX, self.bounds.size.height - 40, gridWidth, 40);
    //[headerText drawInRect:headerRect withAttributes:headerAttrs];
    //[headerStyle release];
    */
    // Draw info text
    NSMutableParagraphStyle *infoStyle = [[NSMutableParagraphStyle alloc] init];
    [infoStyle setAlignment:NSTextAlignmentRight];
    
    NSDictionary *infoAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor lightGrayColor],
        NSParagraphStyleAttributeName: infoStyle
    };
    
    NSString *infoText = @"Press 'V' to change view mode";
    NSRect infoRect = NSMakeRect(self.bounds.size.width/2 + 70, self.bounds.size.height - 20, 240, 20);
    [infoText drawInRect:infoRect withAttributes:infoAttrs];
    [infoStyle release];
    
    // Draw each channel as a grid item
    for (NSInteger i = 0; i < channelsToShow.count; i++) {
        NSInteger row = i / maxColumns;
        NSInteger col = i % maxColumns;
        
        // Calculate position (centered in available width)
        CGFloat totalGridWidth = maxColumns * (itemWidth + itemPadding) + itemPadding;
        CGFloat leftMargin = gridX + (gridWidth - totalGridWidth) / 2;
        
        CGFloat x = leftMargin + itemPadding + col * (itemWidth + itemPadding);
        CGFloat y = self.bounds.size.height - 60 - itemHeight - (row * (itemHeight + itemPadding)) + scrollOffset;
        
        // Skip if not visible
        if (y + itemHeight < 0 || y > self.bounds.size.height) {
            continue;
        }
        
        // Get the channel and ensure cached image is loaded for immediate display
        VLCChannel *channel = [channelsToShow objectAtIndex:i];
        
        // For grid view, immediately try to load cached poster image if not already loaded
        // This ensures cached images display immediately when grid view is shown
        if ([channel.category isEqualToString:@"MOVIES"] && !channel.cachedPosterImage) {
            [self loadCachedPosterImageForChannel:channel];
        }
        
        [self drawGridItem:channel atRect:NSMakeRect(x, y, itemWidth, itemHeight) highlight:(i == self.hoveredChannelIndex)];
        
        // REMOVED: Don't automatically download for each grid item - handled by validateMovieInfoForVisibleItems
        // [self queueAsyncLoadForGridChannel:channel atIndex:i];
    }
    
    // Draw the scroll bar
    [self drawScrollBar:contentRect contentHeight:totalGridHeight scrollPosition:scrollOffset];
}

// Helper method to draw a single grid item
- (void)drawGridItem:(VLCChannel *)channel atRect:(NSRect)itemRect highlight:(BOOL)highlight {
    // Draw background
    NSRect bgRect = NSInsetRect(itemRect, 1, 1);
    if (highlight) {
        [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.3] set];
    } else {
        [[NSColor colorWithCalibratedRed:0.15 green:0.15 blue:0.15 alpha:1.0] set];
    }
    
    // Use rounded rect for better appearance
    NSBezierPath *bgPath = [NSBezierPath bezierPathWithRoundedRect:bgRect xRadius:5 yRadius:5];
    [bgPath fill];
    
    // Draw border
    [[NSColor colorWithCalibratedWhite:0.4 alpha:1.0] set];
    [bgPath setLineWidth:1.0];
    [bgPath stroke];
    
    // Calculate poster area (top part of the item)
    CGFloat posterHeight = itemRect.size.height * 0.8;
    NSRect posterRect = NSMakeRect(
        itemRect.origin.x + 5,
        itemRect.origin.y + (itemRect.size.height - posterHeight - 5),
        itemRect.size.width - 10,
        posterHeight - 5
    );
    
    // For TV channels, use a white background with rounded corners to make logos look better
    if ([channel.category isEqualToString:@"TV"]) {
        // Create a rounded rect path for the white background
        NSBezierPath *bgPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:5 yRadius:5];
        [[NSColor whiteColor] set];
        [bgPath fill];
        
        // Add a subtle border
        [[NSColor colorWithWhite:0.9 alpha:1.0] set];
        [bgPath setLineWidth:1.0];
        [bgPath stroke];
    }
    
    // Draw poster if available
    NSImage *posterImage = channel.cachedPosterImage;
    
    if (posterImage) {
        // Calculate the image size to maintain aspect ratio
        NSSize imageSize = [posterImage size];
        
        // Use square aspect ratio for TV channel logos
        if ([channel.category isEqualToString:@"TV"]) {
            // For TV logos, we use a completely different approach for best results
            // Create a square area in the center of the poster with plenty of padding
            CGFloat maxDimension = MIN(posterRect.size.width, posterRect.size.height);
            CGFloat squareSize = maxDimension * 0.70; // Reduced from 75% to 70% for more padding
            
            // Center the square in the poster area
            CGFloat xOffset = (posterRect.size.width - squareSize) / 2;
            CGFloat yOffset = (posterRect.size.height - squareSize) / 2;
            
            NSRect logoRect = NSMakeRect(
                posterRect.origin.x + xOffset,
                posterRect.origin.y + yOffset,
                squareSize,
                squareSize
            );
            
            // Scale the logo to fit in the square while preserving aspect ratio
            CGFloat aspectRatio = imageSize.width / MAX(1.0, imageSize.height);
            NSRect drawRect;
            
            if (aspectRatio > 1.0) {
                // Wider logo - constrain to width
                CGFloat scaledHeight = squareSize / aspectRatio;
                CGFloat innerYOffset = (squareSize - scaledHeight) / 2;
                drawRect = NSMakeRect(
                    logoRect.origin.x,
                    logoRect.origin.y + innerYOffset,
                    squareSize,
                    scaledHeight
                );
            } else {
                // Taller logo - constrain to height
                CGFloat scaledWidth = squareSize * aspectRatio;
                CGFloat innerXOffset = (squareSize - scaledWidth) / 2;
                drawRect = NSMakeRect(
                    logoRect.origin.x + innerXOffset,
                    logoRect.origin.y,
                    scaledWidth,
                    squareSize
                );
            }
            
            // Use NSBezierPath for rounded corners in grid view - TV logos
            // Save graphics state before clipping
            [NSGraphicsContext saveGraphicsState];
            NSBezierPath *clipPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:5 yRadius:5];
            [clipPath setClip];
            [posterImage drawInRect:drawRect fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0];
            // Restore graphics state instead of resetting clip on the path
            [NSGraphicsContext restoreGraphicsState];
        } else {
            // For movies and other content, use standard movie poster ratio
            CGFloat aspectRatio = imageSize.width / MAX(1.0, imageSize.height);
            
            // Create a slightly smaller rectangle with padding
            CGFloat padding = 6.0;
            NSRect innerRect = NSInsetRect(posterRect, padding, padding);
            
            NSRect drawRect;
            if (aspectRatio > (innerRect.size.width / innerRect.size.height)) {
                // Image is wider than the target area
                CGFloat scaledHeight = innerRect.size.width / aspectRatio;
                CGFloat yOffset = (innerRect.size.height - scaledHeight) / 2;
                drawRect = NSMakeRect(innerRect.origin.x, innerRect.origin.y + yOffset, innerRect.size.width, scaledHeight);
            } else {
                // Image is taller than the target area
                CGFloat scaledWidth = innerRect.size.height * aspectRatio;
                CGFloat xOffset = (innerRect.size.width - scaledWidth) / 2;
                drawRect = NSMakeRect(innerRect.origin.x + xOffset, innerRect.origin.y, scaledWidth, innerRect.size.height);
            }
            
            // Use NSBezierPath for rounded corners in grid view - movie posters
            // Save graphics state before clipping
            [NSGraphicsContext saveGraphicsState];
            NSBezierPath *clipPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:5 yRadius:5];
            [clipPath setClip];
            [posterImage drawInRect:drawRect fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0];
            // Restore graphics state instead of resetting clip on the path
            [NSGraphicsContext restoreGraphicsState];
        }
    } else {
        // Draw placeholder if no image - with rounded corners to match the grid item style
        NSBezierPath *placeholderPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:5 yRadius:5];
        [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0] set];
        [placeholderPath fill];
        
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        if (channel.hasStartedFetchingMovieInfo && !channel.hasLoadedMovieInfo) {
            // If loading, show a loading message
            NSDictionary *loadingAttrs = @{
                NSFontAttributeName: [NSFont systemFontOfSize:12],
                NSForegroundColorAttributeName: [NSColor lightGrayColor],
                NSParagraphStyleAttributeName: style
            };
            
            NSString *loadingText = @"Loading...";
            [loadingText drawInRect:NSInsetRect(posterRect, 10, posterRect.size.height/2 - 10) withAttributes:loadingAttrs];
        } else {
            // Show empty background with no text
            
            // Try to load the image if available and not already loading (similar to stacked view)
            if (channel.logo && !objc_getAssociatedObject(channel, "imageLoadingInProgress")) {
                [self loadImageAsynchronously:channel.logo forChannel:channel];
            }
        }
        
        [style release];
    }
    
    // Draw title at the bottom
    NSRect titleRect = NSMakeRect(
        itemRect.origin.x + 5,
        itemRect.origin.y + 5,
        itemRect.size.width - 10,
        itemRect.size.height * 0.2 - 10
    );
    
    NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
    [titleStyle setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:12],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: titleStyle
    };
    
    // Truncate title if needed
    NSString *title = channel.name;
    if (title.length > 40) {
        title = [[title substringToIndex:37] stringByAppendingString:@"..."];
    }
    
    [title drawInRect:titleRect withAttributes:titleAttrs];
    [titleStyle release];
    
    // If movie has metadata, draw a small info badge
    if (channel.hasLoadedMovieInfo && (channel.movieYear || channel.movieRating)) {
        NSString *infoText = @"";
        if (channel.movieYear) {
            infoText = channel.movieYear;
        }
        if (channel.movieRating && [channel.movieRating floatValue] > 0) {
            if (infoText.length > 0) {
                infoText = [infoText stringByAppendingFormat:@" ‚Ä¢ %@‚òÖ", channel.movieRating];
            } else {
                infoText = [NSString stringWithFormat:@"%@‚òÖ", channel.movieRating];
            }
        }
        
        if (infoText.length > 0) {
            NSRect infoRect = NSMakeRect(
                itemRect.origin.x + 10,
                itemRect.origin.y + itemRect.size.height - 20,
                itemRect.size.width - 20,
                15
            );
            
            NSDictionary *infoAttrs = @{
                NSFontAttributeName: [NSFont boldSystemFontOfSize:10],
                NSForegroundColorAttributeName: [NSColor yellowColor],
                NSParagraphStyleAttributeName: titleStyle
            };
            
            [infoText drawInRect:infoRect withAttributes:infoAttrs];
        }
    }
}

// Helper method to get all channels for the current group
- (NSArray *)getChannelsForCurrentGroup {
    // Get current category and group
    NSString *currentCategory = nil;
    NSString *currentGroup = nil;
    NSArray *groups = nil;
    
    if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
        currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
        
        // Get the appropriate groups based on category
        if ([currentCategory isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([currentCategory isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([currentCategory isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SETTINGS"]) {
            groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        }
        
        // Get the current group
        if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
            currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
            
            // Get channels for this group
            return [self.channelsByGroup objectForKey:currentGroup];
        }
    }
    
    return nil;
}

// Helper method to get current group name
- (NSString *)getCurrentGroupName {
    // Get current category and group
    NSString *currentCategory = nil;
    NSArray *groups = nil;
    
    if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
        currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
        
        // Get the appropriate groups based on category
        if ([currentCategory isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([currentCategory isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([currentCategory isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SETTINGS"]) {
            groups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        }
        
        // Get the current group
        if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
            return [groups objectAtIndex:self.selectedGroupIndex];
        }
    }
    
    return nil;
}

// Helper method to check if the current group contains movie channels
- (BOOL)currentGroupContainsMovieChannels {
    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
    if (!channelsInCurrentGroup || channelsInCurrentGroup.count == 0) {
    return NO;
}

    // Check if any channel in the current group is a movie channel
    for (VLCChannel *channel in channelsInCurrentGroup) {
        if ([channel.category isEqualToString:@"MOVIES"]) {
            return YES;
        }
    }
    
        return NO;
    }
    
// Helper method to check if a group has channels with catch-up functionality
- (BOOL)groupHasCatchupChannels:(NSString *)groupName {
    if (!groupName) return NO;
    
    NSArray *channelsInGroup = [self.channelsByGroup objectForKey:groupName];
    if (!channelsInGroup) return NO;
    
    for (VLCChannel *channel in channelsInGroup) {
        // Check both EPG-based catch-up and channel-level catch-up
        if (channel.supportsCatchup) {
            return YES; // Channel-level catch-up support
        }
        
        if (channel.programs && channel.programs.count > 0) {
            for (VLCProgram *program in channel.programs) {
                if (program.hasArchive) {
                    return YES; // EPG-based catch-up support
                }
            }
        }
    }
    
    return NO;
}

// Optimized method to validate and refresh movie info for visible items with better performance
- (void)validateMovieInfoForVisibleItems {
    // Cancel any pending validation calls using NSObject's built-in delayed execution
    // This is much safer than managing timers manually and prevents crashes
    [NSObject cancelPreviousPerformRequestsWithTarget:self 
                                             selector:@selector(performValidateMovieInfoForVisibleItems) 
                                               object:nil];
    // Schedule new validation with 0.1 second delay to debounce rapid calls
    [self performSelector:@selector(performValidateMovieInfoForVisibleItems) 
               withObject:nil 
               afterDelay:0.1];
}

// Actual validation method that runs optimized in background
- (void)performValidateMovieInfoForVisibleItems {
    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
    if (!channelsInCurrentGroup || channelsInCurrentGroup.count == 0) {
        return;
    }
    
    // Calculate visible range based on current view mode (lightweight operation)
    NSRange visibleRange = [self calculateVisibleChannelRange];
    
    // Validate visible range
    if (visibleRange.location >= channelsInCurrentGroup.count || visibleRange.length == 0) {
        return;
    }
    
    // Create array of visible movie channels for background processing
    NSMutableArray *visibleMovieChannels = [NSMutableArray array];
    NSInteger visibleStart = (NSInteger)visibleRange.location;
    NSInteger visibleEnd = visibleStart + (NSInteger)visibleRange.length - 1;
    
    // Add buffer margin: load 3 items before they become visible for smoother scrolling
    NSInteger bufferSize = 3;
    NSInteger originalStart = visibleStart;
    NSInteger originalEnd = visibleEnd;
    
    // Expand range with buffer (with proper bounds checking)
    visibleStart = MAX(0, visibleStart - bufferSize);
    visibleEnd = MIN((NSInteger)channelsInCurrentGroup.count - 1, visibleEnd + bufferSize);
    
    //NSLog(@"üéØ Loading buffer: visible %ld-%ld expanded to %ld-%ld (+/-%ld buffer)", 
    //      (long)originalStart, (long)originalEnd, (long)visibleStart, (long)visibleEnd, (long)bufferSize);
    
    for (NSInteger i = visibleStart; i <= visibleEnd && i < channelsInCurrentGroup.count; i++) {
        VLCChannel *channel = [channelsInCurrentGroup objectAtIndex:i];
        if ([channel.category isEqualToString:@"MOVIES"]) {
            [visibleMovieChannels addObject:channel];
        }
    }
    
    if (visibleMovieChannels.count == 0) {
        return;
    }
    
    // Process all validation and cache loading in background thread
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSMutableArray *channelsNeedingFetch = [NSMutableArray array];
        NSMutableArray *channelsLoadedFromCache = [NSMutableArray array];
        
        // Process each visible movie channel in background
        for (VLCChannel *channel in visibleMovieChannels) {
            @autoreleasepool {
                // Skip if already fetching
                if (channel.hasStartedFetchingMovieInfo) {
                    continue;
                }
                
                // Quick check for movie info completeness (in memory)
                BOOL needsRefresh = NO;
                
                if (!channel.hasLoadedMovieInfo) {
                    needsRefresh = YES;
                } else {
                    // Check if the loaded info is actually useful (all in memory - fast)
                    BOOL hasDescription = channel.movieDescription && [channel.movieDescription length] > 0;
                    BOOL hasYear = channel.movieYear && [channel.movieYear length] > 0;
                    BOOL hasGenre = channel.movieGenre && [channel.movieGenre length] > 0;
                    BOOL hasDirector = channel.movieDirector && [channel.movieDirector length] > 0;
                    BOOL hasRating = channel.movieRating && [channel.movieRating length] > 0;
                    BOOL hasDuration = channel.movieDuration && [channel.movieDuration length] > 0;
                    
                    // If we're missing critical info, refresh
                    if (!hasDescription || (!hasYear && !hasGenre && !hasDirector && !hasRating && !hasDuration)) {
                        needsRefresh = YES;
                        // Reset the flag so fetchMovieInfoForChannel won't skip it
                        channel.hasLoadedMovieInfo = NO;
                    }
                }
                
                if (needsRefresh) {
                    // Try to load from cache (disk I/O in background thread)
                    BOOL loadedFromCache = [self loadMovieInfoFromCacheForChannel:channel];
                    
                    if (loadedFromCache) {
                        [channelsLoadedFromCache addObject:channel];
                    } else {
                        [channelsNeedingFetch addObject:channel];
                    }
                }
            }
        }
        
        // Update UI and start fetches on main thread (batch updates for better performance)
        dispatch_async(dispatch_get_main_queue(), ^{
            // Limit to maximum 10 simultaneous downloads to prevent system overload
            NSInteger maxSimultaneousDownloads = 10;
            NSInteger downloadsStarted = 0;
            
            // Batch mark channels as fetching and start downloads (limited)
            for (VLCChannel *channel in channelsNeedingFetch) {
                if (!channel.hasStartedFetchingMovieInfo && downloadsStarted < maxSimultaneousDownloads) {
                    channel.hasStartedFetchingMovieInfo = YES;
                    downloadsStarted++;
                    
                    // Start async fetch in background
                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
                        [self fetchMovieInfoForChannelAsync:channel];
                    });
                }
            }
            
            // Log results if any work was done
            if (channelsLoadedFromCache.count > 0) {
                NSLog(@"üìã Loaded %ld movies from cache", (long)channelsLoadedFromCache.count);
                // Use throttled update instead of immediate redraw for better performance
                [self throttledDisplayUpdate];
            }
            
            if (downloadsStarted > 0) {
                NSLog(@"üîÑ Started fetching %ld movies (limited to 10 max)", (long)downloadsStarted);
            }
        });
    });
}

// Timer to control scroll bar visibility
NSTimer *scrollBarFadeTimer = nil;
float scrollBarAlpha = 0.0; // Used to control scroll bar opacity

// Add a new method to draw a scroll bar
- (void)drawScrollBar:(NSRect)contentRect contentHeight:(CGFloat)contentHeight scrollPosition:(CGFloat)scrollPosition {
    // Only draw if content is taller than the visible area
    if (contentHeight <= contentRect.size.height) {
        return;
    }
    
    // Only show scroll bar when scrolling or briefly after
    if (scrollBarAlpha <= 0.01) {
        return;
    }
    
    // Calculate scroll bar metrics - make slightly wider for better visibility
    CGFloat scrollBarWidth = 6.0; 
    CGFloat scrollBarMargin = 2.0;
    CGFloat scrollBarHeight = contentRect.size.height;
    
    // Position the scroll bar on the right side of the content area
    NSRect scrollBarRect = NSMakeRect(
        contentRect.origin.x + contentRect.size.width - scrollBarWidth - scrollBarMargin,
        contentRect.origin.y,
        scrollBarWidth,
        scrollBarHeight
    );
    
    // Skip drawing background - only draw the thumb with no background
    
    // Calculate thumb size and position
    CGFloat visibleRatio = contentRect.size.height / contentHeight;
    CGFloat thumbHeight = MAX(20, scrollBarHeight * visibleRatio); // Minimum thumb size
    
    // Calculate scroll position as a ratio of the total scrollable distance
    CGFloat maxScroll = contentHeight - contentRect.size.height;
    CGFloat scrollRatio = (maxScroll > 0) ? scrollPosition / maxScroll : 0;
    
    // Calculate thumb position - invert for correct direction
    CGFloat thumbY = scrollBarRect.origin.y + (scrollBarHeight - thumbHeight) * (1.0 - scrollRatio);
    
    // Draw the thumb without background
    NSRect thumbRect = NSMakeRect(
        scrollBarRect.origin.x,
        thumbY,
        scrollBarWidth,
        thumbHeight
    );
    
    // Use a more visible thumb with slightly darker color
    [[NSColor colorWithCalibratedWhite:0.6 alpha:scrollBarAlpha * 0.9] set];
    NSBezierPath *thumbPath = [NSBezierPath bezierPathWithRoundedRect:thumbRect xRadius:3 yRadius:3];
    [thumbPath fill];
}

// Add a new method to fade out scroll bars
- (void)fadeScrollBars:(NSTimer *)timer {
    // Reduce alpha gradually
    scrollBarAlpha -= 0.1;
    
    // If fully transparent, stop the timer
    if (scrollBarAlpha <= 0) {
        scrollBarAlpha = 0;
        [scrollBarFadeTimer invalidate];
        scrollBarFadeTimer = nil;
    }
    
    // Trigger redraw to update scroll bar appearance
        [self setNeedsDisplay:YES];
}

// Add a new method to draw Movie Info settings
- (void)drawMovieInfoSettings:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = self.bounds.size.height - 100;
    CGFloat buttonHeight = 40;
    CGFloat buttonWidth = 260;
    
    // Draw a section title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, width - (padding * 2), 20);
    [@"Movie Information Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Draw descriptive text
    NSRect descRect = NSMakeRect(x + padding, startY - 30, width - (padding * 2), 20);
    NSDictionary *descAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    [@"Manage movie information and poster images" drawInRect:descRect withAttributes:descAttrs];
    
    // Get the current cache directory info
    NSString *cacheDir = [self getCacheDirectoryPath];
    NSString *movieInfoCacheDir = [cacheDir stringByAppendingPathComponent:@"MovieInfo"];
    NSString *posterCacheDir = [cacheDir stringByAppendingPathComponent:@"Posters"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // Count files in cache directories
    NSInteger movieInfoCount = 0;
    NSInteger posterCount = 0;
    NSError *error = nil;
    
    if ([fileManager fileExistsAtPath:movieInfoCacheDir]) {
        NSArray *files = [fileManager contentsOfDirectoryAtPath:movieInfoCacheDir error:&error];
        if (!error) {
            movieInfoCount = files.count;
        }
    }
    
    if ([fileManager fileExistsAtPath:posterCacheDir]) {
        NSArray *files = [fileManager contentsOfDirectoryAtPath:posterCacheDir error:&error];
        if (!error) {
            posterCount = files.count;
        }
    }
    
    // Draw cache stats
    NSRect statsRect = NSMakeRect(x + padding, startY - 60, width - (padding * 2), 20);
    NSString *statsText = [NSString stringWithFormat:@"Cache: %ld movie descriptions, %ld poster images", 
                          (long)movieInfoCount, (long)posterCount];
    [statsText drawInRect:statsRect withAttributes:descAttrs];
    
    // Draw refresh button or progress bar
    NSRect refreshButtonRect = NSMakeRect(
        x + padding, 
        startY - 110, 
        buttonWidth, 
        buttonHeight
    );
    
    if (self.isRefreshingMovieInfo) {
        // Draw progress bar instead of button
        NSRect progressBarRect = refreshButtonRect;
        
        // Draw progress bar background
        [[NSColor colorWithCalibratedRed:0.3 green:0.3 blue:0.3 alpha:1.0] set];
        NSBezierPath *progressBgPath = [NSBezierPath bezierPathWithRoundedRect:progressBarRect xRadius:5 yRadius:5];
        [progressBgPath fill];
        
        // Calculate progress percentage
        CGFloat progressPercent = 0.0;
        if (self.movieRefreshTotal > 0) {
            progressPercent = (CGFloat)self.movieRefreshCompleted / (CGFloat)self.movieRefreshTotal;
        }
        progressPercent = MIN(1.0, MAX(0.0, progressPercent)); // Clamp between 0 and 1
        
        // Draw progress fill
        if (progressPercent > 0) {
            NSRect progressFillRect = NSMakeRect(
                progressBarRect.origin.x,
                progressBarRect.origin.y,
                progressBarRect.size.width * progressPercent,
                progressBarRect.size.height
            );
            
            [[NSColor colorWithCalibratedRed:0.2 green:0.6 blue:0.2 alpha:1.0] set];
            NSBezierPath *progressFillPath = [NSBezierPath bezierPathWithRoundedRect:progressFillRect xRadius:5 yRadius:5];
            [progressFillPath fill];
        }
        
        // Draw progress text
        NSMutableParagraphStyle *progressStyle = [[NSMutableParagraphStyle alloc] init];
        [progressStyle setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *progressAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:12],
            NSForegroundColorAttributeName: [NSColor whiteColor],
            NSParagraphStyleAttributeName: progressStyle
        };
        
        NSString *progressText = [NSString stringWithFormat:@"Refreshing... %ld/%ld (%.0f%%)", 
                                 (long)self.movieRefreshCompleted, 
                                 (long)self.movieRefreshTotal, 
                                 progressPercent * 100];
        
        NSRect progressTextRect = NSMakeRect(
            progressBarRect.origin.x, 
            progressBarRect.origin.y + (progressBarRect.size.height - 16) / 2, 
            progressBarRect.size.width, 
            16
        );
        
        [progressText drawInRect:progressTextRect withAttributes:progressAttrs];
        
        // Store the progress bar rect for reference
        self.movieInfoProgressBarRect = progressBarRect;
        
        [progressStyle release];
    } else {
        // Draw normal button
        [[NSColor colorWithCalibratedRed:0.2 green:0.4 blue:0.6 alpha:1.0] set];
        NSBezierPath *buttonPath = [NSBezierPath bezierPathWithRoundedRect:refreshButtonRect xRadius:5 yRadius:5];
        [buttonPath fill];
        
        // Draw button text
        NSMutableParagraphStyle *buttonStyle = [[NSMutableParagraphStyle alloc] init];
        [buttonStyle setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *buttonAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
            NSForegroundColorAttributeName: [NSColor whiteColor],
            NSParagraphStyleAttributeName: buttonStyle
        };
        
        NSRect buttonTextRect = NSMakeRect(
            refreshButtonRect.origin.x, 
            refreshButtonRect.origin.y + (refreshButtonRect.size.height - 20) / 2, 
            refreshButtonRect.size.width, 
            20
        );
        
        [@"Refresh All Movie Info & Covers" drawInRect:buttonTextRect withAttributes:buttonAttrs];
        
        // Store the button rect for click handling
        self.movieInfoRefreshButtonRect = refreshButtonRect;
        
        [buttonStyle release];
    }
    
    [style release];
}

// Add a debug method to visualize channel list boundaries
- (void)drawChannelListBoundaries:(NSRect)rect {
    // Define exact boundaries for the channel list area
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    
    // Calculate channelListWidth dynamically to match the UI layout
    CGFloat programGuideWidth = 350; // Width reserved for program guide
    CGFloat channelListWidth = self.bounds.size.width - catWidth - groupWidth - programGuideWidth;
    
    // Calculate the exact start and end points of channel list
    CGFloat channelListStartX = catWidth + groupWidth;
    CGFloat channelListEndX = channelListStartX + channelListWidth;
    
    // Draw vertical lines at the boundaries
    NSBezierPath *leftBoundary = [NSBezierPath bezierPath];
    [leftBoundary moveToPoint:NSMakePoint(channelListStartX, 0)];
    [leftBoundary lineToPoint:NSMakePoint(channelListStartX, self.bounds.size.height)];
    [[NSColor greenColor] set];
    [leftBoundary setLineWidth:2.0];
    [leftBoundary stroke];
    
    NSBezierPath *rightBoundary = [NSBezierPath bezierPath];
    [rightBoundary moveToPoint:NSMakePoint(channelListEndX, 0)];
    [rightBoundary lineToPoint:NSMakePoint(channelListEndX, self.bounds.size.height)];
    [[NSColor redColor] set];
    [rightBoundary setLineWidth:2.0];
    [rightBoundary stroke];
    
    // Draw labels
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *attrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor whiteColor],
        NSParagraphStyleAttributeName: style
    };
    
    NSString *leftLabel = @"Channel List Start";
    NSString *rightLabel = @"Channel List End";
    
    [leftLabel drawInRect:NSMakeRect(channelListStartX - 80, self.bounds.size.height - 30, 160, 20) 
          withAttributes:attrs];
    [rightLabel drawInRect:NSMakeRect(channelListEndX - 80, self.bounds.size.height - 30, 160, 20) 
          withAttributes:attrs];
    
    [style release];
}

#pragma mark - Player Controls

// Method to handle clicks on the player controls
- (BOOL)handlePlayerControlsClickAtPoint:(NSPoint)point {
    // First check if the click is within the overall player controls area
    if (!NSPointInRect(point, self.playerControlsRect)) {
        return NO;
    }
    
    // Check if click is on the progress bar
    if (NSPointInRect(point, self.progressBarRect)) {
        // Calculate the position relative to the progress bar
        CGFloat relativeX = point.x - self.progressBarRect.origin.x;
        CGFloat relativePosition = relativeX / self.progressBarRect.size.width;
        relativePosition = MIN(1.0, MAX(0.0, relativePosition)); // Clamp between 0 and 1
        
        // Get total duration
        VLCTime *totalTime = [self.player.media length];
        if (totalTime && [totalTime intValue] > 0) {
            // Calculate new position in milliseconds
            int newPositionMs = (int)([totalTime intValue] * relativePosition);
            
            // Create a VLCTime object with the new position
            VLCTime *newTime = [VLCTime timeWithInt:newPositionMs];
            
            // Set the player to the new position
            [self.player setTime:newTime];
            
            // Force an immediate redraw of the controls
            [self setNeedsDisplay:YES];
            
            // Reset the auto-hide timer when user interacts with controls
            if (playerControlsTimer) {
                [playerControlsTimer invalidate];
            }
            playerControlsTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
                                                            target:self
                                                          selector:@selector(hidePlayerControls:)
                                                          userInfo:nil
                                                           repeats:NO];
        }
        
        return YES; // Indicate we handled the click
    }
    
    // If click was on controls but not on progress bar, just show/hide controls
    //[self togglePlayerControls];
        return YES;
    }
// Method to draw all dropdowns at the end for proper z-ordering
- (void)drawDropdowns:(NSRect)rect {
    //NSLog(@"drawDropdowns called with rect: {{%.1f, %.1f}, {%.1f, %.1f}}", rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    
    if (!self.dropdownManager) {
        //NSLog(@"ERROR: Dropdown manager is nil in drawDropdowns!");
        return;
    }
    
    //NSLog(@"Dropdown manager has %ld active dropdowns", [self.dropdownManager.activeDropdowns count]);
    
    // Log each dropdown state
    for (NSString *identifier in self.dropdownManager.activeDropdowns) {
        VLCDropdown *dropdown = [self.dropdownManager.activeDropdowns objectForKey:identifier];
      //  NSLog(@"Dropdown '%@': isOpen=%@, items=%ld", identifier, dropdown.isOpen ? @"YES" : @"NO", [dropdown.items count]);
    }
    
    // Use the new dropdown manager to draw all dropdowns
    [self.dropdownManager drawAllDropdowns:rect];
    //NSLog(@"Finished drawing dropdowns");
}

// Handle dropdown hover states
- (void)handleDropdownHover:(NSPoint)point {
    NSInteger prevHoveredIndex = self.epgTimeOffsetDropdownHoveredIndex;
    
    // Check EPG Time Offset dropdown hover
    if (self.epgTimeOffsetDropdownActive) {
        NSInteger hoveredIndex = [self getDropdownOptionIndexAtPoint:point 
                                                        dropdownRect:self.epgTimeOffsetDropdownRect 
                                                         optionCount:25]; // -12 to +12 = 25 options
        
        // Convert from 0-based index to -12..+12 range
        if (hoveredIndex >= 0 && hoveredIndex < 25) {
            self.epgTimeOffsetDropdownHoveredIndex = hoveredIndex - 12; // Convert to -12..+12 range
        } else {
            self.epgTimeOffsetDropdownHoveredIndex = -1; // No hover
        }
    } else {
        self.epgTimeOffsetDropdownHoveredIndex = -1; // No hover when dropdown not active
    }
    
    // Redraw if hover state changed
    if (prevHoveredIndex != self.epgTimeOffsetDropdownHoveredIndex) {
        [self setNeedsDisplay:YES];
    }
}

#pragma mark - Reusable Dropdown Helper Methods

// Reusable dropdown rendering method
- (void)drawDropdownWithRect:(NSRect)dropdownRect 
                 optionValues:(NSArray *)values 
               selectedIndex:(NSInteger)selectedIndex 
                hoveredIndex:(NSInteger)hoveredIndex
                formatBlock:(NSString *(^)(id value))formatBlock {
    if (!values || [values count] == 0) return;
    
    CGFloat optionHeight = 25;
    CGFloat dropdownOptionsHeight = [values count] * optionHeight;
    NSRect dropdownOptionsRect = NSMakeRect(dropdownRect.origin.x,
                                           dropdownRect.origin.y - dropdownOptionsHeight,
                                           dropdownRect.size.width,
                                           dropdownOptionsHeight);
    
    // Add shadow effect first
    NSRect shadowRect = NSOffsetRect(dropdownOptionsRect, 2, -2);
    [[NSColor colorWithCalibratedRed:0 green:0 blue:0 alpha:0.3] set];
    NSRectFill(shadowRect);
    
    // Semi-transparent background for options with high alpha for visibility
    [[NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:0.98] set];
    NSRectFill(dropdownOptionsRect);
    
    // Strong border for options
    [[NSColor colorWithCalibratedRed:0.5 green:0.5 blue:0.5 alpha:1.0] set];
    NSFrameRect(dropdownOptionsRect);
    
    // Text style
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    // Draw each option
    for (NSInteger i = 0; i < [values count]; i++) {
        NSRect optionRect = NSMakeRect(dropdownOptionsRect.origin.x,
                                      dropdownOptionsRect.origin.y + (([values count] - 1 - i) * optionHeight),
                                      dropdownOptionsRect.size.width,
                                      optionHeight);
        
        // Determine colors based on state
        NSColor *bgColor = nil;
        NSColor *textColor = [NSColor lightGrayColor];
        
        if (i == selectedIndex && i == hoveredIndex) {
            // Both selected and hovered
            bgColor = [NSColor colorWithCalibratedRed:0.4 green:0.6 blue:0.9 alpha:0.9];
            textColor = [NSColor whiteColor];
        } else if (i == selectedIndex) {
            // Selected but not hovered
            bgColor = [NSColor colorWithCalibratedRed:0.3 green:0.5 blue:0.7 alpha:0.8];
            textColor = [NSColor whiteColor];
        } else if (i == hoveredIndex) {
            // Hovered but not selected
            bgColor = [NSColor colorWithCalibratedRed:0.25 green:0.25 blue:0.25 alpha:0.8];
            textColor = [NSColor whiteColor];
        }
        
        // Fill background if needed
        if (bgColor) {
            [bgColor set];
            NSRectFill(optionRect);
        }
        
        // Option text
        id value = [values objectAtIndex:i];
        NSString *optionText = formatBlock ? formatBlock(value) : [value description];
        
        NSDictionary *optionAttrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:13],
            NSForegroundColorAttributeName: textColor,
            NSParagraphStyleAttributeName: style
        };
        
        NSRect optionTextRect = NSMakeRect(optionRect.origin.x + 10,
                                          optionRect.origin.y + (optionHeight - 16) / 2,
                                          optionRect.size.width - 20,
                                          16);
        [optionText drawInRect:optionTextRect withAttributes:optionAttrs];
    }
    
    [style release];
}

// Method to get dropdown options rect
- (NSRect)getDropdownOptionsRect:(NSRect)dropdownRect optionCount:(NSInteger)optionCount {
    CGFloat optionHeight = 25;
    CGFloat dropdownOptionsHeight = optionCount * optionHeight;
    return NSMakeRect(dropdownRect.origin.x,
                     dropdownRect.origin.y - dropdownOptionsHeight,
                     dropdownRect.size.width,
                     dropdownOptionsHeight);
}

// Method to find which dropdown option is at a given point
- (NSInteger)getDropdownOptionIndexAtPoint:(NSPoint)point dropdownRect:(NSRect)dropdownRect optionCount:(NSInteger)optionCount {
    NSRect dropdownOptionsRect = [self getDropdownOptionsRect:dropdownRect optionCount:optionCount];
    
    if (!NSPointInRect(point, dropdownOptionsRect)) {
        return -1; // Not in dropdown area
    }
    
    CGFloat optionHeight = 25;
    CGFloat relativeY = point.y - dropdownOptionsRect.origin.y;
    NSInteger optionIndex = (NSInteger)(relativeY / optionHeight);
    
    // Convert to proper index (reverse order since we draw from top to bottom)
    optionIndex = (optionCount - 1) - optionIndex;
    
    if (optionIndex >= 0 && optionIndex < optionCount) {
        return optionIndex;
    }
    
    return -1;
}




- (void)drawSubtitleSettings:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = self.bounds.size.height - 100;
    CGFloat controlWidth = width - (padding * 2);
    CGFloat yOffset = 0;
    
    // Draw a section title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, controlWidth, 20);
    [@"Subtitle Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Description
    NSDictionary *descAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect descRect = NSMakeRect(x + padding, startY - 25, controlWidth, 16);
    [@"Move the slider to adjust subtitle text size in real-time" drawInRect:descRect withAttributes:descAttrs];
    
    // Get settings instance
    VLCSubtitleSettings *settings = [VLCSubtitleSettings sharedInstance];
    
    yOffset = 60;
    
    // Font Size Control
    CGFloat sliderY = startY - yOffset;
    NSString *fontSizeLabel = [NSString stringWithFormat:@"Font Size: %ld px", (long)settings.fontSize];
    
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect fontSizeLabelRect = NSMakeRect(x + padding, sliderY, controlWidth, 20);
    [fontSizeLabel drawInRect:fontSizeLabelRect withAttributes:labelAttrs];
    
    // Draw slider background with rounded corners
    NSRect sliderRect = NSMakeRect(x + padding, sliderY - 25, controlWidth - 40, 8); // Made thicker for easier interaction
    [[NSColor colorWithCalibratedRed:0.3 green:0.3 blue:0.3 alpha:1.0] set];
    NSBezierPath *sliderBg = [NSBezierPath bezierPathWithRoundedRect:sliderRect xRadius:4 yRadius:4];
    [sliderBg fill];
    
    // Draw slider fill (representing current value)
    CGFloat sliderProgress = (settings.fontSize - 6.0) / (30.0 - 6.0); // Range 6-30px
    sliderProgress = MAX(0.0, MIN(1.0, sliderProgress));
    NSRect sliderFillRect = NSMakeRect(sliderRect.origin.x, sliderRect.origin.y, 
                                       sliderRect.size.width * sliderProgress, sliderRect.size.height);
    [[NSColor colorWithCalibratedRed:0.3 green:0.5 blue:0.8 alpha:1.0] set];
    NSBezierPath *sliderFill = [NSBezierPath bezierPathWithRoundedRect:sliderFillRect xRadius:4 yRadius:4];
    [sliderFill fill];
    
    // Draw slider thumb with better design
    CGFloat thumbX = sliderRect.origin.x + (sliderRect.size.width * sliderProgress) - 8;
    NSRect thumbRect = NSMakeRect(thumbX, sliderRect.origin.y - 4, 16, 16);
    
    // Add subtle shadow to thumb
    [[NSColor colorWithCalibratedRed:0 green:0 blue:0 alpha:0.3] set];
    NSBezierPath *thumbShadow = [NSBezierPath bezierPathWithOvalInRect:NSOffsetRect(thumbRect, 1, -1)];
    [thumbShadow fill];
    
    // Thumb
    [[NSColor whiteColor] set];
    NSBezierPath *thumbPath = [NSBezierPath bezierPathWithOvalInRect:thumbRect];
    [thumbPath fill];
    
    // Store slider rectangle for click handling (expand hitbox for easier interaction)
    NSRect interactionRect = NSMakeRect(sliderRect.origin.x - 10, sliderRect.origin.y - 10, 
                                        sliderRect.size.width + 20, sliderRect.size.height + 20);
    objc_setAssociatedObject(self, "subtitleFontSizeSliderRect", [NSValue valueWithRect:interactionRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
    [style release];
}
- (void)drawPlaylistSettingsWithComponents:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    // Check if settings panel should be visible (both menu and settings category must be visible)
    BOOL settingsVisible = (self.isChannelListVisible && self.selectedCategoryIndex == CATEGORY_SETTINGS);
    
    // Update UI components visibility (this is also called from main drawRect, but ensure it's current)
    [self updateUIComponentsVisibility];
    
    // If settings are not visible, return early
    if (!settingsVisible) {
        return;
    }
    
    // Improved layout with better padding and spacing
    CGFloat padding = 30;
    CGFloat fieldHeight = 35;
    CGFloat labelHeight = 22;
    CGFloat verticalSpacing = 25;
    CGFloat sectionSpacing = 25;
    CGFloat startY = self.bounds.size.height - 80;
    CGFloat fieldWidth = width - (padding * 2);
    
    // Draw a section title with better styling
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:18],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, fieldWidth, labelHeight + 5);
    [@"Playlist Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    CGFloat currentY = startY - (labelHeight + sectionSpacing);
    
    // M3U URL Label with better styling
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:15],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect m3uLabelRect = NSMakeRect(x + padding, currentY, fieldWidth, labelHeight);
    [@"M3U Playlist URL:" drawInRect:m3uLabelRect withAttributes:labelAttrs];
    currentY -= (labelHeight + verticalSpacing);
    
    // Create or update M3U text field
    NSRect m3uFieldRect = NSMakeRect(x + padding, currentY, fieldWidth, fieldHeight);
    if (!self.m3uTextField) {
        self.m3uTextField = [[VLCReusableTextField alloc] initWithFrame:m3uFieldRect identifier:@"m3u"];
        self.m3uTextField.textFieldDelegate = self;
        [self.m3uTextField setPlaceholderText:@"Enter M3U playlist URL..."];
        // Don't add to subview here - will be managed by updateUIComponentsVisibility
    } else {
        [self.m3uTextField setFrame:m3uFieldRect];
    }
    
    // Always set the current value from saved settings (fix for immediate display)
    NSString *currentM3uValue = @"";
    if (self.m3uFilePath && [self.m3uFilePath length] > 0) {
        // Use the saved M3U file path
        currentM3uValue = self.m3uFilePath;
    } else if (self.tempM3uUrl && [self.tempM3uUrl length] > 0) {
        // Fallback to temp URL if no saved path
        currentM3uValue = self.tempM3uUrl;
    }
    // Only set text value if the field is not currently being edited
    if (!self.m3uTextField.isActive) {
        [self.m3uTextField setTextValue:currentM3uValue];
    }
    
    // Auto-generate EPG URL if M3U URL exists but EPG URL is missing
    if (currentM3uValue && [currentM3uValue length] > 0 && (!self.epgUrl || [self.epgUrl length] == 0)) {
        NSString *generatedEpgUrl = [self generateEpgUrlFromM3uUrl:currentM3uValue];
        if (generatedEpgUrl && [generatedEpgUrl length] > 0) {
            self.epgUrl = generatedEpgUrl;
        }
    }
    
    currentY -= (fieldHeight + sectionSpacing);
    
    // EPG URL Label
    NSRect epgLabelRect = NSMakeRect(x + padding, currentY, fieldWidth, labelHeight);
    [@"EPG URL (auto-generated, click to copy):" drawInRect:epgLabelRect withAttributes:labelAttrs];
    currentY -= (labelHeight + verticalSpacing);
    
    // Create or update EPG clickable label (without visible frame)
    NSRect epgFieldRect = NSMakeRect(x + padding, currentY, fieldWidth, fieldHeight);
    if (!self.epgLabel) {
        self.epgLabel = [[VLCClickableLabel alloc] initWithFrame:epgFieldRect identifier:@"epg"];
        self.epgLabel.delegate = self;
        [self.epgLabel setPlaceholderText:@"EPG URL will be auto-generated from M3U URL"];
        // Don't add to subview here - will be managed by updateUIComponentsVisibility
    } else {
        [self.epgLabel setFrame:epgFieldRect];
    }
    
    // Set the current EPG URL
    NSString *currentEpgValue = self.epgUrl ? self.epgUrl : @"";
    [self.epgLabel setText:currentEpgValue];
    
    currentY -= (fieldHeight + sectionSpacing);
    
    // EPG Time Offset Label and Dropdown
    NSRect epgOffsetLabelRect = NSMakeRect(x + padding, currentY, fieldWidth, labelHeight);
    [@"EPG Time Offset:" drawInRect:epgOffsetLabelRect withAttributes:labelAttrs];
    currentY -= (labelHeight + verticalSpacing);
    
    // EPG Time Offset Dropdown with better width
    CGFloat dropdownWidth = 150;
    NSRect epgTimeOffsetDropdownRect = NSMakeRect(x + padding, currentY, dropdownWidth, fieldHeight);
    self.epgTimeOffsetDropdownRect = epgTimeOffsetDropdownRect;
    
    // Update dropdown frame in dropdown manager
    VLCDropdown *offsetDropdown = [self.dropdownManager dropdownWithIdentifier:@"EPGTimeOffset"];
    if (offsetDropdown) {
        offsetDropdown.frame = epgTimeOffsetDropdownRect;
    }
    
    // Draw dropdown background
    NSColor *dropdownBgColor = [NSColor colorWithCalibratedRed:0.1 green:0.1 blue:0.1 alpha:1.0];
    [dropdownBgColor set];
    NSBezierPath *dropdownBgPath = [NSBezierPath bezierPathWithRoundedRect:epgTimeOffsetDropdownRect xRadius:3 yRadius:3];
    [dropdownBgPath fill];
    
    // Draw dropdown border
    NSColor *dropdownBorderColor = [NSColor colorWithCalibratedRed:0.3 green:0.3 blue:0.3 alpha:1.0];
    [dropdownBorderColor set];
    NSBezierPath *dropdownBorderPath = [NSBezierPath bezierPathWithRoundedRect:NSInsetRect(epgTimeOffsetDropdownRect, 0.5, 0.5) xRadius:3 yRadius:3];
    [dropdownBorderPath setLineWidth:1.0];
    [dropdownBorderPath stroke];
    
    // Draw dropdown text
    NSString *offsetText = [NSString stringWithFormat:@"%+d hours", (int)self.epgTimeOffsetHours];
    NSRect dropdownTextRect = NSMakeRect(epgTimeOffsetDropdownRect.origin.x + 5, 
                                        epgTimeOffsetDropdownRect.origin.y + 7, 
                                        epgTimeOffsetDropdownRect.size.width - 20, 
                                        epgTimeOffsetDropdownRect.size.height - 14);
    [offsetText drawInRect:dropdownTextRect withAttributes:labelAttrs];
    
    // Draw dropdown arrow
    NSRect arrowRect = NSMakeRect(epgTimeOffsetDropdownRect.origin.x + epgTimeOffsetDropdownRect.size.width - 15,
                                 epgTimeOffsetDropdownRect.origin.y + 10,
                                 10, 10);
    NSBezierPath *arrowPath = [NSBezierPath bezierPath];
    [arrowPath moveToPoint:NSMakePoint(arrowRect.origin.x, arrowRect.origin.y + 3)];
    [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + 5, arrowRect.origin.y + 8)];
    [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + 10, arrowRect.origin.y + 3)];
    [[NSColor lightGrayColor] set];
    [arrowPath setLineWidth:1.5];
    [arrowPath stroke];
    
    currentY -= (fieldHeight + sectionSpacing);
    
    // Buttons row with improved spacing
    CGFloat buttonWidth = 130;
    CGFloat buttonHeight = 40;
    CGFloat buttonSpacing = 20;
    
    // Load button
    NSRect loadButtonRect = NSMakeRect(x + padding, currentY, buttonWidth, buttonHeight);
    self.loadButtonRect = loadButtonRect;
    
    // Draw load button background with disabled state
    NSColor *loadButtonColor;
    if (self.isLoading) {
        loadButtonColor = [NSColor colorWithCalibratedRed:0.5 green:0.5 blue:0.5 alpha:0.6]; // Grayed out when disabled
    } else {
        loadButtonColor = [NSColor colorWithCalibratedRed:0.2 green:0.4 blue:0.7 alpha:1.0]; // Normal blue
    }
    [loadButtonColor set];
    NSBezierPath *loadButtonPath = [NSBezierPath bezierPathWithRoundedRect:loadButtonRect xRadius:5 yRadius:5];
    [loadButtonPath fill];
    
    // Draw load button text with centered alignment
    NSMutableParagraphStyle *buttonStyle = [[NSMutableParagraphStyle alloc] init];
    [buttonStyle setAlignment:NSTextAlignmentCenter];
    
    NSColor *buttonTextColor = self.isLoading ? [NSColor colorWithCalibratedWhite:0.8 alpha:0.6] : [NSColor whiteColor];
    NSDictionary *buttonTextAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
        NSForegroundColorAttributeName: buttonTextColor,
        NSParagraphStyleAttributeName: buttonStyle
    };
    
    NSRect loadButtonTextRect = NSMakeRect(loadButtonRect.origin.x, loadButtonRect.origin.y + 10, 
                                          loadButtonRect.size.width, loadButtonRect.size.height - 20);
    [@"Load Playlist" drawInRect:loadButtonTextRect withAttributes:buttonTextAttrs];
    
    // Update EPG button
    NSRect epgButtonRect = NSMakeRect(x + padding + buttonWidth + buttonSpacing, currentY, buttonWidth, buttonHeight);
    self.epgButtonRect = epgButtonRect;
    
    // Draw EPG button background with disabled state
    NSColor *epgButtonColor;
    if (self.isLoading) {
        epgButtonColor = [NSColor colorWithCalibratedRed:0.5 green:0.5 blue:0.5 alpha:0.6]; // Grayed out when disabled
    } else {
        epgButtonColor = [NSColor colorWithCalibratedRed:0.2 green:0.6 blue:0.3 alpha:1.0]; // Normal green
    }
    [epgButtonColor set];
    NSBezierPath *epgButtonPath = [NSBezierPath bezierPathWithRoundedRect:epgButtonRect xRadius:5 yRadius:5];
    [epgButtonPath fill];
    
    // Draw EPG button text
    NSRect epgButtonTextRect = NSMakeRect(epgButtonRect.origin.x, epgButtonRect.origin.y + 10, 
                                         epgButtonRect.size.width, epgButtonRect.size.height - 20);
    [@"Update EPG" drawInRect:epgButtonTextRect withAttributes:buttonTextAttrs];
    
    [buttonStyle release];
    [style release];
}

- (void)hideControls {
    // Remove all UI components from view hierarchy
    if (self.m3uTextField && [self.m3uTextField superview] != nil) {
        [self.m3uTextField removeFromSuperview];
    }
    if (self.epgLabel && [self.epgLabel superview] != nil) {
        [self.epgLabel removeFromSuperview];
    }
    if (self.searchTextField && [self.searchTextField superview] != nil) {
        [self.searchTextField removeFromSuperview];
    }
    // Also hide any other UI components that might be visible
    // This ensures a clean slate before showing the menu
}



- (void)setupEpgTimeOffsetDropdown {
    // Create EPG time offset dropdown with placeholder frame (will be updated in drawPlaylistSettingsWithComponents)
    NSRect placeholderFrame = NSMakeRect(0, 0, 100, 30);
    VLCDropdown *offsetDropdown = [self.dropdownManager createDropdownWithIdentifier:@"EPGTimeOffset" frame:placeholderFrame];
    
    // Add time offset options from -12 to +12 hours
    for (NSInteger offset = -12; offset <= 12; offset++) {
        NSString *displayText;
        if (offset == 0) {
            displayText = @"0 hours (UTC)";
        } else {
            displayText = [NSString stringWithFormat:@"%+ld hours", (long)offset];
        }
        
        [offsetDropdown addItemWithValue:[NSNumber numberWithInteger:offset] displayText:displayText];
        
        // Set default selection to 0 (UTC)
        if (offset == 0) {
            offsetDropdown.selectedIndex = [offsetDropdown.items count] - 1;
        }
    }
    
    // Set up selection callback
    offsetDropdown.onSelectionChanged = ^(VLCDropdown *dropdown, VLCDropdownItem *selectedItem, NSInteger selectedIndex) {
        if (selectedItem && selectedItem.value) {
            NSNumber *offsetValue = (NSNumber *)selectedItem.value;
            
            // Update the EPG time offset
            self.epgTimeOffsetHours = [offsetValue integerValue];
            
            NSLog(@"EPG time offset changed to: %ld hours", (long)self.epgTimeOffsetHours);
            
            // Save settings
            if ([self respondsToSelector:@selector(saveSettings)]) {
                [self saveSettings];
            }
            
            // Refresh display
            [self setNeedsDisplay:YES];
        }
    };
}



#pragma mark - VLCClickableLabelDelegate

- (void)clickableLabelWasClicked:(NSString *)identifier withText:(NSString *)text {
    if ([identifier isEqualToString:@"epg"]) {
        // Text is already copied to clipboard by the clickable label
        // Show a brief confirmation message
        [self setLoadingStatusText:@"EPG URL copied to clipboard"];
        
        // Clear the message after a short delay
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), 
                      dispatch_get_main_queue(), ^{
            if (gProgressMessageLock) {
                [gProgressMessageLock lock];
                [gProgressMessage release];
                gProgressMessage = nil;
                [gProgressMessageLock unlock];
            }
            [self setNeedsDisplay:YES];
        });
        
        [self setNeedsDisplay:YES];
    }
}

// Handle right-click on EPG programs
- (BOOL)handleEpgProgramRightClick:(NSPoint)point withEvent:(NSEvent *)event {
    // Only handle if we're hovering on a channel and EPG is visible
    if (self.hoveredChannelIndex < 0) {
    return NO;
}

    // Calculate EPG panel boundaries (same as in drawProgramGuideForHoveredChannel)
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat channelListX = catWidth + groupWidth;
    CGFloat programGuideWidth = 400;
    CGFloat channelListWidth = self.bounds.size.width - channelListX - programGuideWidth;
    CGFloat guidePanelX = channelListX + channelListWidth;
    CGFloat guidePanelWidth = programGuideWidth;
    CGFloat guidePanelHeight = self.bounds.size.height;
    
    // Check if click is within EPG panel
    if (point.x < guidePanelX || point.x > guidePanelX + guidePanelWidth) {
        return NO;
    }
    
    // Get the hovered channel
    VLCChannel *channel = [self getChannelAtHoveredIndex];
    if (!channel || !channel.programs || [channel.programs count] == 0) {
        return NO;
    }
    
    NSLog(@"EPG Right-click detected on channel: %@ (hoveredChannelIndex: %ld)", 
          channel.name, (long)self.hoveredChannelIndex);
    
    // Sort programs by start time (same as in drawing code)
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    // Calculate which program was clicked
    CGFloat entryHeight = 65;
    CGFloat entrySpacing = 8;
    
    for (NSInteger i = 0; i < [sortedPrograms count]; i++) {
        VLCProgram *program = [sortedPrograms objectAtIndex:i];
        
        // Calculate Y position for this item (same calculation as in drawing code)
        CGFloat itemY = guidePanelHeight - ((i + 1) * (entryHeight + entrySpacing)) + self.epgScrollPosition;
        
        // Skip items that are completely outside the visible area
        if (itemY + entryHeight < 0 || itemY > guidePanelHeight) {
            continue;
        }
        
        // Create the program entry rect
        NSRect entryRect = NSMakeRect(
            guidePanelX + 10,
            itemY,
            guidePanelWidth - 20,
            entryHeight
        );
        
        // Check if click is within this program's rect
        if (NSPointInRect(point, entryRect)) {
            // Store the clicked program and channel for the context menu
            rightClickedProgram = program;
            rightClickedProgramChannel = channel;
            
            // Show context menu for this program
            [self showContextMenuForProgram:program channel:channel atPoint:point withEvent:event];
            return YES;
        }
    }
    
    return NO;
}

// Show context menu for EPG program
- (void)showContextMenuForProgram:(VLCProgram *)program channel:(VLCChannel *)channel atPoint:(NSPoint)point withEvent:(NSEvent *)event {
    NSLog(@"Creating EPG context menu for program: %@ on channel: %@", program.title, channel.name);
    
    NSMenu *menu = [[NSMenu alloc] init];
    
    // Add program title as header (disabled)
    NSString *programTitle = program.title ? program.title : @"Unknown Program";
    if ([programTitle length] > 40) {
        programTitle = [[programTitle substringToIndex:37] stringByAppendingString:@"..."];
    }
    
    NSMenuItem *titleItem = [[NSMenuItem alloc] initWithTitle:programTitle 
                                                      action:nil 
                                               keyEquivalent:@""];
    [titleItem setEnabled:NO]; // Disabled, just for display
    [menu addItem:titleItem];
    [titleItem release];
    
    // Add separator
    [menu addItem:[NSMenuItem separatorItem]];
    
    // Check if catch-up is available for this program
    if (program.hasArchive) {
        // Add "Play CatchUp" option
        NSMenuItem *catchupItem = [[NSMenuItem alloc] initWithTitle:@"Play CatchUp" 
                                                            action:@selector(playCatchUpFromMenu:) 
                                                     keyEquivalent:@""];
        [catchupItem setTarget:self];
        [catchupItem setRepresentedObject:program];
        [menu addItem:catchupItem];
        [catchupItem release];
    } else {
        // Add disabled "No CatchUp" option
        NSMenuItem *noCatchupItem = [[NSMenuItem alloc] initWithTitle:@"No CatchUp" 
                                                              action:nil 
                                                       keyEquivalent:@""];
        [noCatchupItem setEnabled:NO];
        [menu addItem:noCatchupItem];
        [noCatchupItem release];
    }
    
    // Add separator
    [menu addItem:[NSMenuItem separatorItem]];
    
    // Add "Play Channel" option
    NSMenuItem *playChannelItem = [[NSMenuItem alloc] initWithTitle:@"Play Channel" 
                                                            action:@selector(playChannelFromEpgMenu:) 
                                                     keyEquivalent:@""];
    [playChannelItem setTarget:self];
    [playChannelItem setRepresentedObject:channel];
    [menu addItem:playChannelItem];
    [playChannelItem release];
    
    // Show the menu
    [NSMenu popUpContextMenu:menu withEvent:event forView:self];
    [menu release];
}

// Handle "Play CatchUp" menu action
- (void)playCatchUpFromMenu:(NSMenuItem *)sender {
    VLCProgram *program = [sender representedObject];
    if (program && rightClickedProgramChannel) {
        NSLog(@"Playing catch-up for program: %@ on channel: %@", program.title, rightClickedProgramChannel.name);
        
        // Generate timeshift URL for the program
        NSString *timeshiftUrl = [self generateTimeshiftUrlForProgram:program channel:rightClickedProgramChannel];
        
        if (timeshiftUrl) {
            NSLog(@"Generated timeshift URL: %@", timeshiftUrl);
            
            // Stop current playback
            if (self.player) {
                [self saveCurrentPlaybackPosition];
                [self.player stop];
            }
            
            // Brief pause to allow VLC to reset
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                // Create media object with timeshift URL
                NSURL *url = [NSURL URLWithString:timeshiftUrl];
                VLCMedia *media = [VLCMedia mediaWithURL:url];
                
                // Set the media to the player
                [self.player setMedia:media];
                
                // Apply subtitle settings
                if ([VLCSubtitleSettings respondsToSelector:@selector(applyCurrentSettingsToPlayer:)]) {
                    [VLCSubtitleSettings applyCurrentSettingsToPlayer:self.player];
                }
                
                // Start playing
                [self.player play];
                
                NSLog(@"Started timeshift playback for program: %@", program.title);
                
                // Force UI update
                [self setNeedsDisplay:YES];
            });
            
            // Save the timeshift URL as last played for resume functionality
            [self saveLastPlayedChannelUrl:timeshiftUrl];
            
            // Create a temporary channel object for timeshift content
            VLCChannel *timeshiftChannel = [[VLCChannel alloc] init];
            timeshiftChannel.name = [NSString stringWithFormat:@"%@ (Timeshift: %@)", rightClickedProgramChannel.name, program.title];
            timeshiftChannel.url = timeshiftUrl;
            timeshiftChannel.channelId = rightClickedProgramChannel.channelId;
            timeshiftChannel.group = rightClickedProgramChannel.group;
            timeshiftChannel.category = rightClickedProgramChannel.category;
            timeshiftChannel.logo = rightClickedProgramChannel.logo;
            
            // Add program info to the timeshift channel
            timeshiftChannel.programs = [NSMutableArray arrayWithObject:program];
            
            [self saveLastPlayedContentInfo:timeshiftChannel];
            [timeshiftChannel release];
            
            // Hide the channel list after starting playback
            [self hideChannelListWithFade];
        } else {
            NSLog(@"Failed to generate timeshift URL for program: %@", program.title);
            
            // Show a brief error message
            [self setLoadingStatusText:@"Error: Could not generate timeshift URL"];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (gProgressMessageLock) {
                    [gProgressMessageLock lock];
                    [gProgressMessage release];
                    gProgressMessage = nil;
                    [gProgressMessageLock unlock];
                }
                [self setNeedsDisplay:YES];
            });
        }
        
        // Clear the stored references
        rightClickedProgram = nil;
        rightClickedProgramChannel = nil;
    }
}

// Handle "Play Channel" menu action from EPG context menu
- (void)playChannelFromEpgMenu:(NSMenuItem *)sender {
    VLCChannel *channel = [sender representedObject];
    if (channel) {
        NSLog(@"EPG Context Menu - Playing channel: %@ (URL: %@)", channel.name, channel.url);
        NSLog(@"EPG Context Menu - rightClickedProgramChannel: %@ (URL: %@)", 
              rightClickedProgramChannel ? rightClickedProgramChannel.name : @"nil",
              rightClickedProgramChannel ? rightClickedProgramChannel.url : @"nil");
        
        // Use the stored rightClickedProgramChannel to ensure we play the correct channel
        // This is more reliable than the representedObject
        VLCChannel *channelToPlay = rightClickedProgramChannel ? rightClickedProgramChannel : channel;
        
        if (channelToPlay) {
            // Play the channel
            [self playChannelWithUrl:channelToPlay.url];
            
            // Find the index of this channel in the current group to update selectedChannelIndex
            NSInteger channelIndex = [self findChannelIndexForChannel:channelToPlay];
            if (channelIndex >= 0) {
                self.selectedChannelIndex = channelIndex;
                NSLog(@"Updated selectedChannelIndex to: %ld for channel: %@", (long)channelIndex, channelToPlay.name);
            } else {
                NSLog(@"Warning: Could not find channel index for: %@", channelToPlay.name);
            }
            
            // Refresh the EPG information and update the display
            [self refreshCurrentEPGInfo];
            
            // Force redraw to update the program control panel
            [self setNeedsDisplay:YES];
        }
        
        // Clear the stored references
        rightClickedProgram = nil;
        rightClickedProgramChannel = nil;
    }
}

// Helper method to find the index of a channel in the current group
- (NSInteger)findChannelIndexForChannel:(VLCChannel *)targetChannel {
    if (!targetChannel) {
        return -1;
    }
    
    // Get the current group's channels
    NSArray *groups = nil;
    NSString *currentCategory = nil;
    
    if (self.selectedCategoryIndex >= 0 && self.selectedCategoryIndex < self.categories.count) {
        currentCategory = [self.categories objectAtIndex:self.selectedCategoryIndex];
        
        if ([currentCategory isEqualToString:@"FAVORITES"]) {
            groups = [self safeGroupsForCategory:@"FAVORITES"];
        } else if ([currentCategory isEqualToString:@"TV"]) {
            groups = [self safeTVGroups];
        } else if ([currentCategory isEqualToString:@"MOVIES"]) {
            groups = [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
        } else if ([currentCategory isEqualToString:@"SERIES"]) {
            groups = [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
        }
    }
    
    // Get the current group
    if (groups && self.selectedGroupIndex >= 0 && self.selectedGroupIndex < groups.count) {
        NSString *currentGroup = [groups objectAtIndex:self.selectedGroupIndex];
        
        // Get channels for this group
        NSArray *channelsInGroup = [self.channelsByGroup objectForKey:currentGroup];
        if (channelsInGroup) {
            // Find the target channel in this group
            for (NSInteger i = 0; i < channelsInGroup.count; i++) {
                VLCChannel *channel = [channelsInGroup objectAtIndex:i];
                if ([channel.url isEqualToString:targetChannel.url] || 
                    [channel.name isEqualToString:targetChannel.name]) {
                    return i;
                }
            }
        }
    }
    
    return -1;
}

- (void)drawThemeSettings:(NSRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 30;
    CGFloat startY = self.bounds.size.height - 80;
    CGFloat controlWidth = width - (padding * 2);
    CGFloat yOffset = 0;
    CGFloat controlHeight = 35;
    CGFloat verticalSpacing = 25;
    
    // Draw a section title
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:18],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect titleRect = NSMakeRect(x + padding, startY, controlWidth, 25);
    [@"Theme Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    // Draw Theme Selector
    yOffset += 45;
    NSRect themeLabelRect = NSMakeRect(x + padding, startY - yOffset, 100, 20);
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    [@"Theme:" drawInRect:themeLabelRect withAttributes:labelAttrs];
    
    // Theme dropdown button
    self.themeDropdownRect = NSMakeRect(x + padding + 110, startY - yOffset, controlWidth - 120, controlHeight);
    
    // Draw theme dropdown
    [self drawDropdownButton:self.themeDropdownRect 
                        text:[self getCurrentThemeDisplayText]
                  identifier:@"theme"];
    
    yOffset += controlHeight + verticalSpacing;
    
    // Show RGB sliders only when Custom theme is selected
    if (self.currentTheme == VLC_THEME_CUSTOM) {
        // Red slider
        NSRect redRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
        NSString *redDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customThemeRed * 255)];
        
        NSRect redSliderInteractionRect;
        [VLCSliderControl drawSlider:redRect
                              label:@"Red:"
                           minValue:0.0
                           maxValue:1.0
                       currentValue:self.customThemeRed
                        labelColor:self.textColor
                        sliderRect:&redSliderInteractionRect
                       displayText:redDisplayText];
        self.redSliderRect = redSliderInteractionRect;
        
        yOffset += controlHeight + verticalSpacing;
        
        // Green slider
        NSRect greenRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
        NSString *greenDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customThemeGreen * 255)];
        
        NSRect greenSliderInteractionRect;
        [VLCSliderControl drawSlider:greenRect
                              label:@"Green:"
                           minValue:0.0
                           maxValue:1.0
                       currentValue:self.customThemeGreen
                        labelColor:self.textColor
                        sliderRect:&greenSliderInteractionRect
                       displayText:greenDisplayText];
        self.greenSliderRect = greenSliderInteractionRect;
        
        yOffset += controlHeight + verticalSpacing;
        
        // Blue slider
        NSRect blueRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
        NSString *blueDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customThemeBlue * 255)];
        
        NSRect blueSliderInteractionRect;
        [VLCSliderControl drawSlider:blueRect
                              label:@"Blue:"
                           minValue:0.0
                           maxValue:1.0
                       currentValue:self.customThemeBlue
                        labelColor:self.textColor
                        sliderRect:&blueSliderInteractionRect
                       displayText:blueDisplayText];
        self.blueSliderRect = blueSliderInteractionRect;
        
        yOffset += controlHeight + verticalSpacing;
    }
    
    // Add a section separator for Selection Colors
    yOffset += 15;
    NSRect selectionSectionRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, 25);
    NSDictionary *sectionAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    [@"Selection Colors" drawInRect:selectionSectionRect withAttributes:sectionAttrs];
    yOffset += 35;
    
    // Selection Color RGB sliders (always shown)
    // Selection Red slider
    NSRect selectionRedRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
    NSString *selectionRedDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customSelectionRed * 255)];
    
    NSRect selectionRedSliderInteractionRect;
    [VLCSliderControl drawSlider:selectionRedRect
                          label:@"Selection Red:"
                       minValue:0.0
                       maxValue:1.0
                   currentValue:self.customSelectionRed
                    labelColor:self.textColor
                    sliderRect:&selectionRedSliderInteractionRect
                   displayText:selectionRedDisplayText];
    self.selectionRedSliderRect = selectionRedSliderInteractionRect;
    
    yOffset += controlHeight + verticalSpacing;
    
    // Selection Green slider
    NSRect selectionGreenRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
    NSString *selectionGreenDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customSelectionGreen * 255)];
    
    NSRect selectionGreenSliderInteractionRect;
    [VLCSliderControl drawSlider:selectionGreenRect
                          label:@"Selection Green:"
                       minValue:0.0
                       maxValue:1.0
                   currentValue:self.customSelectionGreen
                    labelColor:self.textColor
                    sliderRect:&selectionGreenSliderInteractionRect
                   displayText:selectionGreenDisplayText];
    self.selectionGreenSliderRect = selectionGreenSliderInteractionRect;
    
    yOffset += controlHeight + verticalSpacing;
    
    // Selection Blue slider
    NSRect selectionBlueRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
    NSString *selectionBlueDisplayText = [NSString stringWithFormat:@"%d", (int)(self.customSelectionBlue * 255)];
    
    NSRect selectionBlueSliderInteractionRect;
    [VLCSliderControl drawSlider:selectionBlueRect
                          label:@"Selection Blue:"
                       minValue:0.0
                       maxValue:1.0
                   currentValue:self.customSelectionBlue
                    labelColor:self.textColor
                    sliderRect:&selectionBlueSliderInteractionRect
                   displayText:selectionBlueDisplayText];
    self.selectionBlueSliderRect = selectionBlueSliderInteractionRect;
    
    yOffset += controlHeight + verticalSpacing;
    
    // Draw Transparency Slider (always shown)
    NSRect transparencyRect = NSMakeRect(x + padding, startY - yOffset, controlWidth, controlHeight);
    
    // Convert transparency level to continuous slider value (0.5 to 0.95)
    CGFloat currentValue = self.themeAlpha;
    NSString *displayText = [NSString stringWithFormat:@"%.0f%%", currentValue * 100];
    
    // Use a local variable to store the slider rect for interaction
    NSRect sliderInteractionRect;
    [VLCSliderControl drawSlider:transparencyRect
                          label:@"Transparency:"
                       minValue:0.0
                       maxValue:1.0
                   currentValue:currentValue
                    labelColor:self.textColor
                    sliderRect:&sliderInteractionRect
                   displayText:displayText];
    
    // Store the slider rect in the property for later use
    self.transparencySliderRect = sliderInteractionRect;
    
    [style release];
}

- (void)drawDropdownButton:(NSRect)rect text:(NSString *)text identifier:(NSString *)identifier {
    // Check if this dropdown is open
    VLCDropdown *dropdown = [self.dropdownManager dropdownWithIdentifier:identifier];
    BOOL isOpen = dropdown && dropdown.isOpen;
    
    // Draw button background
    NSColor *bgColor = isOpen ? self.hoverColor : self.backgroundColor;
    [bgColor set];
    NSBezierPath *bgPath = [NSBezierPath bezierPathWithRoundedRect:rect xRadius:3 yRadius:3];
    [bgPath fill];
    
    // Draw border
    [self.textColor set];
    [bgPath stroke];
    
    // Draw text
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *attrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:14],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: style
    };
    
    NSRect textRect = NSMakeRect(rect.origin.x + 8,
                                rect.origin.y + (rect.size.height - 16) / 2,
                                rect.size.width - 28,
                                16);
    [text drawInRect:textRect withAttributes:attrs];
    
    // Draw dropdown arrow
    NSRect arrowRect = NSMakeRect(rect.origin.x + rect.size.width - 20,
                                 rect.origin.y + (rect.size.height - 10) / 2,
                                 10, 10);
    [[NSColor lightGrayColor] set];
    NSBezierPath *arrowPath = [NSBezierPath bezierPath];
    if (isOpen) {
        // Up arrow when dropdown is open
        [arrowPath moveToPoint:NSMakePoint(arrowRect.origin.x, arrowRect.origin.y)];
        [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width/2, arrowRect.origin.y + arrowRect.size.height)];
        [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width, arrowRect.origin.y)];
    } else {
        // Down arrow when dropdown is closed
        [arrowPath moveToPoint:NSMakePoint(arrowRect.origin.x, arrowRect.origin.y + arrowRect.size.height)];
        [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width/2, arrowRect.origin.y)];
        [arrowPath lineToPoint:NSMakePoint(arrowRect.origin.x + arrowRect.size.width, arrowRect.origin.y + arrowRect.size.height)];
    }
    [arrowPath closePath];
    [arrowPath fill];
    
    [style release];
}

- (NSString *)getCurrentThemeDisplayText {
    switch (self.currentTheme) {
        case VLC_THEME_DARK: return @"Dark";
        case VLC_THEME_DARKER: return @"Darker";
        case VLC_THEME_BLUE: return @"Blue";
        case VLC_THEME_GREEN: return @"Green";
        case VLC_THEME_PURPLE: return @"Purple";
        case VLC_THEME_CUSTOM: return @"Custom";
        default: return @"Dark";
    }
}

- (NSString *)getCurrentTransparencyDisplayText {
    switch (self.transparencyLevel) {
        case VLC_TRANSPARENCY_OPAQUE: return @"Opaque";
        case VLC_TRANSPARENCY_LIGHT: return @"Light";
        case VLC_TRANSPARENCY_MEDIUM: return @"Medium";
        case VLC_TRANSPARENCY_HIGH: return @"High";
        case VLC_TRANSPARENCY_VERY_HIGH: return @"Very High";
        default: return @"Medium";
    }
}

- (void)setupThemeDropdowns {
    if (!self.dropdownManager) {
        return;
    }
    
    // Create theme dropdown
    VLCDropdown *themeDropdown = [self.dropdownManager createDropdownWithIdentifier:@"theme" frame:self.themeDropdownRect];
    [themeDropdown addItemWithValue:@(VLC_THEME_DARK) displayText:@"Dark"];
    [themeDropdown addItemWithValue:@(VLC_THEME_DARKER) displayText:@"Darker"];
    [themeDropdown addItemWithValue:@(VLC_THEME_BLUE) displayText:@"Blue"];
    [themeDropdown addItemWithValue:@(VLC_THEME_GREEN) displayText:@"Green"];
    [themeDropdown addItemWithValue:@(VLC_THEME_PURPLE) displayText:@"Purple"];
    [themeDropdown addItemWithValue:@(VLC_THEME_CUSTOM) displayText:@"Custom"];
    themeDropdown.selectedIndex = self.currentTheme;
    
    // Set theme dropdown callback
    themeDropdown.onSelectionChanged = ^(VLCDropdown *dropdown, VLCDropdownItem *selectedItem, NSInteger index) {
        VLCColorTheme newTheme = [selectedItem.value integerValue];
        NSLog(@"Theme changed to: %@ (%ld)", selectedItem.displayText, (long)newTheme);
        [self applyTheme:newTheme];
        [self setNeedsDisplay:YES];
    };
    
    // Create transparency slider
    CGFloat currentValue = [self alphaForTransparencyLevel:self.transparencyLevel];
    NSString *displayText = [NSString stringWithFormat:@"%.0f%%", currentValue * 100];
    
    NSRect sliderInteractionRect;
    [VLCSliderControl drawSlider:self.transparencyDropdownRect
                          label:@"Transparency:"
                       minValue:0.0
                       maxValue:1.0
                   currentValue:currentValue
                    labelColor:self.textColor
                    sliderRect:&sliderInteractionRect
                   displayText:displayText];
    
    self.transparencySliderRect = sliderInteractionRect;
}

- (void)handleThemeDropdownClick:(NSPoint)point {
    if (NSPointInRect(point, self.themeDropdownRect)) {
        VLCDropdown *dropdown = [self.dropdownManager dropdownWithIdentifier:@"theme"];
        if (dropdown) {
            if (dropdown.isOpen) {
                [self.dropdownManager hideDropdown:@"theme"];
                } else {
                // Update dropdown frame to current position
                dropdown.frame = self.themeDropdownRect;
                [self.dropdownManager showDropdown:@"theme"];
            }
        } else {
            [self setupThemeDropdowns];
            [self.dropdownManager showDropdown:@"theme"];
        }
    }
}

#pragma mark - Theme Controls Management

- (void)showThemeControls {
    // Setup theme dropdowns when in theme settings
    [self setupThemeDropdowns];
}

- (void)hideThemeControls {
    // Hide theme dropdowns when not in theme settings
    if (self.dropdownManager) {
        [self.dropdownManager hideDropdown:@"theme"];
    }
}

- (void)updateUIComponentsVisibility {
    BOOL isSettingsVisible = (self.selectedCategoryIndex == CATEGORY_SETTINGS);
    BOOL isSearchVisible = (self.selectedCategoryIndex == CATEGORY_SEARCH);
    BOOL isThemeGroupSelected = NO;
    
    if (isSettingsVisible) {
        // Check if Themes group is selected
        NSArray *settingsGroups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        if (self.selectedGroupIndex >= 0 && self.selectedGroupIndex < [settingsGroups count]) {
            NSString *selectedGroup = [settingsGroups objectAtIndex:self.selectedGroupIndex];
            isThemeGroupSelected = [selectedGroup isEqualToString:@"Themes"];
        }
    }
    
    // Manage search textfield visibility
    if (isSearchVisible) {
        // Force a redraw to show the search interface
        [self setNeedsDisplay:YES];
    } else {
        if (self.searchTextField) {
            [self.searchTextField setHidden:YES];
            [self.searchTextField deactivateField];
        }
        
        // Clear search results when leaving search mode
        if (self.isSearchActive) {
            self.searchResults = [NSMutableArray array];
            self.isSearchActive = NO;
            [self setNeedsDisplay:YES];
        }
    }
    
    // Manage theme controls visibility
    if (isThemeGroupSelected) {
        [self showThemeControls];
    } else {
        [self hideThemeControls];
    }
    
    // Handle other UI components visibility as before
    BOOL shouldShowTextField = (self.selectedCategoryIndex == CATEGORY_SETTINGS && 
                               self.selectedGroupIndex >= 0);
    
    // Existing text field management code...
    if (shouldShowTextField) {
        NSArray *settingsGroups = [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
        if (self.selectedGroupIndex < [settingsGroups count]) {
            NSString *selectedGroup = [settingsGroups objectAtIndex:self.selectedGroupIndex];
            
            if ([selectedGroup isEqualToString:@"Playlist"]) {
                // Show playlist-related UI components
                if (self.m3uTextField && ![self.subviews containsObject:self.m3uTextField]) {
                    [self addSubview:self.m3uTextField];
                }
                if (self.epgLabel && ![self.subviews containsObject:self.epgLabel]) {
                    [self addSubview:self.epgLabel];
                }
                
                [self.m3uTextField setHidden:NO];
                [self.epgLabel setHidden:NO];
            } else {
                // Hide playlist-related UI components for other settings groups
                [self.m3uTextField setHidden:YES];
                [self.epgLabel setHidden:YES];
            }
        }
    } else {
        // Hide all text components when not in settings
        [self.m3uTextField setHidden:YES];
        [self.epgLabel setHidden:YES];
    }
}
#pragma mark - Stacked View Drawing

- (void)drawStackedView:(NSRect)rect {
    CGFloat catWidth = 200;
    CGFloat groupWidth = 250;
    CGFloat stackedViewX = catWidth + groupWidth;
    CGFloat stackedViewWidth = self.bounds.size.width - stackedViewX;
    CGFloat rowHeight = 400; // Reduced height for better fit - can show more movies
    
    // Draw background using theme colors
    NSRect stackedRect = NSMakeRect(stackedViewX, 0, stackedViewWidth, self.bounds.size.height);
    NSGradient *backgroundGradient = [[NSGradient alloc] initWithStartingColor:self.themeChannelStartColor ? self.themeChannelStartColor : [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.7]
                                                                   endingColor:self.themeChannelEndColor ? self.themeChannelEndColor : [NSColor colorWithCalibratedRed:0.12 green:0.14 blue:0.18 alpha:0.7]];
    [backgroundGradient drawInRect:stackedRect angle:90];
    [backgroundGradient release];
    
    // Get current movies for the selected group
    NSArray *moviesInCurrentGroup = [self getChannelsForCurrentGroup];
    
    if (!moviesInCurrentGroup || moviesInCurrentGroup.count == 0) {
        // No movies to display
        NSString *message = @"No movies available in this group";
        NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
        [style setAlignment:NSTextAlignmentCenter];
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [NSFont systemFontOfSize:16],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: style
        };
        
        NSRect messageRect = NSMakeRect(stackedViewX, self.bounds.size.height/2 - 10, stackedViewWidth, 20);
        [message drawInRect:messageRect withAttributes:attrs];
        [style release];
        return;
    }
    
    // Calculate total content height for scrolling
    CGFloat totalContentHeight = moviesInCurrentGroup.count * rowHeight;
    
    // Add extra space at bottom to ensure last item is fully visible when scrolled to the end
    totalContentHeight += rowHeight;
    
    // Update scroll limits to ensure last item is fully visible
    CGFloat maxScroll = MAX(0, totalContentHeight - stackedRect.size.height);
    CGFloat scrollPosition = MIN(channelScrollPosition, maxScroll); // Reuse channelScrollPosition for stacked view
    
    // Calculate minimum number of visible rows (at least 4)
    NSInteger minVisibleRows = 4;
    CGFloat requiredHeight = minVisibleRows * rowHeight;
    if (stackedRect.size.height < requiredHeight) {
        // If window is too small, adjust row height to fit at least 4 rows
        rowHeight = MAX(80, stackedRect.size.height / minVisibleRows); // Minimum 80px per row
        
        // Recalculate content height with adjusted row height for accurate scroll bar
        totalContentHeight = moviesInCurrentGroup.count * rowHeight;
        totalContentHeight += rowHeight; // Add extra space
        maxScroll = MAX(0, totalContentHeight - stackedRect.size.height);
        scrollPosition = MIN(channelScrollPosition, maxScroll);
    }
    
    // Draw each movie row
    for (NSInteger i = 0; i < moviesInCurrentGroup.count; i++) {
        VLCChannel *movie = [moviesInCurrentGroup objectAtIndex:i];
        
        // Calculate smooth position with correct scroll direction
        // Position movies from bottom to top, with proper scroll offset
        CGFloat movieYPosition = stackedRect.size.height - ((i + 1) * rowHeight) + scrollPosition;
        
        // Position the movie row
        NSRect itemRect = NSMakeRect(stackedViewX, 
                                     movieYPosition, 
                                     stackedViewWidth, 
                                     rowHeight);
        
        // Skip drawing if completely outside visible area
        if (itemRect.origin.y + itemRect.size.height < 0 || 
            itemRect.origin.y > stackedRect.size.height) {
            continue;
        }
        
        // Clip to visible area for smooth scrolling
        NSRect clippedRect = NSIntersectionRect(itemRect, stackedRect);
        if (NSIsEmptyRect(clippedRect)) {
            continue;
        }
        
        // ONLY load cached poster image for visible movies (after visibility check)
        if ([movie.category isEqualToString:@"MOVIES"] && !movie.cachedPosterImage) {
            [self loadCachedPosterImageForChannel:movie];
        }
        
        // Draw row background and selection state
        if (i == self.selectedChannelIndex) {
            // Selected movie - use exact same style as categories/groups
            NSBezierPath *selectionPath = [NSBezierPath bezierPathWithRoundedRect:
                                         NSInsetRect(clippedRect, 4, 2)
                                                                         xRadius:6
                                                                         yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.3] set];
            [selectionPath fill];
            
            // Add subtle highlight - exact same as categories/groups
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.2] set];
            [selectionPath stroke];
        } else if (i == self.hoveredChannelIndex) {
            // Hovered movie - use exact same style as categories/groups
            NSBezierPath *hoverPath = [NSBezierPath bezierPathWithRoundedRect:
                                     NSInsetRect(clippedRect, 4, 2)
                                                                     xRadius:6
                                                                     yRadius:6];
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.25] set];
            [hoverPath fill];
            
            // Add subtle highlight - exact same as categories/groups
            [[NSColor colorWithCalibratedRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.15] set];
            [hoverPath stroke];
        }
        
        // Draw border around each movie row
        [[NSColor colorWithCalibratedWhite:0.4 alpha:0.6] set];
        NSBezierPath *borderPath = [NSBezierPath bezierPathWithRoundedRect:NSInsetRect(clippedRect, 2, 2) xRadius:4 yRadius:4];
        [borderPath setLineWidth:1.0];
        [borderPath stroke];
        
        // Calculate layout dimensions using original itemRect for positioning
        // Movie poster aspect ratio is typically 2:3 (width:height)
        CGFloat posterHeight = rowHeight - 10; // Leave some padding
        CGFloat posterAspectRatio = 2.0 / 3.0; // Standard movie poster ratio
        CGFloat posterWidth = posterHeight * posterAspectRatio; // Calculate width to maintain aspect ratio
        CGFloat posterX = itemRect.origin.x + 10;
        CGFloat posterY = itemRect.origin.y + 5;
        
        CGFloat textAreaX = posterX + posterWidth + 15;
        CGFloat textAreaWidth = itemRect.size.width - posterWidth - 30;
        
        // Draw movie poster
        NSRect posterRect = NSMakeRect(posterX, posterY, posterWidth, posterHeight);
        
        // Only draw poster if it intersects with visible area
        if (NSIntersectsRect(posterRect, clippedRect)) {
            if (movie.cachedPosterImage) {
                // Draw the actual poster image
                [[NSColor colorWithCalibratedWhite:0.2 alpha:0.8] set];
                NSBezierPath *posterBg = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:4 yRadius:4];
                [posterBg fill];
                
                NSRect imageRect = NSInsetRect(posterRect, 2, 2);
                [movie.cachedPosterImage drawInRect:imageRect 
                                           fromRect:NSZeroRect 
                                          operation:NSCompositeSourceOver 
                                           fraction:1.0 
                                    respectFlipped:YES 
                                             hints:nil];
            } else {
                // Draw placeholder
                [[NSColor colorWithCalibratedWhite:0.3 alpha:0.8] set];
                NSBezierPath *placeholderPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:4 yRadius:4];
                [placeholderPath fill];
                
                // Draw "No Image" text
                NSMutableParagraphStyle *placeholderStyle = [[NSMutableParagraphStyle alloc] init];
                [placeholderStyle setAlignment:NSTextAlignmentCenter];
                
                NSDictionary *placeholderAttrs = @{
                    NSFontAttributeName: [NSFont systemFontOfSize:10],
                    NSForegroundColorAttributeName: [NSColor lightGrayColor],
                    NSParagraphStyleAttributeName: placeholderStyle
                };
                
                [@"No Image" drawInRect:posterRect withAttributes:placeholderAttrs];
                [placeholderStyle release];
                
                // Try to load the image if available and not already loading
                if (movie.logo && !objc_getAssociatedObject(movie, "imageLoadingInProgress")) {
                    [self loadImageAsynchronously:movie.logo forChannel:movie];
                }
            }
        }
        
        // Draw movie details in the text area
        CGFloat currentY = itemRect.origin.y + itemRect.size.height - 40;
        CGFloat lineHeight = 16;
        
        // Movie title (larger, bold)
        NSString *movieTitle = movie.name ? movie.name : @"Unknown Movie";
        NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
        [titleStyle setAlignment:NSTextAlignmentLeft];
        [titleStyle setLineBreakMode:NSLineBreakByTruncatingTail];
        
        NSDictionary *titleAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:16],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: titleStyle
        };
        
        NSRect titleRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight + 2);
        // Only draw title if it's visible in the clipped area
        if (NSIntersectsRect(titleRect, clippedRect)) {
            [movieTitle drawInRect:titleRect withAttributes:titleAttrs];
        }
        [titleStyle release];
        currentY -= (lineHeight + 5);
        
        // Show movie info if loaded
        if (movie.hasLoadedMovieInfo) {
            // Year and Genre on same line
            NSMutableString *yearGenre = [NSMutableString string];
            if (movie.movieYear && movie.movieYear.length > 0) {
                [yearGenre appendString:movie.movieYear];
            }
            if (movie.movieGenre && movie.movieGenre.length > 0) {
                if (yearGenre.length > 0) [yearGenre appendString:@" ‚Ä¢ "];
                [yearGenre appendString:movie.movieGenre];
            }
            
            if (yearGenre.length > 0) {
                NSRect yearGenreRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
                if (NSIntersectsRect(yearGenreRect, clippedRect)) {
                    [self drawCompactText:yearGenre inRect:yearGenreRect];
                }
                currentY -= lineHeight;
            }
            
            // Director
            if (movie.movieDirector && movie.movieDirector.length > 0) {
                NSString *directorText = [NSString stringWithFormat:@"Director: %@", movie.movieDirector];
                NSRect directorRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
                if (NSIntersectsRect(directorRect, clippedRect)) {
                    [self drawCompactText:directorText inRect:directorRect];
                }
                currentY -= lineHeight;
            }
            
            // Rating and Duration on same line with stars
            NSMutableString *ratingDuration = [NSMutableString string];
            if (movie.movieRating && movie.movieRating.length > 0) {
                // Convert rating to stars (assuming rating is out of 10)
                NSString *stars = [self convertRatingToStars:movie.movieRating];
                [ratingDuration appendString:[NSString stringWithFormat:@"‚òÖ %@ %@", movie.movieRating, stars]];
            }
            if (movie.movieDuration && movie.movieDuration.length > 0) {
                if (ratingDuration.length > 0) [ratingDuration appendString:@" ‚Ä¢ "];
                [ratingDuration appendString:[NSString stringWithFormat:@"‚è± %@", movie.movieDuration]];
            }
            
            if (ratingDuration.length > 0) {
                NSRect ratingDurationRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
                if (NSIntersectsRect(ratingDurationRect, clippedRect)) {
                    [self drawHighlightedText:ratingDuration inRect:ratingDurationRect];
                }
                currentY -= lineHeight;
            }
            
            // Short description if space allows - with improved styling
            if (movie.movieDescription && movie.movieDescription.length > 0 && currentY > itemRect.origin.y + 5) {
                NSString *shortDescription = movie.movieDescription;
                // Truncate description to fit in remaining space
                if (shortDescription.length > 150) {
                    shortDescription = [[shortDescription substringToIndex:147] stringByAppendingString:@"..."];
                }
                
                NSMutableParagraphStyle *descStyle = [[NSMutableParagraphStyle alloc] init];
                [descStyle setAlignment:NSTextAlignmentLeft];
                [descStyle setLineBreakMode:NSLineBreakByWordWrapping];
                [descStyle setLineSpacing:2.0]; // Add line spacing for better readability
                
                NSDictionary *descAttrs = @{
                    NSFontAttributeName: [NSFont systemFontOfSize:14],
                    NSForegroundColorAttributeName: [NSColor colorWithCalibratedWhite:0.9 alpha:1.0], // Brighter text
                    NSParagraphStyleAttributeName: descStyle,
                    NSShadowAttributeName: ({
                        NSShadow *shadow = [[NSShadow alloc] init];
                        shadow.shadowColor = [NSColor colorWithCalibratedWhite:0.0 alpha:0.6];
                        shadow.shadowOffset = NSMakeSize(0, -1);
                        shadow.shadowBlurRadius = 1;
                        shadow;
                    })
                };
                
                NSRect descRect = NSMakeRect(textAreaX, itemRect.origin.y + 10, textAreaWidth, currentY - itemRect.origin.y - 15);
                if (NSIntersectsRect(descRect, clippedRect)) {
                    [shortDescription drawInRect:descRect withAttributes:descAttrs];
                }
                [descStyle release];
                [descAttrs[NSShadowAttributeName] release];
            }
        } else {
            // Movie info not loaded yet
            NSRect loadingRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
            if (NSIntersectsRect(loadingRect, clippedRect)) {
                [self drawCompactText:@"Loading movie information..." 
                               inRect:loadingRect];
            }
            
            // Movie info loading is now handled by the preloading system
            // which uses accurate visibility detection and improved caching logic
        }
    }
    
    // Draw scroll indicator if content is scrollable
    if (totalContentHeight > stackedRect.size.height) {
        [self drawScrollBar:stackedRect contentHeight:totalContentHeight scrollPosition:scrollPosition];
    }
    
    // Draw navigation hint at bottom
    NSString *navigationHint = @"Use ‚Üë‚Üì keys to browse movies, Press Enter to play";
    NSMutableParagraphStyle *hintStyle = [[NSMutableParagraphStyle alloc] init];
    [hintStyle setAlignment:NSTextAlignmentCenter];
    
    NSDictionary *hintAttrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor darkGrayColor],
        NSParagraphStyleAttributeName: hintStyle
    };
    
    NSRect hintRect = NSMakeRect(stackedViewX, 5, stackedViewWidth, 15);
    [navigationHint drawInRect:hintRect withAttributes:hintAttrs];
    [hintStyle release];
}

- (void)drawSearchMovieResults:(NSRect)rect {
    if (!self.searchMovieResults || [self.searchMovieResults count] == 0) {
        return;
    }
    
    CGFloat rowHeight = 120; // Smaller rows for search results
    
    // Draw background using theme colors with proper alpha handling
    NSColor *searchBackgroundStartColor, *searchBackgroundEndColor;
    if (self.themeChannelStartColor && self.themeChannelEndColor) {
        // Use theme colors with proper alpha adjustment for search results
        CGFloat searchAlpha = self.themeAlpha * 0.9; // Slightly more opaque for search results
        searchBackgroundStartColor = [self.themeChannelStartColor colorWithAlphaComponent:searchAlpha];
        searchBackgroundEndColor = [self.themeChannelEndColor colorWithAlphaComponent:searchAlpha];
    } else {
        // Fallback colors consistent with theme system defaults
        searchBackgroundStartColor = [NSColor colorWithCalibratedRed:0.08 green:0.10 blue:0.14 alpha:0.9];
        searchBackgroundEndColor = [NSColor colorWithCalibratedRed:0.10 green:0.12 blue:0.16 alpha:0.8];
    }
    
    NSGradient *backgroundGradient = [[NSGradient alloc] initWithStartingColor:searchBackgroundStartColor
                                                                   endingColor:searchBackgroundEndColor];
    [backgroundGradient drawInRect:rect angle:90];
    [backgroundGradient release];

    /*
    // Draw section header
    NSString *headerText = [NSString stringWithFormat:@"Movies/Series Found (%lu)", (unsigned long)[self.searchMovieResults count]];
    NSMutableParagraphStyle *headerStyle = [[NSMutableParagraphStyle alloc] init];
    [headerStyle setAlignment:NSTextAlignmentLeft];
    
    NSDictionary *headerAttrs = @{
        NSFontAttributeName: [NSFont boldSystemFontOfSize:14],
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName: headerStyle
    };
    
    NSRect headerRect = NSMakeRect(rect.origin.x + 10, rect.origin.y + rect.size.height - 25, rect.size.width - 20, 20);
    [headerText drawInRect:headerRect withAttributes:headerAttrs];
    [headerStyle release];
    */
    // Calculate scrollable content area
    NSRect contentRect = NSMakeRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height - 30);
    CGFloat totalContentHeight = [self.searchMovieResults count] * rowHeight;
    
    // Use dedicated scroll position for movie results
    CGFloat maxScroll = MAX(0, totalContentHeight - contentRect.size.height);
    CGFloat scrollPosition = MIN(self.searchMovieScrollPosition, maxScroll);
    
    // Draw each movie result
    for (NSInteger i = 0; i < [self.searchMovieResults count]; i++) {
        VLCChannel *movie = [self.searchMovieResults objectAtIndex:i];
        
        // Calculate position with scroll offset
        CGFloat movieYPosition = contentRect.origin.y + contentRect.size.height - ((i + 1) * rowHeight) + scrollPosition;
        
        NSRect itemRect = NSMakeRect(contentRect.origin.x, movieYPosition, contentRect.size.width, rowHeight);
        
        // Skip drawing if completely outside visible area
        if (itemRect.origin.y + itemRect.size.height < contentRect.origin.y || 
            itemRect.origin.y > contentRect.origin.y + contentRect.size.height) {
            continue;
        }
        
        // Clip to visible area
        NSRect clippedRect = NSIntersectionRect(itemRect, contentRect);
        if (NSIsEmptyRect(clippedRect)) {
            continue;
        }
        
        // Draw row background using theme-appropriate colors
        NSColor *rowBackgroundColor;
        if (self.themeChannelStartColor) {
            // Use a lighter version of the theme color for individual rows
            CGFloat rowAlpha = self.themeAlpha * 0.6;
            rowBackgroundColor = [self.themeChannelStartColor colorWithAlphaComponent:rowAlpha];
        } else {
            // Fallback to default
            rowBackgroundColor = [NSColor colorWithCalibratedWhite:0.15 alpha:0.6];
        }
        [rowBackgroundColor set];
        NSRectFill(clippedRect);
        
        // Draw border using theme-appropriate colors
        NSColor *borderColor;
        if (self.themeChannelEndColor) {
            // Use theme end color with reduced alpha for borders
            CGFloat borderAlpha = self.themeAlpha * 0.4;
            borderColor = [self.themeChannelEndColor colorWithAlphaComponent:borderAlpha];
        } else {
            // Fallback to default
            borderColor = [NSColor colorWithCalibratedWhite:0.4 alpha:0.4];
        }
        [borderColor set];
        NSBezierPath *borderPath = [NSBezierPath bezierPathWithRoundedRect:NSInsetRect(clippedRect, 1, 1) xRadius:3 yRadius:3];
        [borderPath setLineWidth:0.5];
        [borderPath stroke];
        
        // Calculate layout dimensions
        CGFloat posterHeight = rowHeight - 10;
        CGFloat posterWidth = posterHeight * (2.0 / 3.0); // Movie poster aspect ratio
        CGFloat posterX = itemRect.origin.x + 8;
        CGFloat posterY = itemRect.origin.y + 5;
        
        CGFloat textAreaX = posterX + posterWidth + 10;
        CGFloat textAreaWidth = itemRect.size.width - posterWidth - 25;
        
        // Draw movie poster
        NSRect posterRect = NSMakeRect(posterX, posterY, posterWidth, posterHeight);
        
        if (NSIntersectsRect(posterRect, clippedRect)) {
            if (movie.cachedPosterImage) {
                // Use theme-appropriate background for poster area
                NSColor *posterBgColor;
                if (self.themeChannelStartColor) {
                    CGFloat posterBgAlpha = self.themeAlpha * 0.8;
                    posterBgColor = [self.themeChannelStartColor colorWithAlphaComponent:posterBgAlpha];
                } else {
                    posterBgColor = [NSColor colorWithCalibratedWhite:0.2 alpha:0.8];
                }
                [posterBgColor set];
                NSBezierPath *posterBg = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:3 yRadius:3];
                [posterBg fill];
                
                NSRect imageRect = NSInsetRect(posterRect, 1, 1);
                [movie.cachedPosterImage drawInRect:imageRect 
                                           fromRect:NSZeroRect 
                                          operation:NSCompositeSourceOver 
                                           fraction:1.0 
                                    respectFlipped:YES 
                                             hints:nil];
            } else {
                // Draw placeholder with theme-appropriate color
                NSColor *placeholderColor;
                if (self.themeChannelStartColor) {
                    CGFloat placeholderAlpha = self.themeAlpha * 0.25;
                    placeholderColor = [self.themeChannelStartColor colorWithAlphaComponent:placeholderAlpha];
                } else {
                    placeholderColor = [NSColor colorWithCalibratedWhite:0.25 alpha:0.8];
                }
                [placeholderColor set];
                NSBezierPath *placeholderPath = [NSBezierPath bezierPathWithRoundedRect:posterRect xRadius:3 yRadius:3];
                [placeholderPath fill];
                
                // Load image if available
                if (movie.logo && !objc_getAssociatedObject(movie, "imageLoadingInProgress")) {
                    [self loadImageAsynchronously:movie.logo forChannel:movie];
                }
            }
        }
        
        // Draw movie information in text area
        CGFloat currentY = itemRect.origin.y + itemRect.size.height - 20;
        CGFloat lineHeight = 14;
        
        // Movie title
        NSString *movieTitle = movie.name ? movie.name : @"Unknown Movie";
        NSMutableParagraphStyle *titleStyle = [[NSMutableParagraphStyle alloc] init];
        [titleStyle setAlignment:NSTextAlignmentLeft];
        [titleStyle setLineBreakMode:NSLineBreakByTruncatingTail];
        
        NSDictionary *titleAttrs = @{
            NSFontAttributeName: [NSFont boldSystemFontOfSize:13],
            NSForegroundColorAttributeName: self.textColor,
            NSParagraphStyleAttributeName: titleStyle
        };
        
        NSRect titleRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
        if (NSIntersectsRect(titleRect, clippedRect)) {
            [movieTitle drawInRect:titleRect withAttributes:titleAttrs];
        }
        [titleStyle release];
        currentY -= (lineHeight + 2);
        
        // Group name (where it was found)
        if (movie.group && [movie.group length] > 0) {
            NSString *groupText = [NSString stringWithFormat:@"From: %@", movie.group];
            NSRect groupRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
            if (NSIntersectsRect(groupRect, clippedRect)) {
                [self drawCompactText:groupText inRect:groupRect];
            }
            currentY -= lineHeight;
        }
        
        // Movie details if loaded
        if (movie.hasLoadedMovieInfo) {
            // Year and Genre
            NSMutableString *yearGenre = [NSMutableString string];
            if (movie.movieYear && movie.movieYear.length > 0) {
                [yearGenre appendString:movie.movieYear];
            }
            if (movie.movieGenre && movie.movieGenre.length > 0) {
                if (yearGenre.length > 0) [yearGenre appendString:@" ‚Ä¢ "];
                [yearGenre appendString:movie.movieGenre];
            }
            
            if (yearGenre.length > 0) {
                NSRect yearGenreRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
                if (NSIntersectsRect(yearGenreRect, clippedRect)) {
                    [self drawCompactText:yearGenre inRect:yearGenreRect];
                }
                currentY -= lineHeight;
            }
            
            // Rating if available
            if (movie.movieRating && movie.movieRating.length > 0) {
                NSString *ratingText = [NSString stringWithFormat:@"‚òÖ %@", movie.movieRating];
                NSRect ratingRect = NSMakeRect(textAreaX, currentY, textAreaWidth, lineHeight);
                if (NSIntersectsRect(ratingRect, clippedRect)) {
                    [self drawHighlightedText:ratingText inRect:ratingRect];
                }
            }
        }
    }
    
    // Draw scroll indicator if content is scrollable
    if (totalContentHeight > contentRect.size.height) {
        [self drawScrollBar:contentRect contentHeight:totalContentHeight scrollPosition:scrollPosition];
    }
}

- (void)drawCompactText:(NSString *)text inRect:(NSRect)rect {
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    [style setLineBreakMode:NSLineBreakByTruncatingTail];
    
    NSDictionary *attrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor lightGrayColor],
        NSParagraphStyleAttributeName: style
    };
    
    [text drawInRect:rect withAttributes:attrs];
    [style release];
}

- (void)drawHighlightedText:(NSString *)text inRect:(NSRect)rect {
    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
    [style setAlignment:NSTextAlignmentLeft];
    [style setLineBreakMode:NSLineBreakByTruncatingTail];
    
    NSDictionary *attrs = @{
        NSFontAttributeName: [NSFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [NSColor colorWithCalibratedWhite:0.9 alpha:1.0],
        NSParagraphStyleAttributeName: style
    };
    
    [text drawInRect:rect withAttributes:attrs];
    [style release];
}

- (NSString *)convertRatingToStars:(NSString *)rating {
    // Convert rating to stars (assuming rating is out of 10)
    CGFloat ratingValue = [rating floatValue];
    NSInteger starCount = (NSInteger)ratingValue; // Direct conversion for 10-star scale
    starCount = MAX(0, MIN(10, starCount)); // Clamp between 0 and 10
    
    NSMutableString *stars = [NSMutableString string];
    for (NSInteger i = 0; i < 10; i++) {
        if (i < starCount) {
            [stars appendString:@"‚òÖ"];
        } else {
            [stars appendString:@"‚òÜ"];
        }
    }
    return stars;
}

#pragma mark - View Mode Preferences

- (void)saveViewModePreference {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    [defaults setInteger:currentViewMode forKey:@"VLCOverlayViewMode"];
    [defaults synchronize];
    NSLog(@"Saved view mode preference: %ld", (long)currentViewMode);
}

- (void)loadViewModePreference {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Load saved view mode (default to 0 = Stacked)
    NSInteger savedViewMode = [defaults integerForKey:@"VLCOverlayViewMode"];
    
    // Validate the loaded value
    if (savedViewMode < 0 || savedViewMode > 2) {
        savedViewMode = 0; // Default to Stacked
    }
    
    currentViewMode = savedViewMode;
    
    // Apply the loaded view mode
    [self applyViewMode:currentViewMode];
    
    NSLog(@"Loaded view mode preference: %ld", (long)currentViewMode);
}

- (void)applyViewMode:(NSInteger)viewMode {
    // Apply the view mode settings
    switch (viewMode) {
        case 0: // Stacked
            isGridViewActive = NO;
            isStackedViewActive = YES;
            break;
        case 1: // Grid
            isGridViewActive = YES;
            isStackedViewActive = NO;
            break;
        case 2: // List
            isGridViewActive = NO;
            isStackedViewActive = NO;
            break;
    }
    
    // Reset hover state and scroll position when changing view modes
    self.hoveredChannelIndex = -1;
    channelScrollPosition = 0;
    
    NSLog(@"Applied view mode: %ld (Stacked: %@, Grid: %@)", (long)viewMode, 
          isStackedViewActive ? @"YES" : @"NO", 
          isGridViewActive ? @"YES" : @"NO");
}

// Memory management: Clear cached images for channels that are not currently visible
- (void)clearOffscreenCachedImages {
    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
    if (!channelsInCurrentGroup || channelsInCurrentGroup.count == 0) {
        return;
    }
    
    // Calculate visible range based on current view mode
    NSRange visibleRange = [self calculateVisibleChannelRange];
    
    NSInteger clearedCount = 0;
    NSInteger memoryBufferSize = 8; // Larger buffer - keep more items in memory
    
    // Clear images for channels well outside the visible range
    for (NSInteger i = 0; i < channelsInCurrentGroup.count; i++) {
        VLCChannel *channel = [channelsInCurrentGroup objectAtIndex:i];
        
        // Keep images for visible channels plus a larger buffer for smooth scrolling
        BOOL shouldKeepInMemory = (i >= visibleRange.location - memoryBufferSize) && 
                                 (i <= visibleRange.location + visibleRange.length + memoryBufferSize);
        
        if (!shouldKeepInMemory && channel.cachedPosterImage) {
            channel.cachedPosterImage = nil; // Release from memory (but keep on disk)
            clearedCount++;
        }
    }
    
    if (clearedCount > 0) {
        NSLog(@"Cleared %ld cached images from memory (buffer: %ld items)", (long)clearedCount, (long)memoryBufferSize);
    }
}

// Preload content for channels that are about to become visible
- (void)preloadContentWithMargin {
    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
    if (!channelsInCurrentGroup || channelsInCurrentGroup.count == 0) {
        return;
    }
    
    // Calculate visible range based on current view mode
    NSRange visibleRange = [self calculateVisibleChannelRange];
    
    // Validate visible range
    if (visibleRange.location >= channelsInCurrentGroup.count || visibleRange.length == 0) {
        NSLog(@"Invalid visible range for preloading");
        return;
    }
    
    // MODIFIED: Only process exactly visible items, no buffer margin to prevent bulk downloading
    NSInteger totalChannels = (NSInteger)channelsInCurrentGroup.count;
    NSInteger visibleStart = (NSInteger)visibleRange.location;
    NSInteger visibleEnd = visibleStart + (NSInteger)visibleRange.length - 1;
    
    // NO BUFFER: Only process exactly what's visible
    NSInteger startIndex = visibleStart;
    NSInteger endIndex = MIN(totalChannels - 1, visibleEnd);
    
    NSLog(@"Processing ONLY visible movies (no buffer): indices %ld-%ld", (long)startIndex, (long)endIndex);
    
    // Process channels in the visible range only
    for (NSInteger i = startIndex; i <= endIndex; i++) {
        VLCChannel *channel = [channelsInCurrentGroup objectAtIndex:i];
        if (![channel.category isEqualToString:@"MOVIES"]) {
            continue;
        }
        
        // Only process if not already loaded and not already fetching
        if (!channel.hasLoadedMovieInfo && !channel.hasStartedFetchingMovieInfo) {
            // First try to load from cache
            BOOL loadedFromCache = [self loadMovieInfoFromCacheForChannel:channel];
            
            if (!loadedFromCache) {
                // Mark as started and fetch asynchronously
                channel.hasStartedFetchingMovieInfo = YES;
                
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                    [self fetchMovieInfoForChannelAsync:channel];
                });
                
                NSLog(@"üîÑ Started fetching movie info for visible item: %@", channel.name);
            } else {
                NSLog(@"üìã Loaded movie info from cache for visible item: %@", channel.name);
            }
        }
    }
}

// Enhanced method to manage memory and preload
- (void)optimizeMemoryAndPreload {
    // First clear offscreen cached images to free memory
    [self clearOffscreenCachedImages];
    
    // Then preload content that's about to become visible
    [self preloadContentWithMargin];
    
    // Also validate movie info for currently visible items
    [self validateMovieInfoForVisibleItems];
    
    // Clean up any incomplete cached movie info files (run occasionally)
    static NSTimeInterval lastCleanupTime = 0;
    NSTimeInterval currentTime = [NSDate timeIntervalSinceReferenceDate];
    
    // Clean up once every hour to avoid performance impact
    if (currentTime - lastCleanupTime > 3600) {
        [self cleanupIncompleteMovieInfoCache];
        lastCleanupTime = currentTime;
    }
}

// Add method to clean up incomplete cached movie info
- (void)cleanupIncompleteMovieInfoCache {
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *movieInfoCacheDir = [appSupportDir stringByAppendingPathComponent:@"MovieInfo"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:movieInfoCacheDir]) {
        return; // No cache directory exists
    }
    
    NSError *error = nil;
    NSArray *cacheFiles = [fileManager contentsOfDirectoryAtPath:movieInfoCacheDir error:&error];
    if (error || !cacheFiles) {
        return;
    }
    
    NSInteger cleanedCount = 0;
    
    for (NSString *filename in cacheFiles) {
        if (![filename hasSuffix:@".plist"]) continue;
        
        NSString *cacheFilePath = [movieInfoCacheDir stringByAppendingPathComponent:filename];
        NSDictionary *movieInfo = [NSDictionary dictionaryWithContentsOfFile:cacheFilePath];
        
        if (movieInfo) {
            NSString *cachedDescription = [movieInfo objectForKey:@"description"];
            NSString *cachedYear = [movieInfo objectForKey:@"year"];
            NSString *cachedGenre = [movieInfo objectForKey:@"genre"];
            NSString *cachedDirector = [movieInfo objectForKey:@"director"];
            NSString *cachedRating = [movieInfo objectForKey:@"rating"];
            
            // Check if this cached data is incomplete
            BOOL hasUsefulDescription = (cachedDescription && [cachedDescription length] > 10);
            BOOL hasUsefulMetadata = ((cachedYear && [cachedYear length] > 0) || 
                                     (cachedGenre && [cachedGenre length] > 0) || 
                                     (cachedDirector && [cachedDirector length] > 0) || 
                                     (cachedRating && [cachedRating length] > 0));
            
            if (!hasUsefulDescription && !hasUsefulMetadata) {
                // Remove incomplete cache file
                [fileManager removeItemAtPath:cacheFilePath error:nil];
                cleanedCount++;
            }
        }
    }
    
    if (cleanedCount > 0) {
        NSLog(@"üßπ Cleaned up %ld incomplete movie info cache files", (long)cleanedCount);
    }
}



// Calculate the range of currently visible channels based on view mode
- (NSRange)calculateVisibleChannelRange {
    NSArray *channelsInCurrentGroup = [self getChannelsForCurrentGroup];
    if (!channelsInCurrentGroup || channelsInCurrentGroup.count == 0) {
        return NSMakeRange(0, 0);
    }
    
    // Check current view mode
    if (isGridViewActive && ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                           (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]))) {
        // Grid view calculation - improved to match actual visible items
        CGFloat catWidth = 200;
        CGFloat groupWidth = 250;
        CGFloat gridX = catWidth + groupWidth;
        CGFloat gridWidth = self.bounds.size.width - gridX;
        CGFloat itemPadding = 10;
        CGFloat itemWidth = MIN(180, (gridWidth / 2) - (itemPadding * 2));
        CGFloat itemHeight = itemWidth * 1.5;
        CGFloat contentHeight = self.bounds.size.height - 40; // Account for header
        
        NSInteger maxColumns = MAX(1, (NSInteger)((gridWidth - itemPadding) / (itemWidth + itemPadding)));
        
        // Calculate scroll offset like in drawGridView
        CGFloat totalGridHeight = ((NSInteger)ceilf((float)channelsInCurrentGroup.count / (float)maxColumns)) * (itemHeight + itemPadding) + itemPadding + itemHeight;
        CGFloat maxScroll = MAX(0, totalGridHeight - contentHeight);
        CGFloat scrollOffset = MAX(0, MIN(channelScrollPosition, maxScroll));
        
        // Calculate which items are actually visible using the same positioning logic as drawing
        NSMutableIndexSet *visibleIndices = [NSMutableIndexSet indexSet];
        
        for (NSInteger i = 0; i < channelsInCurrentGroup.count; i++) {
            NSInteger row = i / maxColumns;
            NSInteger col = i % maxColumns;
            
            // Calculate position using exact same formula as drawGridView
            CGFloat totalGridItemWidth = maxColumns * (itemWidth + itemPadding) + itemPadding;
            CGFloat leftMargin = gridX + (gridWidth - totalGridItemWidth) / 2;
            
            CGFloat x = leftMargin + itemPadding + col * (itemWidth + itemPadding);
            CGFloat y = self.bounds.size.height - 60 - itemHeight - (row * (itemHeight + itemPadding)) + scrollOffset;
            
            // Check if item intersects with visible area (same logic as drawing skip check)
            if (!(y + itemHeight < 0 || y > self.bounds.size.height)) {
                [visibleIndices addIndex:i];
            }
        }
        
        // Convert to NSRange - find the contiguous range or use first and last indices
        if (visibleIndices.count == 0) {
            return NSMakeRange(0, 0);
        }
        
        NSUInteger firstIndex = [visibleIndices firstIndex];
        NSUInteger lastIndex = [visibleIndices lastIndex];
        NSUInteger length = lastIndex - firstIndex + 1;
        
        return NSMakeRange(firstIndex, length);
        
    } else if (isStackedViewActive && ((self.selectedCategoryIndex == CATEGORY_MOVIES) || 
                                     (self.selectedCategoryIndex == CATEGORY_FAVORITES && [self currentGroupContainsMovieChannels]))) {
        // Stacked view calculation - use EXACT same logic as drawStackedView and scroll calculations
        CGFloat catWidth = 200;
        CGFloat groupWidth = 250;
        CGFloat stackedViewX = catWidth + groupWidth;
        CGFloat stackedViewWidth = self.bounds.size.width - stackedViewX;
        NSRect stackedRect = NSMakeRect(stackedViewX, 0, stackedViewWidth, self.bounds.size.height);
        
        CGFloat rowHeight = 400; // Start with base row height
        
        // Account for potential rowHeight adjustment (matches drawStackedView logic)
        NSInteger minVisibleRows = 4;
        CGFloat requiredHeight = minVisibleRows * rowHeight;
        if (stackedRect.size.height < requiredHeight) {
            // Adjust row height if window is too small (matches drawStackedView)
            rowHeight = MAX(80, stackedRect.size.height / minVisibleRows);
        }
        
        // Calculate total content height for proper scroll position
        CGFloat totalContentHeight = channelsInCurrentGroup.count * rowHeight;
        totalContentHeight += rowHeight; // Add extra space
        CGFloat maxScroll = MAX(0, totalContentHeight - stackedRect.size.height);
        CGFloat scrollPosition = MIN(channelScrollPosition, maxScroll);
        
        // Calculate which items are visible using the same positioning logic as drawing
        NSMutableIndexSet *visibleIndices = [NSMutableIndexSet indexSet];
        
        for (NSInteger i = 0; i < channelsInCurrentGroup.count; i++) {
            // Calculate item position using exact same formula as drawStackedView
            CGFloat movieYPosition = stackedRect.size.height - ((i + 1) * rowHeight) + scrollPosition;
            NSRect itemRect = NSMakeRect(stackedViewX, movieYPosition, stackedViewWidth, rowHeight);
            
            // Check if item intersects with visible area (same logic as drawing)
            if (!(itemRect.origin.y + itemRect.size.height < 0 || 
                  itemRect.origin.y > stackedRect.size.height)) {
                [visibleIndices addIndex:i];
            }
        }
        
        // Convert to NSRange - find the contiguous range or use first and last indices
        if (visibleIndices.count == 0) {
            return NSMakeRange(0, 0);
        }
        
        NSUInteger firstIndex = [visibleIndices firstIndex];
        NSUInteger lastIndex = [visibleIndices lastIndex];
        NSUInteger length = lastIndex - firstIndex + 1;
        
        return NSMakeRange(firstIndex, length);
        
    } else {
        // Regular list view calculation
        CGFloat rowHeight = 40;
        NSInteger visibleCount = (NSInteger)(self.bounds.size.height / rowHeight) + 2;
        NSInteger startIndex = (NSInteger)(channelScrollPosition / rowHeight);
        
        startIndex = MAX(0, MIN(startIndex, (NSInteger)channelsInCurrentGroup.count - 1));
        visibleCount = MIN(visibleCount, (NSInteger)channelsInCurrentGroup.count - startIndex);
        
        return NSMakeRange(startIndex, visibleCount);
    }
}

#pragma mark - Selection Persistence

- (void)saveLastSelectedIndices {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    [defaults setInteger:self.selectedCategoryIndex forKey:@"VLCLastSelectedCategory"];
    [defaults setInteger:self.selectedGroupIndex forKey:@"VLCLastSelectedGroup"];
    [defaults setInteger:self.selectedChannelIndex forKey:@"VLCLastSelectedChannel"];
    [defaults synchronize];
    NSLog(@"Saved last selected indices: Cat=%ld, Group=%ld, Channel=%ld", 
          (long)self.selectedCategoryIndex, (long)self.selectedGroupIndex, (long)self.selectedChannelIndex);
}

- (void)loadAndRestoreLastSelectedIndices {
    @try {
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        if (!defaults) {
            NSLog(@"ERROR: NSUserDefaults is nil, cannot load selection indices");
            return;
        }
        
        // Ensure we have valid data structures before proceeding
        if (!self.categories || [self.categories count] == 0) {
            NSLog(@"Categories not yet loaded, skipping selection restoration");
            return;
        }
        
        // Load saved indices with error handling
        NSInteger savedCategory = 0;
        NSInteger savedGroup = 0;
        NSInteger savedChannel = 0;
        
        @try {
            savedCategory = [defaults integerForKey:@"VLCLastSelectedCategory"];
            savedGroup = [defaults integerForKey:@"VLCLastSelectedGroup"];
            savedChannel = [defaults integerForKey:@"VLCLastSelectedChannel"];
        } @catch (NSException *exception) {
            NSLog(@"Exception while reading saved indices: %@", exception);
            savedCategory = CATEGORY_FAVORITES; // Default fallback
            savedGroup = 0;
            savedChannel = 0;
        }
        
        NSLog(@"Loading saved indices: Cat=%ld, Group=%ld, Channel=%ld", 
              (long)savedCategory, (long)savedGroup, (long)savedChannel);
        
        // Validate category index
        if (savedCategory >= 0 && savedCategory < self.categories.count) {
            self.selectedCategoryIndex = savedCategory;
            
            // Validate group index for this category
            NSArray *groups = [self getGroupsForCategoryIndex:savedCategory];
            if (groups && savedGroup >= 0 && savedGroup < groups.count) {
                self.selectedGroupIndex = savedGroup;
                
                // Prepare channel lists for the selected group
                [self prepareSimpleChannelLists];
                
                // Validate channel index for this group
                if (savedChannel >= 0 && savedChannel < self.simpleChannelNames.count) {
                    self.selectedChannelIndex = savedChannel;
                } else {
                    self.selectedChannelIndex = 0; // Default to first channel
                }
            } else {
                self.selectedGroupIndex = 0; // Default to first group
                self.selectedChannelIndex = 0; // Default to first channel
            }
        } else {
            // Default selections
            self.selectedCategoryIndex = CATEGORY_FAVORITES;
            self.selectedGroupIndex = 0;
            self.selectedChannelIndex = 0;
        }
        
        NSLog(@"Restored selection to: Cat=%ld, Group=%ld, Channel=%ld", 
              (long)self.selectedCategoryIndex, (long)self.selectedGroupIndex, (long)self.selectedChannelIndex);
              
          // Center the selection in the menu and set hover indices to match (like auto-navigation)
        [self centerSelectionInMenuAndSetHoverIndices];
    } @catch (NSException *exception) {
        NSLog(@"CRITICAL ERROR in loadAndRestoreLastSelectedIndices: %@", exception);
        // Set safe defaults
        self.selectedCategoryIndex = CATEGORY_FAVORITES;
        self.selectedGroupIndex = 0;
        self.selectedChannelIndex = 0;
    }
}

- (NSArray *)getGroupsForCategoryIndex:(NSInteger)categoryIndex {
    if (categoryIndex < 0 || categoryIndex >= self.categories.count) {
        return nil;
    }
    
    NSString *category = [self.categories objectAtIndex:categoryIndex];
    
    if ([category isEqualToString:@"FAVORITES"]) {
        return [self safeGroupsForCategory:@"FAVORITES"];
    } else if ([category isEqualToString:@"TV"]) {
        return [self safeTVGroups];
    } else if ([category isEqualToString:@"MOVIES"]) {
        return [self safeValueForKey:@"MOVIES" fromDictionary:self.groupsByCategory];
    } else if ([category isEqualToString:@"SERIES"]) {
        return [self safeValueForKey:@"SERIES" fromDictionary:self.groupsByCategory];
    } else if ([category isEqualToString:@"SETTINGS"]) {
        return [self safeValueForKey:@"SETTINGS" fromDictionary:self.groupsByCategory];
    }
    
    return nil;
}

#pragma mark - Smart Search Selection

- (void)saveOriginalLocationForSearchedChannel:(VLCChannel *)channel {
    if (!channel) return;
    
    // Find the original location of this channel
    for (NSInteger catIndex = 0; catIndex < self.categories.count; catIndex++) {
        NSString *category = [self.categories objectAtIndex:catIndex];
        
        // Skip SEARCH category
        if ([category isEqualToString:@"SEARCH"]) continue;
        
        NSArray *groups = [self getGroupsForCategoryIndex:catIndex];
        if (!groups) continue;
        
        for (NSInteger groupIndex = 0; groupIndex < groups.count; groupIndex++) {
            NSString *group = [groups objectAtIndex:groupIndex];
            NSArray *channelsInGroup = [self.channelsByGroup objectForKey:group];
            
            if (channelsInGroup) {
                for (NSInteger channelIndex = 0; channelIndex < channelsInGroup.count; channelIndex++) {
                    VLCChannel *existingChannel = [channelsInGroup objectAtIndex:channelIndex];
                    
                    // Match by URL or name
                    if ([existingChannel.url isEqualToString:channel.url] || 
                        [existingChannel.name isEqualToString:channel.name]) {
                        
                        // Save the original location
                        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
                        [defaults setInteger:catIndex forKey:@"VLCSearchedChannelOriginalCategory"];
                        [defaults setInteger:groupIndex forKey:@"VLCSearchedChannelOriginalGroup"];
                        [defaults setInteger:channelIndex forKey:@"VLCSearchedChannelOriginalChannel"];
                        [defaults setObject:channel.url forKey:@"VLCSearchedChannelURL"];
                        [defaults synchronize];
                        
                        NSLog(@"Saved original location for searched channel '%@': Cat=%ld, Group=%ld, Channel=%ld", 
                              channel.name, (long)catIndex, (long)groupIndex, (long)channelIndex);
                        return;
                    }
                }
            }
        }
    }
}

- (void)selectSearchAndRememberOriginalLocation:(VLCChannel *)channel {
    // Save the original location of this channel
    [self saveOriginalLocationForSearchedChannel:channel];
    
    // Switch to SEARCH category
    self.selectedCategoryIndex = CATEGORY_SEARCH;
    self.selectedGroupIndex = -1; // No groups in search
    self.selectedChannelIndex = -1; // Will be set by search results
    
    NSLog(@"Switched to SEARCH category for channel: %@", channel.name);
}

@end

