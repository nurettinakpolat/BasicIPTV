//
//  VLCUIOverlayView.m
//  BasicIPTV - iOS/tvOS Overlay View
//
//  UIKit-based overlay view implementation for iOS and tvOS
//  Shares the same visual style and functionality as macOS VLCOverlayView
//

#import "VLCUIOverlayView.h"

#if TARGET_OS_IOS || TARGET_OS_TV

#import <mach/mach.h>

#import "VLCChannel.h"
#import "VLCProgram.h"
#import "DownloadManager.h"
#import <CommonCrypto/CommonDigest.h>
#import "VLCOverlayView+EPG.h"
#import "VLCOverlayView+ChannelManagement.h"

// EPG functionality is now shared between macOS and iOS via the EPG category

// Global variables for EPG progress messaging (shared with EPG module)
NSLock *gProgressMessageLock = nil;
NSString *gProgressMessage = nil;

// Progress timer for loading states
static NSTimer *gProgressRedrawTimer = nil;

// Responsive layout constants - calculated based on screen size and retina scale
#define GRID_ITEM_HEIGHT 300
#define STACKED_ROW_HEIGHT 400

// Category indices (matching macOS)
typedef enum {
    CATEGORY_SEARCH = 0,
    CATEGORY_FAVORITES = 1,
    CATEGORY_TV = 2,
    CATEGORY_MOVIES = 3,
    CATEGORY_SERIES = 4,
    CATEGORY_SETTINGS = 5
} CategoryIndex;

// View modes (matching macOS)
typedef enum {
    VIEW_MODE_STACKED = 0,
    VIEW_MODE_GRID = 1,
    VIEW_MODE_LIST = 2
} ViewMode;

@interface VLCUIOverlayView () {
    // Data structures (shared with macOS)
    NSMutableArray *_channels;
    NSMutableArray *_groups;
    NSMutableDictionary *_channelsByGroup;
    NSArray *_categories;
    NSMutableDictionary *_groupsByCategory;
    NSArray *_simpleChannelNames;
    NSArray *_simpleChannelUrls;
    
    // Touch/gesture handling
    UITapGestureRecognizer *_singleTapGesture;
    UITapGestureRecognizer *_doubleTapGesture;
    UIPanGestureRecognizer *_panGesture;
    
    // UI state
    BOOL _isChannelListVisible;
    NSInteger _selectedCategoryIndex;
    NSInteger _selectedGroupIndex;
    NSInteger _hoveredChannelIndex;
    NSInteger _selectedChannelIndex;
    
    // Scroll positions
    CGFloat _categoryScrollPosition;
    CGFloat _groupScrollPosition;
    CGFloat _channelScrollPosition;
    CGFloat _programGuideScrollPosition;
    
    // View mode
    ViewMode _currentViewMode;
    BOOL _isGridViewActive;
    BOOL _isStackedViewActive;
    
    // Colors (matching macOS theme system)
    UIColor *_backgroundColor;
    UIColor *_hoverColor;
    UIColor *_textColor;
    UIColor *_groupColor;
    UIColor *_themeChannelStartColor;
    UIColor *_themeChannelEndColor;
    CGFloat _themeAlpha;
    
    // Cached fonts for memory efficiency
    UIFont *_cachedCategoryFont;
    UIFont *_cachedGroupFont;
    UIFont *_cachedChannelFont;
    UIFont *_cachedChannelNumberFont;
    CGFloat _cachedScreenWidth;
    CGFloat _cachedScreenScale;
    
    // Download synchronization to prevent memory leaks
    BOOL _isDownloadingChannels;
    BOOL _isDownloadingEPG;
    NSURLSessionDataTask *_currentChannelDownloadTask;
    NSURLSessionDataTask *_currentEPGDownloadTask;
    
    // Layout loop prevention
    BOOL _isInLayoutUpdate;
    
    // Drawing throttling to prevent memory crashes
    NSDate *_lastDrawTime;
    BOOL _needsRedraw;
    
    // Memory management for large channel sets
    NSUInteger _maxChannelsPerGroup;
    NSUInteger _maxTotalChannels;
    BOOL _isMemoryConstrained;
    
    // tvOS navigation state
    NSInteger _tvosNavigationArea; // 0=categories, 1=groups, 2=channels, 3=settings
NSInteger _tvosSelectedSettingsControl; // Index of currently selected settings control
    
    // Loading panel
    UIView *_loadingPaneliOS;
    UILabel *_m3uProgressLabeliOS;
    UIProgressView *_m3uProgressBariOS;
    UILabel *_epgProgressLabeliOS;
    UIProgressView *_epgProgressBariOS;
    
    // Program guide momentum scrolling
    CGFloat _programGuideMomentumVelocity;
    CGFloat _programGuideMomentumMaxScroll;
    CADisplayLink *_programGuideMomentumDisplayLink;
}

// Drawing layers for different UI components
@property (nonatomic, strong) CALayer *categoriesLayer;
@property (nonatomic, strong) CALayer *groupsLayer;
@property (nonatomic, strong) CALayer *channelListLayer;
@property (nonatomic, strong) CALayer *programGuideLayer;

@end

@implementation VLCUIOverlayView

#pragma mark - Responsive Layout Helpers

- (CGFloat)categoryWidth {
    CGFloat screenWidth = self.bounds.size.width;
    
    // Landscape-only optimized calculations
    if (screenWidth <= 667) {
        // iPhone in landscape (iPhone 6/7/8 and smaller)
        return MAX(120, screenWidth * 0.16); // 16% of screen width, minimum 120
    } else if (screenWidth <= 844) {
        // Larger iPhones in landscape (iPhone X/11/12/13/14 series)
        return MAX(130, screenWidth * 0.15); // 15% of screen width, minimum 130
    } else if (screenWidth <= 1024) {
        // iPad in landscape
        return MAX(140, screenWidth * 0.14); // 14% of screen width, minimum 140
    } else if (screenWidth <= 1366) {
        // Large iPad Pro in landscape
        return MAX(160, screenWidth * 0.12); // 12% of screen width, minimum 160
    } else {
        // Apple TV or very large displays
        return MAX(180, screenWidth * 0.10); // 10% of screen width, minimum 180
    }
}

- (CGFloat)groupWidth {
    CGFloat screenWidth = self.bounds.size.width;
    
    // Landscape-only optimized calculations
    if (screenWidth <= 667) {
        // iPhone in landscape (iPhone 6/7/8 and smaller)
        return MAX(140, screenWidth * 0.19); // 19% of screen width, minimum 140
    } else if (screenWidth <= 844) {
        // Larger iPhones in landscape (iPhone X/11/12/13/14 series)
        return MAX(150, screenWidth * 0.18); // 18% of screen width, minimum 150
    } else if (screenWidth <= 1024) {
        // iPad in landscape
        return MAX(160, screenWidth * 0.17); // 17% of screen width, minimum 160
    } else if (screenWidth <= 1366) {
        // Large iPad Pro in landscape
        return MAX(180, screenWidth * 0.15); // 15% of screen width, minimum 180
    } else {
        // Apple TV or very large displays
        return MAX(200, screenWidth * 0.12); // 12% of screen width, minimum 200
    }
}

- (CGFloat)programGuideWidth {
    CGFloat screenWidth = self.bounds.size.width;
    
    // Landscape-only optimized calculations - program guide can be more generous
    if (screenWidth <= 667) {
        // iPhone in landscape - compact program guide
        return MAX(150, screenWidth * 0.22); // 22% of screen width, minimum 150
    } else if (screenWidth <= 844) {
        // Larger iPhones in landscape 
        return MAX(180, screenWidth * 0.24); // 24% of screen width, minimum 180
    } else if (screenWidth <= 1024) {
        // iPad in landscape
        return MAX(220, screenWidth * 0.25); // 25% of screen width, minimum 220
    } else if (screenWidth <= 1366) {
        // Large iPad Pro in landscape
        return MAX(280, screenWidth * 0.28); // 28% of screen width, minimum 280
    } else {
        // Apple TV or very large displays
        return MAX(350, screenWidth * 0.30); // 30% of screen width, minimum 350
    }
}

- (CGFloat)gridItemWidth {
    CGFloat availableWidth = self.bounds.size.width - [self categoryWidth] - [self groupWidth];
    CGFloat itemsPerRow = floor(availableWidth / 220); // Aim for ~220pt wide items
    itemsPerRow = MAX(2, itemsPerRow); // At least 2 items per row
    return (availableWidth - (itemsPerRow - 1) * 10) / itemsPerRow; // 10pt spacing between items
}

// Smaller retina-optimized font sizes for iOS landscape mode
- (CGFloat)categoryFontSize {
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat scale = [[UIScreen mainScreen] scale]; // Retina scale factor
    
    if (screenWidth <= 667) {
        return scale >= 3.0 ? 11 : 12; // iPhone in landscape - smaller for retina
    } else if (screenWidth <= 844) {
        return scale >= 3.0 ? 12 : 13; // Larger iPhones in landscape
    } else if (screenWidth <= 1024) {
        return scale >= 2.0 ? 13 : 14; // iPad in landscape
    } else if (screenWidth <= 1366) {
        return scale >= 2.0 ? 14 : 15; // Large iPad Pro in landscape
    } else {
        return 16; // Apple TV or very large displays
    }
}

- (CGFloat)groupFontSize {
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat scale = [[UIScreen mainScreen] scale]; // Retina scale factor
    
    if (screenWidth <= 667) {
        return scale >= 3.0 ? 9 : 10; // iPhone in landscape - smaller for retina
    } else if (screenWidth <= 844) {
        return scale >= 3.0 ? 10 : 11; // Larger iPhones in landscape
    } else if (screenWidth <= 1024) {
        return scale >= 2.0 ? 11 : 12; // iPad in landscape
    } else if (screenWidth <= 1366) {
        return scale >= 2.0 ? 12 : 13; // Large iPad Pro in landscape
    } else {
        return 14; // Apple TV or very large displays
    }
}

- (CGFloat)channelFontSize {
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat scale = [[UIScreen mainScreen] scale]; // Retina scale factor
    
    if (screenWidth <= 667) {
        return scale >= 3.0 ? 10 : 11; // iPhone in landscape - smaller for retina
    } else if (screenWidth <= 844) {
        return scale >= 3.0 ? 11 : 12; // Larger iPhones in landscape
    } else if (screenWidth <= 1024) {
        return scale >= 2.0 ? 12 : 13; // iPad in landscape
    } else if (screenWidth <= 1366) {
        return scale >= 2.0 ? 13 : 14; // Large iPad Pro in landscape
    } else {
        return 15; // Apple TV or very large displays
    }
}

- (CGFloat)channelNumberFontSize {
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat scale = [[UIScreen mainScreen] scale]; // Retina scale factor
    
    if (screenWidth <= 667) {
        return scale >= 3.0 ? 8 : 9; // iPhone in landscape - very small for retina
    } else if (screenWidth <= 844) {
        return scale >= 3.0 ? 9 : 10; // Larger iPhones in landscape
    } else if (screenWidth <= 1024) {
        return scale >= 2.0 ? 10 : 11; // iPad in landscape
    } else if (screenWidth <= 1366) {
        return scale >= 2.0 ? 11 : 12; // Large iPad Pro in landscape
    } else {
        return 12; // Apple TV or very large displays
    }
}

- (CGFloat)rowHeight {
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat scale = [[UIScreen mainScreen] scale]; // Retina scale factor
    
    if (screenWidth <= 667) {
        return scale >= 3.0 ? 32 : 36; // iPhone in landscape - smaller rows for retina
    } else if (screenWidth <= 844) {
        return scale >= 3.0 ? 34 : 38; // Larger iPhones in landscape
    } else if (screenWidth <= 1024) {
        return scale >= 2.0 ? 36 : 40; // iPad in landscape
    } else if (screenWidth <= 1366) {
        return scale >= 2.0 ? 38 : 42; // Large iPad Pro in landscape
    } else {
        return 44; // Apple TV or very large displays
    }
}

#pragma mark - Font Caching (Memory Management)

// Invalidate font caches when view size changes to prevent memory leaks
- (void)invalidateFontCaches {
    _cachedCategoryFont = nil;
    _cachedGroupFont = nil;
    _cachedChannelFont = nil;
    _cachedChannelNumberFont = nil;
    _cachedScreenWidth = 0;
    _cachedScreenScale = 0;
}

- (UIFont *)getCachedCategoryFont {
    CGFloat currentWidth = CGRectGetWidth(self.bounds);
    CGFloat currentScale = [[UIScreen mainScreen] scale];
    
    if (!_cachedCategoryFont || _cachedScreenWidth != currentWidth || _cachedScreenScale != currentScale) {
        _cachedScreenWidth = currentWidth;
        _cachedScreenScale = currentScale;
        
        CGFloat fontSize = [self categoryFontSize];
        _cachedCategoryFont = [UIFont boldSystemFontOfSize:fontSize];
    }
    return _cachedCategoryFont;
}

- (UIFont *)getCachedGroupFont {
    CGFloat currentWidth = CGRectGetWidth(self.bounds);
    CGFloat currentScale = [[UIScreen mainScreen] scale];
    
    if (!_cachedGroupFont || _cachedScreenWidth != currentWidth || _cachedScreenScale != currentScale) {
        CGFloat fontSize = [self groupFontSize];
        _cachedGroupFont = [UIFont systemFontOfSize:fontSize weight:UIFontWeightMedium];
    }
    return _cachedGroupFont;
}

- (UIFont *)getCachedChannelFont {
    CGFloat currentWidth = CGRectGetWidth(self.bounds);
    CGFloat currentScale = [[UIScreen mainScreen] scale];
    
    if (!_cachedChannelFont || _cachedScreenWidth != currentWidth || _cachedScreenScale != currentScale) {
        CGFloat fontSize = [self channelFontSize];
        _cachedChannelFont = [UIFont systemFontOfSize:fontSize weight:UIFontWeightRegular];
    }
    return _cachedChannelFont;
}

- (UIFont *)getCachedChannelNumberFont {
    CGFloat currentWidth = CGRectGetWidth(self.bounds);
    CGFloat currentScale = [[UIScreen mainScreen] scale];
    
    if (!_cachedChannelNumberFont || _cachedScreenWidth != currentWidth || _cachedScreenScale != currentScale) {
        CGFloat fontSize = [self channelNumberFontSize];
        _cachedChannelNumberFont = [UIFont systemFontOfSize:fontSize weight:UIFontWeightBold];
    }
    return _cachedChannelNumberFont;
}

// Memory monitoring to prevent crashes
- (NSUInteger)getCurrentMemoryUsageMB {
    struct mach_task_basic_info info;
    mach_msg_type_number_t size = MACH_TASK_BASIC_INFO_COUNT;
    kern_return_t kerr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &size);
    
    if (kerr == KERN_SUCCESS) {
        NSUInteger memoryMB = info.resident_size / (1024 * 1024);
        return memoryMB;
    }
    return 0;
}

- (void)logMemoryUsage:(NSString *)context {
    NSUInteger memoryMB = [self getCurrentMemoryUsageMB];
    NSLog(@"📊 Memory usage at %@: %luMB", context, (unsigned long)memoryMB);
    
    if (memoryMB > 200) {
        NSLog(@"🚨 CRITICAL MEMORY WARNING: %luMB - triggering emergency cleanup!", (unsigned long)memoryMB);
        [self emergencyMemoryCleanup];
    } else if (memoryMB > 150) {
        NSLog(@"⚠️ HIGH MEMORY WARNING: %luMB - risk of crash!", (unsigned long)memoryMB);
    }
}

- (void)emergencyMemoryCleanup {
    NSLog(@"🧹 EMERGENCY MEMORY CLEANUP - freeing all possible memory");
    
    // This can be called from background thread during M3U processing
    // Only do thread-safe operations here
    
    // Cancel any ongoing downloads
    [self cancelAllDownloads];
    
    // Clear font caches (thread-safe)
    [self invalidateFontCaches];
    
    // Clear any cached drawing data (thread-safe)
    _lastDrawTime = nil;
    
    // Force garbage collection of autoreleased objects
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
    
    // UI cleanup must be done on main thread
    dispatch_async(dispatch_get_main_queue(), ^{
        // Remove UI elements that aren't critical
        if (_settingsScrollViewiOS && _settingsScrollViewiOS.hidden) {
            [_settingsScrollViewiOS removeFromSuperview];
            [_settingsScrollViewiOS release];
            _settingsScrollViewiOS = nil;
        }
    });
    
    NSLog(@"🧹 Emergency cleanup completed - memory freed");
}

// Memory cleanup to prevent crashes
- (void)cancelAllDownloads {
    if (_currentChannelDownloadTask) {
        [_currentChannelDownloadTask cancel];
        _currentChannelDownloadTask = nil;
    }
    
    if (_currentEPGDownloadTask) {
        [_currentEPGDownloadTask cancel];
        _currentEPGDownloadTask = nil;
    }
    
    _isDownloadingChannels = NO;
    _isDownloadingEPG = NO;
}

- (void)dealloc {
    NSLog(@"🧹 VLCUIOverlayView dealloc - cleaning up memory");
    
    // Cancel any ongoing downloads
    [self cancelAllDownloads];
    
    // Stop all momentum animations to prevent crashes
    [self stopAllMomentumAnimations];
    
    // Invalidate font caches
    [self invalidateFontCaches];
    
    // Clean up UI elements
    if (_settingsScrollViewiOS) {
        [_settingsScrollViewiOS removeFromSuperview];
        [_settingsScrollViewiOS release];
        _settingsScrollViewiOS = nil;
    }
    
    if (_loadingPaneliOS) {
        [_loadingPaneliOS removeFromSuperview];
        [_loadingPaneliOS release];
        _loadingPaneliOS = nil;
    }
    
#if TARGET_OS_TV
    [self stopContinuousScrolling];
#endif

    [super dealloc];
}

// Handle memory warnings to prevent crashes
- (void)didReceiveMemoryWarning {
    NSLog(@"⚠️ Memory warning received - cleaning up caches");
    
    // Cancel downloads to free memory
    [self cancelAllDownloads];
    
    // Clear font caches
    [self invalidateFontCaches];
    
    // Force garbage collection
    if (_settingsScrollViewiOS && _settingsScrollViewiOS.hidden) {
        [_settingsScrollViewiOS removeFromSuperview];
    }
}

// Synthesize data properties (shared with macOS)
@synthesize channels = _channels;
@synthesize groups = _groups;
@synthesize channelsByGroup = _channelsByGroup;
@synthesize categories = _categories;
@synthesize groupsByCategory = _groupsByCategory;
@synthesize simpleChannelNames = _simpleChannelNames;
@synthesize simpleChannelUrls = _simpleChannelUrls;

// Synthesize UI state
@synthesize isChannelListVisible = _isChannelListVisible;
@synthesize selectedCategoryIndex = _selectedCategoryIndex;
@synthesize selectedGroupIndex = _selectedGroupIndex;
@synthesize hoveredChannelIndex = _hoveredChannelIndex;
@synthesize selectedChannelIndex = _selectedChannelIndex;

// Synthesize colors (backgroundColor inherited from UIView)
@synthesize hoverColor = _hoverColor;
@synthesize textColor = _textColor;
@synthesize groupColor = _groupColor;

// Synthesize theme colors
@synthesize themeChannelStartColor = _themeChannelStartColor;
@synthesize themeChannelEndColor = _themeChannelEndColor;
@synthesize themeAlpha = _themeAlpha;

#if TARGET_OS_TV
// Synthesize tvOS continuous scrolling properties
@synthesize continuousScrollTimer = _continuousScrollTimer;
@synthesize currentPressType = _currentPressType;
#endif

#pragma mark - Initialization

- (instancetype)initWithFrame:(CGRect)frame {
    NSLog(@"🎬 iOS VLCUIOverlayView initWithFrame - minimal initialization");
    self = [super initWithFrame:frame];
    if (self) {
        NSLog(@"🎬 Testing initializeThemeSystemiOS...");
        [self initializeThemeSystemiOS];
        NSLog(@"🎬 initializeThemeSystemiOS completed");
        
        NSLog(@"🎬 Testing setupView...");
        [self setupView];
        NSLog(@"🎬 setupView completed");
        
      
        
        NSLog(@"🎬 Testing ensureDataStructuresInitialized...");
        [self ensureDataStructuresInitialized];
        NSLog(@"🎬 ensureDataStructuresInitialized completed");
        
        NSLog(@"🎬 Testing setupGestures...");
        [self setupGestures];
        NSLog(@"🎬 setupGestures completed");
        
        NSLog(@"🎬 Testing setupDrawingLayers...");
        [self setupDrawingLayers];
        NSLog(@"🎬 setupDrawingLayers completed");
        
        NSLog(@"🎬 Starting iOS startup sequence...");
        [self performStartupSequence];
        NSLog(@"🎬 iOS startup sequence initiated");
        
        NSLog(@"🎬 VLCUIOverlayView full initialization completed successfully!");
    }
    return self;
}



- (void)setupView {
    NSLog(@"🎬 setupView - testing minimal version");
    self.backgroundColor = [UIColor clearColor];
    
    // Test with scroll positions added
    NSLog(@"🎬 setupView - adding scroll positions");
    
    // Initialize scroll positions
    _categoryScrollPosition = 0;
    _groupScrollPosition = 0;
    _channelScrollPosition = 0;
    
    NSLog(@"🎬 setupView - scroll positions completed");
    
    // Test with UI state initialization
    NSLog(@"🎬 setupView - adding UI state");
    
    // Initialize UI state (show channel list by default for testing)
    _isChannelListVisible = YES;
    _selectedCategoryIndex = CATEGORY_FAVORITES;
    _selectedGroupIndex = -1;
    _hoveredChannelIndex = -1;
    _selectedChannelIndex = -1;
    _currentViewMode = VIEW_MODE_STACKED;
    _isGridViewActive = NO;
    _isStackedViewActive = YES;
    
    // Initialize memory constraints - DISABLED to allow full channel lists
    _maxChannelsPerGroup = NSUIntegerMax;   // No limit on channels per group
    _maxTotalChannels = NSUIntegerMax;      // No limit on total channels
    _isMemoryConstrained = NO;              // Disable memory constraints to load full lists
    
    NSLog(@"🎬 setupView - UI state completed");
    
    // Test with color setup - one at a time
    NSLog(@"🎬 setupView - testing first color assignment");
    
    // Setup all colors (backgroundColor conflict resolved)
    _hoverColor = [UIColor colorWithRed:0.15 green:0.3 blue:0.6 alpha:0.6];
    _textColor = [UIColor whiteColor];
    _groupColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.1 alpha:0.85];
    self.themeChannelStartColor = [UIColor colorWithRed:0.10 green:0.12 blue:0.16 alpha:0.7];
    self.themeChannelEndColor = [UIColor colorWithRed:0.12 green:0.14 blue:0.18 alpha:0.7];
    _themeAlpha = 0.9;
    
    NSLog(@"🎬 setupView - all colors completed successfully");
    
    // Initialize data structures
    self.m3uFilePath = @"";
    self.epgUrl = @"";
    self.isLoading = NO;
    
    NSLog(@"🎬 setupView - all initialization completed successfully");
}

- (void)performStartupSequence {
    NSLog(@"🚀 iOS performStartupSequence - loading settings and cache");
    [self logMemoryUsage:@"app startup"];
    
    // Load settings synchronously first (like macOS)
    NSLog(@"📋 Loading settings...");
    [self loadSettings];
    NSLog(@"📋 Settings loaded - M3U path: %@", self.m3uFilePath ? self.m3uFilePath : @"(nil)");
    
    [self loadThemeSettings];
    [self loadViewModePreference];
    
    // Ensure we have a valid M3U path
    if (!self.m3uFilePath || [self.m3uFilePath length] == 0) {
        NSLog(@"⚠️ No M3U path found in settings - first run detected");
        // For first run, set up example settings to show the settings panel
        self.m3uFilePath = @""; // Keep empty to show settings panel
        NSLog(@"📁 First run - settings panel will be shown");
        
        // Initialize default EPG time offset
        self.epgTimeOffsetHours = 0.0;
        
        // Initialize default selection colors (blue theme)
        self.customSelectionRed = 0.15;
        self.customSelectionGreen = 0.3;
        self.customSelectionBlue = 0.6;
    } else {
        NSLog(@"📁 Existing M3U path loaded: %@", self.m3uFilePath);
    }
    
    // Always regenerate EPG URL from M3U URL to ensure it's correct (overrides any saved incorrect URLs)
    if (self.m3uFilePath && [self.m3uFilePath hasPrefix:@"http"]) {
        // Generate EPG URL from M3U URL (like the macOS settings do)
        NSString *generatedEpgUrl = [self.m3uFilePath stringByReplacingOccurrencesOfString:@"get.php" withString:@"xmltv.php"];
        if (![generatedEpgUrl isEqualToString:self.m3uFilePath]) {
            self.epgUrl = generatedEpgUrl;
            NSLog(@"📅 ✅ EPG URL regenerated from M3U: %@", self.epgUrl);
            [self saveSettings]; // Save the corrected EPG URL
        }
    }
    
    // Fast cache-first startup sequence (in background to not block UI)
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        BOOL channelsLoadedFromCache = NO;
        
        NSLog(@"🔍 Checking for cached data...");
        
        // Try to load channels from cache first
        if (self.m3uFilePath && [self.m3uFilePath length] > 0) {
            // Check if cache is oversized before attempting to load
            if ([self isCacheOversized:self.m3uFilePath]) {
                NSLog(@"🚨 Cache is oversized - clearing it to prevent memory crash");
                [self clearOversizedCache];
                channelsLoadedFromCache = NO;
            } else {
                NSLog(@"📺 Attempting to load channels from cache for: %@", self.m3uFilePath);
                channelsLoadedFromCache = [self loadChannelsFromCache:self.m3uFilePath];
                
                // Check if loaded cache has very few groups (likely incomplete) and clear it
                if (channelsLoadedFromCache && _groups && [_groups count] < 50) {
                    NSLog(@"🚨 Detected incomplete cache with only %lu groups - clearing to force fresh download", (unsigned long)[_groups count]);
                    [self clearOversizedCache];  // This will clear the cache
                    [self ensureDataStructuresInitialized];  // Reset data structures
                    channelsLoadedFromCache = NO;
                } else if (channelsLoadedFromCache) {
                    NSLog(@"✅ Cache loaded successfully: %lu groups, %lu channels", 
                          (unsigned long)[_groups count], (unsigned long)[_channels count]);
                }
            }
            if (channelsLoadedFromCache) {
                NSLog(@"✅ Channels loaded from cache successfully");
            } else {
                NSLog(@"📄 No cache found for this URL");
            }
        }
        
        // Back to main thread for UI updates
        __weak VLCUIOverlayView *weakSelf = self;
        dispatch_sync(dispatch_get_main_queue(), ^{
            __strong VLCUIOverlayView *strongSelf = weakSelf;
            if (!strongSelf) return;
            
            if (channelsLoadedFromCache) {
                NSLog(@"🎬 Cache loaded successfully - displaying channels");
                [strongSelf setNeedsDisplay];
                [strongSelf startEarlyPlaybackIfAvailable];
            } else {
                NSLog(@"⚠️ No cache available, will need to download M3U");
                // Don't auto-download on startup - user can trigger via "Load URL" button
                [strongSelf setNeedsDisplay]; // Still display UI with settings
            }
        });
         
    });
}

- (void)setupDrawingLayers {
    NSLog(@"🎨 iOS setupDrawingLayers - disabled for testing");
    // CALayer setup disabled for testing to avoid potential issues
    /*
    // Create separate layers for each UI component for efficient drawing
    _categoriesLayer = [CALayer layer];
    _categoriesLayer.frame = CGRectMake(0, 0, CATEGORY_WIDTH, self.bounds.size.height);
    [self.layer addSublayer:_categoriesLayer];
    
    _groupsLayer = [CALayer layer];
    _groupsLayer.frame = CGRectMake(CATEGORY_WIDTH, 0, GROUP_WIDTH, self.bounds.size.height);
    [self.layer addSublayer:_groupsLayer];
    
    _channelListLayer = [CALayer layer];
    CGFloat channelListWidth = self.bounds.size.width - CATEGORY_WIDTH - GROUP_WIDTH - 400; // 400 for program guide
    _channelListLayer.frame = CGRectMake(CATEGORY_WIDTH + GROUP_WIDTH, 0, channelListWidth, self.bounds.size.height);
    [self.layer addSublayer:_channelListLayer];
    
    _programGuideLayer = [CALayer layer];
    _programGuideLayer.frame = CGRectMake(self.bounds.size.width - 400, 0, 400, self.bounds.size.height);
    [self.layer addSublayer:_programGuideLayer];
    */
}

#pragma mark - Gesture Setup

- (void)setupGestures {
    #if TARGET_OS_IOS
    NSLog(@"👆 iOS setupGestures - enabling gestures with scroll priority");
    
    // Single tap to interact with UI elements - add this FIRST to get priority
    _singleTapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleSingleTap:)];
    _singleTapGesture.numberOfTapsRequired = 1;
    _singleTapGesture.delaysTouchesEnded = NO; // Immediate response
    _singleTapGesture.delaysTouchesBegan = NO; // Immediate response
    [self addGestureRecognizer:_singleTapGesture];
    
    // Pan gesture for scrolling - should fail if single tap succeeds
    _panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanGesture:)];
    // Touch properties only available on iOS
    _panGesture.minimumNumberOfTouches = 1;
    _panGesture.maximumNumberOfTouches = 1;
    _panGesture.delaysTouchesEnded = YES; // Allow tap to process first
    _panGesture.delaysTouchesBegan = YES; // Allow tap to process first
    // ANTI-FLICKER: Make pan gesture much less sensitive
    _panGesture.cancelsTouchesInView = NO; // Don't interfere with other touches
    [_panGesture requireGestureRecognizerToFail:_singleTapGesture];
    [self addGestureRecognizer:_panGesture];
    
    // Double tap to toggle fullscreen (iOS only)
    _doubleTapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleDoubleTap:)];
    _doubleTapGesture.numberOfTapsRequired = 2;
    [self addGestureRecognizer:_doubleTapGesture];
    [_singleTapGesture requireGestureRecognizerToFail:_doubleTapGesture];
    #endif
    
    #if TARGET_OS_TV
    //NSLog(@"📺 tvOS setupGestures - enabling focus engine only");
    // Apple TV: Add focus engine support
    [self setupFocusEngine];
    #endif
}

#if TARGET_OS_TV
- (void)setupFocusEngine {
    // Make the view focusable for Apple TV remote navigation
    //NSLog(@"📺 Setting up tvOS focus engine");
    
    // Enable focus for this view
    [self setUserInteractionEnabled:YES];
    
    // Initialize focus state
    _selectedCategoryIndex = 0;
    _selectedGroupIndex = 0;
    _selectedChannelIndex = 0;
    _tvosNavigationArea = 0;
    _tvosSelectedSettingsControl = 0;
    
    // Show the menu by default on tvOS
    _isChannelListVisible = YES;
    
    // Initialize data structures
    [self ensureDataStructuresInitialized];
}

- (BOOL)canBecomeFocused {
    return YES;
}

- (void)didUpdateFocusInContext:(UIFocusUpdateContext *)context withAnimationCoordinator:(UIFocusAnimationCoordinator *)coordinator {
    [super didUpdateFocusInContext:context withAnimationCoordinator:coordinator];
    
    // Update display when focus changes
    [coordinator addCoordinatedAnimations:^{
        [self setNeedsDisplay];
    } completion:nil];
    
    //NSLog(@"📺 tvOS focus updated");
}

// Handle Apple TV remote button presses
- (void)pressesBegan:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    BOOL handled = NO;
    
    for (UIPress *press in presses) {
        switch (press.type) {
            case UIPressTypeSelect: {
                // Handle center button press (selection)
                //NSLog(@"📺 tvOS Select button pressed");
                [self handleTVOSSelectPress];
                handled = YES;
                break;
            }
            case UIPressTypeMenu: {
                // Handle Menu button press (back/menu)
                //NSLog(@"📺 tvOS Menu button pressed");
                [self handleTVOSMenuPress];
                handled = YES;
                break;
            }
            case UIPressTypeUpArrow: {
                //NSLog(@"📺 tvOS Up arrow pressed");
                [self handleTVOSNavigationUp];
                [self startContinuousScrolling:UIPressTypeUpArrow];
                handled = YES;
                break;
            }
            case UIPressTypeDownArrow: {
                //NSLog(@"📺 tvOS Down arrow pressed");
                [self handleTVOSNavigationDown];
                [self startContinuousScrolling:UIPressTypeDownArrow];
                handled = YES;
                break;
            }
            case UIPressTypeLeftArrow: {
                //NSLog(@"📺 tvOS Left arrow pressed");
                [self handleTVOSNavigationLeft];
                [self startContinuousScrolling:UIPressTypeLeftArrow];
                handled = YES;
                break;
            }
            case UIPressTypeRightArrow: {
                //NSLog(@"📺 tvOS Right arrow pressed");
                [self handleTVOSNavigationRight];
                [self startContinuousScrolling:UIPressTypeRightArrow];
                handled = YES;
                break;
            }
            case UIPressTypePlayPause: {
                //NSLog(@"📺 tvOS Play/Pause button pressed");
                [self handleTVOSPlayPause];
                handled = YES;
                break;
            }
            default:
                break;
        }
    }
    
    if (!handled) {
        [super pressesBegan:presses withEvent:event];
    }
}

- (void)pressesEnded:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    // Stop continuous scrolling when button is released
    [self stopContinuousScrolling];
    [super pressesEnded:presses withEvent:event];
}

- (void)pressesCancelled:(NSSet<UIPress *> *)presses withEvent:(UIPressesEvent *)event {
    // Stop continuous scrolling if presses are cancelled
    [self stopContinuousScrolling];
    [super pressesCancelled:presses withEvent:event];
}

#pragma mark - tvOS Continuous Scrolling

#if TARGET_OS_TV
- (void)startContinuousScrolling:(UIPressType)pressType {
    // Stop any existing timer
    [self stopContinuousScrolling];
    
    // Store the current press type
    _currentPressType = pressType;
    
    // Start continuous scrolling after initial delay
    _continuousScrollTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 // Initial delay
                                                             target:self
                                                           selector:@selector(continuousScrollTimerFired:)
                                                           userInfo:nil
                                                            repeats:NO];
}

- (void)stopContinuousScrolling {
    if (_continuousScrollTimer) {
        [_continuousScrollTimer invalidate];
        _continuousScrollTimer = nil;
    }
}

- (void)continuousScrollTimerFired:(NSTimer *)timer {
    // Start fast repeating timer for continuous scrolling
    _continuousScrollTimer = [NSTimer scheduledTimerWithTimeInterval:0.1 // Fast repeat interval
                                                             target:self
                                                           selector:@selector(performContinuousScroll:)
                                                           userInfo:nil
                                                            repeats:YES];
}

- (void)performContinuousScroll:(NSTimer *)timer {
    // Perform the appropriate navigation action based on stored press type
    switch (_currentPressType) {
        case UIPressTypeUpArrow:
            [self handleTVOSNavigationUp];
            break;
        case UIPressTypeDownArrow:
            [self handleTVOSNavigationDown];
            break;
        case UIPressTypeLeftArrow:
            [self handleTVOSNavigationLeft];
            break;
        case UIPressTypeRightArrow:
            [self handleTVOSNavigationRight];
            break;
        default:
            // Unknown press type, stop scrolling
            [self stopContinuousScrolling];
            break;
    }
}
#endif

#pragma mark - tvOS Navigation Handlers

- (void)handleTVOSSelectPress {
    if (!_isChannelListVisible) {
        // Show menu if hidden
        _isChannelListVisible = YES;
        [self setNeedsDisplay];
        return;
    }
    
    // Determine current navigation area and handle selection
    switch (_tvosNavigationArea) {
        case 0: // Categories
            [self handleTVOSCategorySelection];
            break;
        case 1: // Groups
            [self handleTVOSGroupSelection];
            break;
        case 2: // Channels
            [self handleTVOSChannelSelection];
            break;
        case 3: // Settings controls or Program Guide
            if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
                [self handleTVOSSettingsSelection];
            } else {
                [self handleTVOSEpgProgramSelection];
            }
            break;
    }
}

- (void)handleTVOSMenuPress {
    // Toggle menu visibility or go back
    if (_isChannelListVisible) {
        [self hideAllSettingsScrollViews];
        _isChannelListVisible = NO;
    } else {
        _isChannelListVisible = YES;
    }
    [self setNeedsDisplay];
}

- (void)handleTVOSNavigationUp {
    if (!_isChannelListVisible) return;
    
    switch (_tvosNavigationArea) {
        case 0: // Categories
            if (_selectedCategoryIndex > 0) {
                _selectedCategoryIndex--;
                [self handleTVOSCategoryChange];
            }
            break;
        case 1: // Groups
            if (_selectedGroupIndex > 0) {
                _selectedGroupIndex--;
                [self handleTVOSGroupScroll];
            }
            break;
        case 2: // Channels
            if (_selectedChannelIndex > 0) {
                _selectedChannelIndex--;
                [self handleTVOSChannelScroll];
                //NSLog(@"📺 ✅ tvOS UP - Set selectedChannelIndex to: %ld (should show program guide)", (long)_selectedChannelIndex);
            }
            break;
        case 3: // Settings controls or Program Guide
            if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
                [self handleTVOSSettingsNavigationUp];
            } else {
                [self handleTVOSProgramGuideNavigationUp];
            }
            break;
    }
    [self setNeedsDisplay];
}

- (void)handleTVOSNavigationDown {
    if (!_isChannelListVisible) return;
    
    switch (_tvosNavigationArea) {
        case 0: // Categories
            if (_selectedCategoryIndex < 5) { // 6 categories (0-5)
                _selectedCategoryIndex++;
                [self handleTVOSCategoryChange];
            }
            break;
        case 1: // Groups
        {
            NSArray *groups = [self getGroupsForSelectedCategory];
            if (_selectedGroupIndex < groups.count - 1) {
                _selectedGroupIndex++;
                [self handleTVOSGroupScroll];
            }
            break;
        }
        case 2: // Channels
        {
            NSArray *channels = [self getChannelsForCurrentGroup];
            if (_selectedChannelIndex < channels.count - 1) {
                _selectedChannelIndex++;
                [self handleTVOSChannelScroll];
                //NSLog(@"📺 ✅ tvOS DOWN - Set selectedChannelIndex to: %ld (should show program guide)", (long)_selectedChannelIndex);
            }
            break;
        }
        case 3: // Settings controls or Program Guide
            if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
                [self handleTVOSSettingsNavigationDown];
            } else {
                [self handleTVOSProgramGuideNavigationDown];
            }
            break;
    }
    [self setNeedsDisplay];
}

- (void)handleTVOSNavigationLeft {
    if (!_isChannelListVisible) return;
    
    // Reset EPG navigation mode if leaving program guide area
    if (_tvosNavigationArea == 3 && _selectedCategoryIndex != CATEGORY_SETTINGS) {
        self.epgNavigationMode = NO;
        self.selectedEpgProgramIndex = -1;
        //NSLog(@"📺 [EPG] Exited EPG navigation mode");
    }
    
    // Move to previous navigation area
    if (_tvosNavigationArea > 0) {
        _tvosNavigationArea--;
        //NSLog(@"📺 tvOS moved to navigation area: %d", _tvosNavigationArea);
    }
    [self setNeedsDisplay];
}

- (void)handleTVOSNavigationRight {
    if (!_isChannelListVisible) return;
    
    // Move to next navigation area
    NSInteger maxArea;
    if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
        maxArea = 3; // Categories, Groups, Channels, Settings
    } else if (_selectedChannelIndex >= 0 && [self getChannelAtIndex:_selectedChannelIndex]) {
        maxArea = 3; // Categories, Groups, Channels, Program Guide
    } else {
        maxArea = 2; // Categories, Groups, Channels
    }
    
    if (_tvosNavigationArea < maxArea) {
        _tvosNavigationArea++;
        if (_tvosNavigationArea == 3) {
            if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
                _tvosSelectedSettingsControl = 0; // Start at first control
            } else {
                // Initialize EPG navigation starting at current program
                [self initializeEpgNavigation];
            }
        }
        //NSLog(@"📺 tvOS moved to navigation area: %d", _tvosNavigationArea);
    }
    [self setNeedsDisplay];
}

- (void)handleTVOSPlayPause {
    // Toggle playback if media is loaded
    if (self.player) {
        if (self.player.isPlaying) {
            [self.player pause];
            //NSLog(@"📺 tvOS paused playback");
        } else {
            [self.player play];
            //NSLog(@"📺 tvOS resumed playback");
        }
    }
}

#pragma mark - tvOS Selection Handlers

- (void)handleTVOSCategorySelection {
    NSInteger previousCategoryIndex = _selectedCategoryIndex;
    
    // Hide settings scroll views when switching categories
    [self hideAllSettingsScrollViews];
    
    // Handle settings panel visibility
    if (previousCategoryIndex == CATEGORY_SETTINGS && _selectedCategoryIndex != CATEGORY_SETTINGS) {
        [self hideSettingsPanel];
    } else if (_selectedCategoryIndex == CATEGORY_SETTINGS && previousCategoryIndex != CATEGORY_SETTINGS) {
        [self showSettingsPanel];
    }
    
    // Reset group selection when changing categories
    _selectedGroupIndex = 0;
    _selectedChannelIndex = 0;
    _groupScrollPosition = 0;
    _channelScrollPosition = 0;
    
    //NSLog(@"📺 tvOS selected category: %ld", (long)_selectedCategoryIndex);
}

- (void)handleTVOSGroupSelection {
    NSArray *groups = [self getGroupsForSelectedCategory];
    if (_selectedGroupIndex >= 0 && _selectedGroupIndex < groups.count) {
        // Hide settings scroll views when switching groups
        [self hideAllSettingsScrollViews];
        
        // Reset channel selection when changing groups
        _selectedChannelIndex = 0;
        _channelScrollPosition = 0;
        
        // Reset settings control selection when switching groups
        _tvosSelectedSettingsControl = 0;
        
        //NSLog(@"📺 tvOS selected group: %@ (index: %ld)", groups[_selectedGroupIndex], (long)_selectedGroupIndex);
    }
}

- (void)handleTVOSChannelSelection {
    NSArray *channels = [self getChannelsForCurrentGroup];
    if (_selectedChannelIndex >= 0 && _selectedChannelIndex < channels.count) {
        // Play the selected channel
        [self playChannelAtIndex:_selectedChannelIndex];
        
        // Hide menu and all settings after selection on tvOS
        [self hideAllSettingsScrollViews];
        _isChannelListVisible = NO;
        [self setNeedsDisplay];
        
        //NSLog(@"📺 tvOS selected and playing channel at index: %ld", (long)_selectedChannelIndex);
    }
}

#pragma mark - tvOS Scroll Handlers

- (void)handleTVOSCategoryChange {
    // Categories don't scroll, just update selection
    // Any category-specific logic can go here
}

- (void)handleTVOSGroupScroll {
    // Ensure selected group is visible
    CGFloat itemHeight = [self rowHeight];
    CGFloat visibleHeight = self.bounds.size.height;
    CGFloat selectedItemY = _selectedGroupIndex * itemHeight;
    
    // Auto-scroll if selection is out of view
    if (selectedItemY < _groupScrollPosition) {
        _groupScrollPosition = selectedItemY;
    } else if (selectedItemY + itemHeight > _groupScrollPosition + visibleHeight) {
        _groupScrollPosition = selectedItemY + itemHeight - visibleHeight;
    }
    
    // Clamp scroll position
    NSArray *groups = [self getGroupsForSelectedCategory];
    CGFloat maxScroll = MAX(0, groups.count * itemHeight - visibleHeight);
    _groupScrollPosition = MAX(0, MIN(_groupScrollPosition, maxScroll));
}

- (void)handleTVOSChannelScroll {
    // Ensure selected channel is visible
    CGFloat itemHeight = [self rowHeight];
    CGFloat visibleHeight = self.bounds.size.height;
    CGFloat selectedItemY = _selectedChannelIndex * itemHeight;
    
    // Auto-scroll if selection is out of view
    if (selectedItemY < _channelScrollPosition) {
        _channelScrollPosition = selectedItemY;
    } else if (selectedItemY + itemHeight > _channelScrollPosition + visibleHeight) {
        _channelScrollPosition = selectedItemY + itemHeight - visibleHeight;
    }
    
    // Clamp scroll position
    NSArray *channels = [self getChannelsForCurrentGroup];
    CGFloat maxScroll = MAX(0, channels.count * itemHeight - visibleHeight);
    _channelScrollPosition = MAX(0, MIN(_channelScrollPosition, maxScroll));
}

#pragma mark - tvOS Program Guide Navigation

- (void)handleTVOSProgramGuideNavigationUp {
    VLCChannel *channel = [self getChannelAtIndex:_selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) return;
    
    // Initialize EPG navigation mode if not already active
    if (!self.epgNavigationMode) {
        [self initializeEpgNavigation];
        return;
    }
    
    // Move to previous program
    if (self.selectedEpgProgramIndex > 0) {
        self.selectedEpgProgramIndex--;
        [self scrollToSelectedEpgProgram];
        //NSLog(@"📺 EPG UP - Selected program index: %ld", (long)self.selectedEpgProgramIndex);
        [self setNeedsDisplay];
    }
}

- (void)handleTVOSProgramGuideNavigationDown {
    VLCChannel *channel = [self getChannelAtIndex:_selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) return;
    
    // Initialize EPG navigation mode if not already active
    if (!self.epgNavigationMode) {
        [self initializeEpgNavigation];
        return;
    }
    
    // Move to next program
    if (self.selectedEpgProgramIndex < channel.programs.count - 1) {
        self.selectedEpgProgramIndex++;
        [self scrollToSelectedEpgProgram];
        //NSLog(@"📺 EPG DOWN - Selected program index: %ld", (long)self.selectedEpgProgramIndex);
        [self setNeedsDisplay];
    }
}

#pragma mark - tvOS Settings Navigation

- (void)handleTVOSSettingsNavigationUp {
    if (_tvosSelectedSettingsControl > 0) {
        _tvosSelectedSettingsControl--;
        //NSLog(@"📺 tvOS settings control up: %ld", (long)_tvosSelectedSettingsControl);
    }
}

- (void)handleTVOSSettingsNavigationDown {
    NSInteger maxControls = [self getSettingsControlCount];
    if (_tvosSelectedSettingsControl < maxControls - 1) {
        _tvosSelectedSettingsControl++;
        //NSLog(@"📺 tvOS settings control down: %ld", (long)_tvosSelectedSettingsControl);
    }
}

- (void)handleTVOSSettingsSelection {
    //NSLog(@"📺 tvOS settings control selected: %ld", (long)_tvosSelectedSettingsControl);
    
    // Get current settings group
    NSArray *settingsGroups = [self getGroupsForSelectedCategory];
    if (_selectedGroupIndex >= 0 && _selectedGroupIndex < [settingsGroups count]) {
        NSString *selectedGroup = [settingsGroups objectAtIndex:_selectedGroupIndex];
        
        if ([selectedGroup isEqualToString:@"Playlist"]) {
            [self handleTVOSPlaylistSettingsSelection];
        } else if ([selectedGroup isEqualToString:@"Themes"]) {
            [self handleTVOSThemeSettingsSelection];
        } else if ([selectedGroup isEqualToString:@"General"]) {
            [self handleTVOSGeneralSettingsSelection];
        } else if ([selectedGroup isEqualToString:@"Movie Info"]) {
            [self handleTVOSMovieInfoSettingsSelection];
        }
    }
}

- (NSInteger)getSettingsControlCount {
    // Get current settings group and return control count
    NSArray *settingsGroups = [self getGroupsForSelectedCategory];
    if (_selectedGroupIndex >= 0 && _selectedGroupIndex < [settingsGroups count]) {
        NSString *selectedGroup = [settingsGroups objectAtIndex:_selectedGroupIndex];
        
        if ([selectedGroup isEqualToString:@"Playlist"]) {
            return 5; // M3U field, EPG field, Time offset button, Load button, Update EPG button
        } else if ([selectedGroup isEqualToString:@"Themes"]) {
            return 8; // Theme selection, transparency, RGB sliders, glassmorphism toggle, intensity, reset
        } else if ([selectedGroup isEqualToString:@"General"]) {
            return 1; // Placeholder
        } else if ([selectedGroup isEqualToString:@"Movie Info"]) {
            return 1; // Clear cache button
        }
    }
    return 0;
}

- (void)handleTVOSPlaylistSettingsSelection {
    switch (_tvosSelectedSettingsControl) {
        case 0: // M3U URL field
            //NSLog(@"📺 tvOS M3U URL field selected - show text input");
            [self showTVOSTextInput:@"Enter M3U URL" currentText:self.m3uFilePath completion:^(NSString *newText) {
                if (newText && newText.length > 0) {
                    self.m3uFilePath = newText;
                    [self saveSettings];
                    //NSLog(@"📺 M3U URL updated: %@", newText);
                }
            }];
            break;
        case 1: // EPG URL field  
            //NSLog(@"📺 tvOS EPG URL field selected - show text input");
            [self showTVOSTextInput:@"Enter EPG URL" currentText:self.epgUrl completion:^(NSString *newText) {
                if (newText && newText.length > 0) {
                    self.epgUrl = newText;
                    [self saveSettings];
                    //NSLog(@"📺 EPG URL updated: %@", newText);
                }
            }];
            break;
        case 2: // Time offset button
            //NSLog(@"📺 tvOS Time offset button selected");
            [self showTVOSTimeOffsetSelection];
            break;
        case 3: // Load button
            //NSLog(@"📺 tvOS Load button selected");
            if (self.m3uFilePath && self.m3uFilePath.length > 0) {
                [self loadChannelsFromUrl:self.m3uFilePath];
            }
            break;
        case 4: // Update EPG button
            NSLog(@"🔧 [UPDATE-EPG-TVOS] ===== TVOS UPDATE EPG BUTTON SELECTED =====");
            if (self.epgUrl && self.epgUrl.length > 0) {
                // FORCE FRESH EPG DOWNLOAD: Use the existing forceReloadEpgData method
                NSLog(@"🔧 [UPDATE-EPG-TVOS] About to call forceReloadEpgData");
                if ([self respondsToSelector:@selector(forceReloadEpgData)]) {
                    NSLog(@"🔧 [UPDATE-EPG-TVOS] ✅ forceReloadEpgData method is available - calling it");
                    [self forceReloadEpgData];
                } else {
                    NSLog(@"🔧 [UPDATE-EPG-TVOS] ❌ forceReloadEpgData method not available - falling back to loadEpgDataWithRetryCount");
                    // Fallback: bypass cache manually and call direct download
                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                        [self loadEpgDataWithRetryCount:0];
                    });
                }
            } else {
                NSLog(@"🔧 [UPDATE-EPG-TVOS] ❌ No EPG URL configured for updating");
            }
            break;
    }
}

- (void)handleTVOSThemeSettingsSelection {
    //NSLog(@"📺 tvOS Theme settings selection: %ld", (long)_tvosSelectedSettingsControl);
    switch (_tvosSelectedSettingsControl) {
        case 0: // Theme selection
            //[self showTVOSThemeSelection];
            break;
        case 1: // Transparency
            //[self showTVOSTransparencySelection];
            break;
        case 2: // Selection Red
            //[self showTVOSSelectionColorSelection:@"Red" component:0];
            break;
        case 3: // Selection Green
            //[self showTVOSSelectionColorSelection:@"Green" component:1];
            break;
        case 4: // Selection Blue  
            //[self showTVOSSelectionColorSelection:@"Blue" component:2];
            break;
        case 5: // Glassmorphism toggle
            //[self toggleTVOSGlassmorphism];
            break;
        case 6: // Glassmorphism intensity
            //[self showTVOSGlassmorphismIntensitySelection];
            break;
        case 7: // Reset themes
            [self resetTVOSThemeSettings];
            break;
    }
}
/*
- (void)handleTVOSGeneralSettingsSelection {
    NSLog(@"📺 tvOS General settings selection: %ld", (long)_tvosSelectedSettingsControl);
    // Add general settings selection handling
}
*/
- (void)handleTVOSMovieInfoSettingsSelection {
    if (_tvosSelectedSettingsControl == 0) {
        //NSLog(@"📺 tvOS Clear movie info cache selected");
        [self clearMovieInfoCache];
    }
}

- (void)showTVOSTextInput:(NSString *)title currentText:(NSString *)currentText completion:(void(^)(NSString *newText))completion {
    //NSLog(@"📺 tvOS text input: %@", title);
    
#if TARGET_OS_TV
    // Create an alert controller with text field
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title
                                                                             message:@"Type using the on-screen keyboard. Select each letter, then use 'Done' button to save."
                                                                      preferredStyle:UIAlertControllerStyleAlert];
    
    // Store completion block for later use - copy to ensure proper memory management
    void(^storedCompletion)(NSString *) = [completion copy];
    
    // Add text field with tvOS-optimized configuration
    [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.text = currentText ?: @"";
        textField.placeholder = @"http://example.com/playlist.m3u";
        
        // tvOS-specific optimizations for proper character input
        textField.keyboardType = UIKeyboardTypeURL; // URL keyboard for better URL input
        textField.returnKeyType = UIReturnKeyDefault; // Don't auto-trigger Done
        textField.autocorrectionType = UITextAutocorrectionTypeNo;
        textField.autocapitalizationType = UITextAutocapitalizationTypeNone;
        textField.spellCheckingType = UITextSpellCheckingTypeNo;
        textField.clearButtonMode = UITextFieldViewModeWhileEditing;
        
        // Better editing configuration for tvOS
        textField.borderStyle = UITextBorderStyleRoundedRect;
        textField.adjustsFontSizeToFitWidth = YES;
        textField.minimumFontSize = 12.0;
    }];
    
    // Add Done action (primary)
    UIAlertAction *doneAction = [UIAlertAction actionWithTitle:@"Done" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        UITextField *textField = alertController.textFields.firstObject;
        NSString *newText = textField.text ?: @"";
        //NSLog(@"📺 tvOS text input completed: '%@'", newText);
        if (storedCompletion) {
            storedCompletion(newText);
        }
        [self setNeedsDisplay];
    }];
    
    // Add Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {
        //NSLog(@"📺 tvOS text input cancelled");
        if (storedCompletion) {
            storedCompletion(currentText); // Return original text
        }
    }];
    
    // Add Clear action for convenience
    UIAlertAction *clearAction = [UIAlertAction actionWithTitle:@"Clear" style:UIAlertActionStyleDestructive handler:^(UIAlertAction *action) {
        //NSLog(@"📺 tvOS text input cleared");
        if (storedCompletion) {
            storedCompletion(@""); // Return empty text
        }
        [self setNeedsDisplay];
    }];
    
    // Add Paste action for clipboard support (only if clipboard has content)
    // Note: Clipboard functionality is not available on tvOS, so this is disabled
    // On tvOS, users will need to type the URL manually
#if !TARGET_OS_TV
    NSString *clipboardText = [self getClipboardText];
    if (clipboardText && clipboardText.length > 0) {
        NSString *pasteTitle = [NSString stringWithFormat:@"Paste: %@", [self truncateString:clipboardText maxLength:30]];
        UIAlertAction *pasteAction = [UIAlertAction actionWithTitle:pasteTitle style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            //NSLog(@"📺 tvOS paste from clipboard: '%@'", clipboardText);
            if (storedCompletion) {
                storedCompletion(clipboardText);
            }
            [self setNeedsDisplay];
        }];
        [alertController addAction:pasteAction];
    }
#endif
    
    [alertController addAction:doneAction];
    [alertController addAction:clearAction];
    [alertController addAction:cancelAction];
    
    // Set Done as preferred action
    alertController.preferredAction = doneAction;
    
#else
    // iOS version - simpler implementation
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title
                                                                             message:@"Enter text"
                                                                      preferredStyle:UIAlertControllerStyleAlert];
    
    [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.text = currentText ?: @"";
        textField.placeholder = @"Enter URL";
        textField.keyboardType = UIKeyboardTypeURL;
    }];
    
    UIAlertAction *okAction = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
        UITextField *textField = alertController.textFields.firstObject;
        NSString *newText = textField.text;
        if (completion) {
            completion(newText);
        }
        [self setNeedsDisplay];
    }];
    
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {
        if (completion) {
            completion(currentText);
        }
    }];
    
    [alertController addAction:okAction];
    [alertController addAction:cancelAction];
#endif
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:^{
            // Auto-focus the text field after presentation with delay for tvOS
            UITextField *textField = alertController.textFields.firstObject;
            if (textField) {
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    [textField becomeFirstResponder];
                    //NSLog(@"📺 Text field focused for input");
                });
            }
        }];
    } else {
        //NSLog(@"❌ No view controller found to present text input");
        if (completion) {
            completion(currentText);
        }
    }
}

- (UIViewController *)topViewController {
    UIViewController *topController = [UIApplication sharedApplication].keyWindow.rootViewController;
    while (topController.presentedViewController) {
        topController = topController.presentedViewController;
    }
    return topController;
}

- (NSString *)getClipboardText {
#if TARGET_OS_IOS
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    
    // Check if pasteboard has string content
    if (pasteboard.hasStrings && pasteboard.string) {
        NSString *clipboardContent = pasteboard.string;
        
        // Basic validation - check if it looks like a URL
        if ([clipboardContent hasPrefix:@"http://"] || 
            [clipboardContent hasPrefix:@"https://"] ||
            [clipboardContent containsString:@".m3u"] ||
            [clipboardContent containsString:@".m3u8"]) {
            return clipboardContent;
        }
        
        // Return content even if not URL-like, user can decide
        return clipboardContent;
    }
    
    return nil;
#else
    // Clipboard is not available on tvOS
    return nil;
#endif
}

- (NSString *)truncateString:(NSString *)string maxLength:(NSInteger)maxLength {
    if (!string || string.length <= maxLength) {
        return string;
    }
    
    NSString *truncated = [string substringToIndex:maxLength - 3];
    return [truncated stringByAppendingString:@"..."];
}

#if TARGET_OS_TV
- (void)drawTVOSPlaylistSettings:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = rect.size.height - 80;
    CGFloat lineHeight = 25;
    CGFloat controlHeight = 35;
    CGFloat spacing = 15;
    
    // Title
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:18],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect titleRect = CGRectMake(x + padding, startY, width - (padding * 2), lineHeight);
    [@"Playlist Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    CGFloat currentY = startY - 50;
    NSInteger controlIndex = 0;
    
    // Control 0: M3U URL Field
    [self drawTVOSControl:controlIndex
                    label:@"M3U URL:"
                    value:self.m3uFilePath ?: @"Not set"
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 1: EPG URL Field
    [self drawTVOSControl:controlIndex
                    label:@"EPG URL:"
                    value:self.epgUrl ?: @"Not set"
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 2: Time Offset
    NSString *timeOffsetText = [NSString stringWithFormat:@"%.1f hours", self.epgTimeOffsetHours];
    [self drawTVOSControl:controlIndex
                    label:@"Time Offset:"
                    value:timeOffsetText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 3: Load Button
    [self drawTVOSControl:controlIndex
                    label:@"Load Channels"
                    value:@"Press to load"
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 4: Update EPG Button
    [self drawTVOSControl:controlIndex
                    label:@"Update EPG"
                    value:@"Press to update EPG data"
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
}

- (void)drawTVOSControl:(NSInteger)controlIndex label:(NSString *)label value:(NSString *)value rect:(CGRect)controlRect selected:(BOOL)selected {
    // Draw background with highlighting if selected
    if (selected) {
        // Bright blue highlight for focused control
        [[UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:0.8] setFill];
        UIBezierPath *highlightPath = [UIBezierPath bezierPathWithRoundedRect:controlRect cornerRadius:8];
        [highlightPath fill];
    } else {
        // Darker background for non-focused controls
        [[UIColor colorWithRed:0.2 green:0.2 blue:0.2 alpha:0.6] setFill];
        UIBezierPath *bgPath = [UIBezierPath bezierPathWithRoundedRect:controlRect cornerRadius:8];
        [bgPath fill];
    }
    
    // Draw border
    [[UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0] setStroke];
    UIBezierPath *borderPath = [UIBezierPath bezierPathWithRoundedRect:controlRect cornerRadius:8];
    borderPath.lineWidth = 1.0;
    [borderPath stroke];
    
    // Label color based on selection
    UIColor *labelColor = selected ? [UIColor whiteColor] : [UIColor lightGrayColor];
    UIColor *valueColor = selected ? [UIColor whiteColor] : [UIColor grayColor];
    
    // Draw label
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:14],
        NSForegroundColorAttributeName: labelColor
    };
    
    CGRect labelRect = CGRectMake(controlRect.origin.x + 10, controlRect.origin.y + 2, controlRect.size.width - 20, 16);
    [label drawInRect:labelRect withAttributes:labelAttrs];
    
    // Draw value
    NSDictionary *valueAttrs = @{
        NSFontAttributeName: [UIFont systemFontOfSize:12],
        NSForegroundColorAttributeName: valueColor
    };
    
    CGRect valueRect = CGRectMake(controlRect.origin.x + 10, controlRect.origin.y + 18, controlRect.size.width - 20, 14);
    [value drawInRect:valueRect withAttributes:valueAttrs];
    
    // Show control index for debugging
    if (selected) {
        //NSLog(@"📺 tvOS control %ld highlighted: %@", (long)controlIndex, label);
    }
}
#endif

#endif

#pragma mark - Drawing Methods (Core UI Rendering)

- (void)drawRect:(CGRect)rect {
    @autoreleasepool {
        // No throttling - maximum smoothness for scrolling
        
        // Light memory monitoring during drawing
        static NSUInteger drawCount = 0;
        drawCount++;
        if (drawCount % 100 == 0) { // Check memory every 100 draws (reduced frequency)
            [self logMemoryUsage:@"during drawing"];
        }
        
        //NSLog(@"🎨 iOS drawRect called - rendering retina-optimized UI (scale: %.1fx)", [[UIScreen mainScreen] scale]);
        
        if (!_isChannelListVisible) {
            // Clear the background to be transparent when channel list is not visible
            // This allows the video underneath to show through
            CGContextRef context = UIGraphicsGetCurrentContext();
            if (context) {
                CGContextClearRect(context, rect);
            }
            return;
        }
        
        // Get current graphics context
        CGContextRef context = UIGraphicsGetCurrentContext();
        if (!context) {
            NSLog(@"❌ No graphics context available");
            return;
        }
        
        CGContextSaveGState(context);
        
        // Draw components in order (matching macOS layout) with autorelease pools
        @autoreleasepool {
            [self drawCategories:rect];
        }
        
        @autoreleasepool {
            [self drawGroups:rect];
        }
        
        // Draw content based on selected category
        @autoreleasepool {
            if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
                [self drawSettingsPanel:rect];
            } else {
                // Check view mode for content categories
                if (_isGridViewActive && ((_selectedCategoryIndex == CATEGORY_MOVIES) || 
                                         (_selectedCategoryIndex == CATEGORY_FAVORITES))) {
                    [self drawGridView:rect];
                } else if (_isStackedViewActive && ((_selectedCategoryIndex == CATEGORY_MOVIES) || 
                                                   (_selectedCategoryIndex == CATEGORY_FAVORITES))) {
                    [self drawStackedView:rect];
                } else {
                    [self drawChannelList:rect];
                }
            }
        }
        
        CGContextRestoreGState(context);
        //NSLog(@"🎨 Full UI rendering completed");
    }
}

- (void)drawCategories:(CGRect)rect {
    // Calculate responsive category width
    CGFloat categoryWidth = [self categoryWidth];
    
    // Draw background for categories panel using theme colors
    CGRect categoriesRect = CGRectMake(0, 0, categoryWidth, rect.size.height);
    
    // Use theme colors if available, otherwise fall back to default
    UIColor *categoryBgColor = self.themeCategoryStartColor ?: [UIColor darkGrayColor];
    [categoryBgColor setFill];
    UIRectFill(categoriesRect);
    
    // Draw category items
    NSArray *categoryNames = @[@"🔍 Search", @"⭐ Favorites", @"📺 TV", @"🎬 Movies", @"📚 Series", @"⚙️ Settings"];
    
    for (NSInteger i = 0; i < categoryNames.count; i++) {
        CGRect itemRect = CGRectMake(0, i * [self rowHeight], categoryWidth, [self rowHeight]);
        
        // Highlight selected category using custom selection colors (like macOS)
        if (i == _selectedCategoryIndex) {
            // Use user-customized selection colors instead of hardcoded blue
            UIColor *highlightColor;
            #if TARGET_OS_TV
            // Enhanced highlighting for tvOS when in category navigation area
            if (_tvosNavigationArea == 0) {
                // Bright selection color for focus
                highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.8];
            } else {
                // Dimmer selection color when not focused
                highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.75]; // Increased for better visibility
            }
            #else
            // Use custom selection colors for iOS (increased alpha for better visibility)
            highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.85];
            #endif
            
            // Apply glassmorphism visual effects if enabled (categories)
            if (self.glassmorphismEnabled) {
                // Create rounded rect with custom corner radius
                UIBezierPath *selectionPath = [UIBezierPath bezierPathWithRoundedRect:itemRect cornerRadius:self.glassmorphismCornerRadius];
                [highlightColor setFill];
                [selectionPath fill];
                
                // Add border if border width > 0
                if (self.glassmorphismBorderWidth > 0) {
                    // Create border color based on selection color
                    UIColor *borderColor = [UIColor colorWithRed:self.customSelectionRed * 1.2 
                                                           green:self.customSelectionGreen * 1.2 
                                                            blue:self.customSelectionBlue * 1.2 
                                                           alpha:0.8];
                    [borderColor setStroke];
                    selectionPath.lineWidth = self.glassmorphismBorderWidth;
                    [selectionPath stroke];
                }
            } else {
                // Fallback to simple rectangle
                [highlightColor setFill];
                UIRectFill(itemRect);
            }
        }
        
        // Draw category text using cached fonts
        NSString *categoryName = categoryNames[i];
        NSDictionary *textAttributes = @{
            NSFontAttributeName: [self getCachedCategoryFont],
            NSForegroundColorAttributeName: [UIColor whiteColor]
        };
        
        CGRect textRect = CGRectInset(itemRect, 10, 5);
        [categoryName drawInRect:textRect withAttributes:textAttributes];
    }
}

- (void)drawGroups:(CGRect)rect {
    // Calculate responsive widths
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    
    // Draw background for groups panel using theme colors  
    CGRect groupsRect = CGRectMake(categoryWidth, 0, groupWidth, rect.size.height);
    
    // Use theme colors if available, otherwise fall back to default
    UIColor *groupBgColor = self.themeCategoryEndColor ?: [UIColor grayColor];
    [groupBgColor setFill];
    UIRectFill(groupsRect);
    
    // Get groups for selected category
    NSArray *groups = [self getGroupsForSelectedCategory];
    
    for (NSInteger i = 0; i < groups.count; i++) {
        CGRect itemRect = CGRectMake(categoryWidth, i * [self rowHeight] - _groupScrollPosition, groupWidth, [self rowHeight]);
        
        // Skip items that are not visible
        if (itemRect.origin.y + itemRect.size.height < 0 || itemRect.origin.y > rect.size.height) {
            continue;
        }
        
        // Highlight selected group using custom selection colors (like macOS)
        if (i == _selectedGroupIndex) {
            UIColor *highlightColor;
            #if TARGET_OS_TV
            // Enhanced highlighting for tvOS when in group navigation area
            if (_tvosNavigationArea == 1) {
                // Bright selection color for focus
                highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.8];
            } else {
                // Dimmer selection color when not focused
                highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.75]; // Increased for better visibility
            }
            #else
            // Use custom selection colors for iOS (increased alpha for better visibility)
            highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.85];
            #endif
            
            // Apply glassmorphism visual effects if enabled (groups)
            if (self.glassmorphismEnabled) {
                // Create rounded rect with custom corner radius
                UIBezierPath *selectionPath = [UIBezierPath bezierPathWithRoundedRect:itemRect cornerRadius:self.glassmorphismCornerRadius];
                [highlightColor setFill];
                [selectionPath fill];
                
                // Add border if border width > 0
                if (self.glassmorphismBorderWidth > 0) {
                    // Create border color based on selection color
                    UIColor *borderColor = [UIColor colorWithRed:self.customSelectionRed * 1.2 
                                                           green:self.customSelectionGreen * 1.2 
                                                            blue:self.customSelectionBlue * 1.2 
                                                           alpha:0.8];
                    [borderColor setStroke];
                    selectionPath.lineWidth = self.glassmorphismBorderWidth;
                    [selectionPath stroke];
                }
            } else {
                // Fallback to simple rectangle
                [highlightColor setFill];
                UIRectFill(itemRect);
            }
        }
        
        // Draw group text using cached fonts
        NSString *groupName = groups[i];
        NSDictionary *textAttributes = @{
            NSFontAttributeName: [self getCachedGroupFont],
            NSForegroundColorAttributeName: [UIColor whiteColor]
        };
        
        CGRect textRect = CGRectInset(itemRect, 10, 5);
        [groupName drawInRect:textRect withAttributes:textAttributes];
        
        // Draw catchup icon if this group contains channels with catchup support (like Mac version)
        if ([self groupHasCatchupChannels:groupName]) {
            CGFloat catchupSize = 18;
            CGRect catchupRect = CGRectMake(itemRect.origin.x + itemRect.size.width - catchupSize - 8,
                                          itemRect.origin.y + (itemRect.size.height - catchupSize) / 2,
                                          catchupSize,
                                          catchupSize);
            
            // Draw circular background for catchup icon
            UIBezierPath *catchupCircle = [UIBezierPath bezierPathWithOvalInRect:catchupRect];
            [[UIColor colorWithRed:0.2 green:0.7 blue:0.4 alpha:0.9] setFill]; // Green like Mac
            [catchupCircle fill];
            
            // Add white border for better visibility
            [[UIColor whiteColor] setStroke];
            catchupCircle.lineWidth = 1.0;
            [catchupCircle stroke];
            
            // Draw clock symbol
            NSString *clockSymbol = @"⏱";
            NSDictionary *clockAttributes = @{
                NSFontAttributeName: [UIFont systemFontOfSize:10],
                NSForegroundColorAttributeName: [UIColor whiteColor]
            };
            
            CGRect clockRect = CGRectMake(catchupRect.origin.x + 2,
                                        catchupRect.origin.y + 1,
                                        catchupSize - 4,
                                        catchupSize - 2);
            [clockSymbol drawInRect:clockRect withAttributes:clockAttributes];
        }
    }
}

- (void)drawChannelList:(CGRect)rect {
    // Calculate responsive dimensions
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat programGuideWidth = [self programGuideWidth];
    
    // Calculate channel list area - responsive to screen size
    CGFloat channelListX = categoryWidth + groupWidth;
    CGFloat channelListWidth = rect.size.width - channelListX - programGuideWidth;
    
    // Draw background for channel list using theme colors
    CGRect channelListRect = CGRectMake(channelListX, 0, channelListWidth, rect.size.height);
    
    // Use theme colors if available, otherwise fall back to default
    UIColor *channelBgColor = self.themeChannelStartColor ?: [UIColor lightGrayColor];
    [channelBgColor setFill];
    UIRectFill(channelListRect);
    
    // Get channels for current selection
    NSArray *channels = [self getChannelsForCurrentGroup];
    
    // Draw channel items
    for (NSInteger i = 0; i < channels.count; i++) {
        CGRect itemRect = CGRectMake(channelListX, i * [self rowHeight] - _channelScrollPosition, 
                                    channelListWidth, [self rowHeight]);
        
        // Skip items that are not visible (with small buffer for smooth scrolling)
        if (itemRect.origin.y + itemRect.size.height < -[self rowHeight] || itemRect.origin.y > rect.size.height + [self rowHeight]) {
            continue;
        }
        
        // Highlight hovered or selected channel using custom selection colors (like macOS)
        if (i == _hoveredChannelIndex || i == _selectedChannelIndex) {
            UIColor *highlightColor;
            
            if (i == _selectedChannelIndex) {
                // Selected channel - use custom selection colors
                #if TARGET_OS_TV
                // Enhanced highlighting for tvOS when in channel navigation area
                if (_tvosNavigationArea == 2) {
                    // Bright selection color for focus
                    highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.8];
                } else {
                    // Dimmer selection color when not focused
                    highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.6];
                }
                #else
                // Use custom selection colors for iOS (increased alpha for better visibility)
                highlightColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.85];
                #endif
            } else {
                // Hovered channel - lighter version of custom selection color (like macOS hover)
                CGFloat hoverRed = self.customSelectionRed * 0.9;
                CGFloat hoverGreen = self.customSelectionGreen * 0.9;
                CGFloat hoverBlue = self.customSelectionBlue * 0.9;
                highlightColor = [UIColor colorWithRed:hoverRed green:hoverGreen blue:hoverBlue alpha:0.7]; // Increased from 0.3 for better visibility
            }
            
            // Apply glassmorphism visual effects if enabled (channels)
            if (self.glassmorphismEnabled) {
                // Create rounded rect with custom corner radius
                UIBezierPath *selectionPath = [UIBezierPath bezierPathWithRoundedRect:itemRect cornerRadius:self.glassmorphismCornerRadius];
                [highlightColor setFill];
                [selectionPath fill];
                
                // Add border if border width > 0
                if (self.glassmorphismBorderWidth > 0) {
                    // Create border color based on selection color (brighter for channels)
                    UIColor *borderColor;
                    if (i == _selectedChannelIndex) {
                        // Bright border for selected channel
                        borderColor = [UIColor colorWithRed:self.customSelectionRed * 1.3 
                                                      green:self.customSelectionGreen * 1.3 
                                                       blue:self.customSelectionBlue * 1.3 
                                                      alpha:0.9];
                    } else {
                        // Dimmer border for hovered channel
                        borderColor = [UIColor colorWithRed:self.customSelectionRed * 1.1 
                                                      green:self.customSelectionGreen * 1.1 
                                                       blue:self.customSelectionBlue * 1.1 
                                                      alpha:0.7];
                    }
                    [borderColor setStroke];
                    selectionPath.lineWidth = self.glassmorphismBorderWidth;
                    [selectionPath stroke];
                }
            } else {
                // Fallback to simple rectangle
                [highlightColor setFill];
                UIRectFill(itemRect);
            }
        }
        
        // Get channel data
        NSString *channelName = @"Unknown Channel";
        VLCChannel *channel = nil;
        if ([channels[i] isKindOfClass:[VLCChannel class]]) {
            channel = (VLCChannel *)channels[i];
            channelName = channel.name ?: @"Unnamed Channel";
        } else if ([channels[i] isKindOfClass:[NSString class]]) {
            channelName = (NSString *)channels[i];
        }
        
        // Calculate text layout - channel name at top, EPG data below
        CGRect channelNameRect = CGRectInset(itemRect, 8, 4);
        channelNameRect.size.height = 20; // Reserve space for channel name
        
        // Optional: Draw channel number on the left first
        if (i < 999) { // Only show numbers for reasonable range
            NSString *channelNumber = [NSString stringWithFormat:@"%ld", (long)(i + 1)];
            NSDictionary *numberAttributes = @{
                NSFontAttributeName: [self getCachedChannelNumberFont],
                NSForegroundColorAttributeName: [UIColor colorWithWhite:0.7 alpha:1.0]
            };
            CGRect numberRect = CGRectMake(channelListX + 5, itemRect.origin.y + 8, 30, 20);
            [channelNumber drawInRect:numberRect withAttributes:numberAttributes];
            
            // Adjust channel name rect to account for channel number  
            channelNameRect.origin.x += 35;
            channelNameRect.size.width -= 35;
        }
        
        // Draw channel name with better styling
        NSDictionary *channelNameAttributes = @{
            NSFontAttributeName: [self getCachedChannelFont],
            NSForegroundColorAttributeName: [UIColor whiteColor]
        };
        [channelName drawInRect:channelNameRect withAttributes:channelNameAttributes];
        
        // Draw catchup icon if channel supports catchup (like Mac version)
        if (channel && (channel.supportsCatchup || channel.catchupDays > 0)) {
            CGFloat catchupSize = 20;
            CGRect catchupRect = CGRectMake(channelNameRect.origin.x + channelNameRect.size.width - catchupSize - 5,
                                          channelNameRect.origin.y + 1,
                                          catchupSize,
                                          catchupSize);
            
            // Draw circular background for catchup icon
            UIBezierPath *catchupCircle = [UIBezierPath bezierPathWithOvalInRect:catchupRect];
            [[UIColor colorWithRed:0.2 green:0.7 blue:0.4 alpha:0.8] setFill]; // Green like Mac
            [catchupCircle fill];
            
            // Draw clock symbol
            NSString *clockSymbol = @"⏱";
            NSDictionary *clockAttributes = @{
                NSFontAttributeName: [UIFont systemFontOfSize:12],
                NSForegroundColorAttributeName: [UIColor whiteColor]
            };
            
            CGRect clockRect = CGRectMake(catchupRect.origin.x + 3,
                                        catchupRect.origin.y + 2,
                                        catchupSize - 6,
                                        catchupSize - 4);
            [clockSymbol drawInRect:clockRect withAttributes:clockAttributes];
        }
        
        // Draw EPG data below channel name (like macOS version)
        if (channel) {
            VLCProgram *currentProgram = [channel currentProgramWithTimeOffset:self.epgTimeOffsetHours];
            
            // Check if we have EPG data
            BOOL hasEpgData = (self.isEpgLoaded && currentProgram != nil);
            if (hasEpgData) {
                // Draw current program title
                NSDictionary *programAttributes = @{
                    NSFontAttributeName: [UIFont systemFontOfSize:12],
                    NSForegroundColorAttributeName: [UIColor colorWithWhite:0.8 alpha:1.0]
                };
                
                // Program info below channel name
                CGRect programRect = CGRectMake(channelNameRect.origin.x,
                                              itemRect.origin.y + 24,
                                              channelNameRect.size.width - 80, // Leave space for time
                                              16);
                
                // Truncate program title if needed (with safety check)
                NSString *programTitle = currentProgram ? currentProgram.title : @"Loading...";
                if (programTitle && programTitle.length > 25) {
                    programTitle = [[programTitle substringToIndex:22] stringByAppendingString:@"..."];
                }
                if (!programTitle) programTitle = @"Loading...";
                [programTitle drawInRect:programRect withAttributes:programAttributes];
                
                // Draw program time on right side (with safety check)
                CGRect timeRect = CGRectMake(itemRect.origin.x + channelListWidth - 85,
                                           itemRect.origin.y + 24,
                                           75,
                                           16);
                
                NSString *timeRange = currentProgram ? [currentProgram formattedTimeRangeWithOffset:self.epgTimeOffsetHours] : @"--:--";
                if (!timeRange) timeRange = @"--:--";
                [timeRange drawInRect:timeRect withAttributes:programAttributes];
                
                // Draw progress bar at bottom
                NSDate *now = [NSDate date];
                NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600.0;
                NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
                
                // Safety check: Ensure currentProgram is valid and both dates exist before calculating duration
                CGFloat progress = 0;
                if (currentProgram && currentProgram.startTime && currentProgram.endTime) {
                    NSTimeInterval totalDuration = [currentProgram.endTime timeIntervalSinceDate:currentProgram.startTime];
                    NSTimeInterval elapsed = [adjustedNow timeIntervalSinceDate:currentProgram.startTime];
                    progress = totalDuration > 0 ? (elapsed / totalDuration) : 0;
                    progress = MAX(0, MIN(progress, 1.0)); // Clamp between 0 and 1
                } else {
                    // Silently handle nil program or dates - this is expected when EPG data is loading
                    progress = 0;
                }
                
                // Draw thin progress bar
                CGFloat progressBarHeight = 2;
                CGRect progressBarBg = CGRectMake(channelNameRect.origin.x,
                                                itemRect.origin.y + itemRect.size.height - 6,
                                                channelNameRect.size.width,
                                                progressBarHeight);
                
                // Background bar
                [[UIColor colorWithRed:0.2 green:0.2 blue:0.2 alpha:0.7] setFill];
                UIRectFill(progressBarBg);
                
                // Progress fill
                CGRect progressBarFill = CGRectMake(progressBarBg.origin.x,
                                                  progressBarBg.origin.y,
                                                  progressBarBg.size.width * progress,
                                                  progressBarHeight);
                
                // Use color based on progress
                UIColor *progressColor;
                if (progress < 0.25) {
                    progressColor = [UIColor colorWithRed:0.2 green:0.7 blue:0.3 alpha:0.8]; // Green
                } else if (progress < 0.75) {
                    progressColor = [UIColor colorWithRed:0.2 green:0.5 blue:0.8 alpha:0.8]; // Blue
                } else {
                    progressColor = [UIColor colorWithRed:0.8 green:0.3 blue:0.2 alpha:0.8]; // Red
                }
                [progressColor setFill];
                UIRectFill(progressBarFill);
                
            } else if (self.isEpgLoaded) {
                // EPG is loaded but no program data for this channel
                NSDictionary *noDataAttributes = @{
                    NSFontAttributeName: [UIFont systemFontOfSize:10],
                    NSForegroundColorAttributeName: [UIColor darkGrayColor]
                };
                
                CGRect noDataRect = CGRectMake(channelNameRect.origin.x,
                                             itemRect.origin.y + 24,
                                             channelNameRect.size.width,
                                             16);
                
                [@"No program data available" drawInRect:noDataRect withAttributes:noDataAttributes];
            }
        }
    }
    
    // Draw program guide panel for hovered or selected channel (like macOS)
    NSInteger channelIndexForGuide = -1;
    
#if TARGET_OS_IOS
    // iOS: Show guide for hovered channel (single tap) or selected channel
    if (_hoveredChannelIndex >= 0) {
        channelIndexForGuide = _hoveredChannelIndex; // Show guide for hovered channel (single tap)
    } else if (_selectedChannelIndex >= 0) {
        channelIndexForGuide = _selectedChannelIndex; // Fallback to selected channel
    }
#elif TARGET_OS_TV
    // tvOS: Show guide for currently selected channel (removed navigation area restriction)
    if (_selectedChannelIndex >= 0) {
        channelIndexForGuide = _selectedChannelIndex; // Show guide for remote-selected channel
    }
#endif
    
    if (channelIndexForGuide >= 0 && channelIndexForGuide < channels.count) {
        //NSLog(@"📺 ✅ Drawing program guide for channel index: %ld (channels.count: %lu)", (long)channelIndexForGuide, (unsigned long)channels.count);
        [self drawProgramGuideForChannelAtIndex:channelIndexForGuide rect:rect];
    } else {
        //NSLog(@"📺 ❌ No program guide to draw - channelIndexForGuide: %ld, channels.count: %lu", 
         //     (long)channelIndexForGuide, (unsigned long)channels.count);
#if TARGET_OS_IOS
        //NSLog(@"📺 iOS debug - hoveredIndex: %ld, selectedIndex: %ld, channelListVisible: %d", 
        //      (long)_hoveredChannelIndex, (long)_selectedChannelIndex, _isChannelListVisible);
#elif TARGET_OS_TV
        //NSLog(@"📺 tvOS debug - selectedIndex: %ld, channelListVisible: %d", 
        //      (long)_selectedChannelIndex, _isChannelListVisible);
#endif
        //NSLog(@"📺 Debug - selectedCategory: %ld, selectedGroup: %ld, EPG loaded: %d, EPG loading: %d", 
        //      (long)_selectedCategoryIndex, (long)_selectedGroupIndex, self.isEpgLoaded, self.isLoadingEpg);
    }
}

- (void)drawGridView:(CGRect)rect {
    // TODO: Implement grid view for movies (similar to macOS)
    [self drawChannelList:rect]; // Fallback to list view for now
}

- (void)drawStackedView:(CGRect)rect {
    // TODO: Implement stacked view for movies (similar to macOS)
    [self drawChannelList:rect]; // Fallback to list view for now
}

- (void)drawSettingsPanel:(CGRect)rect {
    //NSLog(@"🔧 drawSettingsPanel called for iOS with macOS compatibility");
    
    // Calculate responsive dimensions
    CGFloat catWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat settingsPanelX = catWidth + groupWidth;
    CGFloat settingsPanelWidth = rect.size.width - settingsPanelX;
    
    // Draw the settings panel background
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    // Create a semitransparent background like macOS
    CGContextSetRGBFillColor(context, 0.0, 0.0, 0.0, 0.7);
    CGContextFillRect(context, CGRectMake(settingsPanelX, 0, settingsPanelWidth, rect.size.height));
    
    // Don't cleanup existing settings UI elements - let show/hide methods manage them
    // [self cleanupSettingsUIElements]; // REMOVED - this was causing the scroll view to be destroyed
    
    // Get the actual settings groups like macOS does
    NSArray *settingsGroups = [self getGroupsForSelectedCategory];
    
    if (_selectedGroupIndex >= 0 && _selectedGroupIndex < [settingsGroups count]) {
        NSString *selectedGroup = [settingsGroups objectAtIndex:_selectedGroupIndex];
        //NSLog(@"🔧 Drawing settings for group: %@", selectedGroup);
        
        if ([selectedGroup isEqualToString:@"Playlist"]) {
            [self drawPlaylistSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"General"]) {
            [self drawGeneralSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"Subtitles"]) {
#if TARGET_OS_IOS
            [self drawSubtitleSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth];
#else
            [self drawDefaultSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth group:selectedGroup];
#endif
        } else if ([selectedGroup isEqualToString:@"Movie Info"]) {
            [self drawMovieInfoSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth];
        } else if ([selectedGroup isEqualToString:@"Themes"]) {
            [self drawThemeSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth];
        } else {
            [self drawDefaultSettingsPanel:rect x:settingsPanelX width:settingsPanelWidth group:selectedGroup];
        }
    } else {
        // No group selected, show helper message
        NSString *helpText = @"Select a settings group from the left panel";
        
        NSDictionary *attrs = @{
            NSFontAttributeName: [UIFont systemFontOfSize:14],
            NSForegroundColorAttributeName: [UIColor whiteColor]
        };
        
        CGRect helpRect = CGRectMake(settingsPanelX + 20, rect.size.height / 2 - 10, settingsPanelWidth - 40, 20);
        [helpText drawInRect:helpRect withAttributes:attrs];
    }
}

- (void)cleanupSettingsUIElements {
    // Remove any existing iOS settings UI elements
    if (_settingsScrollViewiOS) {
        [_settingsScrollViewiOS removeFromSuperview];
        [_settingsScrollViewiOS release];
        _settingsScrollViewiOS = nil;
    }
    if (_m3uTextFieldiOS) {
        [_m3uTextFieldiOS removeFromSuperview];
        [_m3uTextFieldiOS release];
        _m3uTextFieldiOS = nil;
    }
    if (_epgLabeliOS) {
        [_epgLabeliOS removeFromSuperview];
        [_epgLabeliOS release];
        _epgLabeliOS = nil;
    }
    if (_timeOffsetButtoniOS) {
        [_timeOffsetButtoniOS removeFromSuperview];
        [_timeOffsetButtoniOS release];
        _timeOffsetButtoniOS = nil;
    }
    
    // Clean up new specialized settings scroll views
    if (_themeSettingsScrollView) {
        [_themeSettingsScrollView removeFromSuperview];
        [_themeSettingsScrollView release];
        _themeSettingsScrollView = nil;
    }
    if (_subtitleSettingsScrollView) {
        [_subtitleSettingsScrollView removeFromSuperview];
        [_subtitleSettingsScrollView release];
        _subtitleSettingsScrollView = nil;
    }
    
    // Clear subtitle slider references
#if TARGET_OS_IOS
    _subtitleFontSizeSlider = nil; // These are subviews that get released with their parent scroll view
#endif
    _subtitleFontSizeLabel = nil;
    
    // Clean up loading panel
    [self hideLoadingPanel];
}

- (void)hideAllSettingsScrollViews {
    // Hide all settings-related scroll views when switching between groups or categories
    // Don't remove from superview to allow proper recreation
    if (_settingsScrollViewiOS) {
        _settingsScrollViewiOS.hidden = YES;
    }
    if (_themeSettingsScrollView) {
        _themeSettingsScrollView.hidden = YES;
    }
    if (_subtitleSettingsScrollView) {
        _subtitleSettingsScrollView.hidden = YES;
    }
}

#pragma mark - Settings Panel Methods (iOS Adaptations of macOS)

- (void)drawPlaylistSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
#if TARGET_OS_TV
    // tvOS: Draw simple controls with highlighting
    [self drawTVOSPlaylistSettings:rect x:x width:width];
#else
    // iOS: Create or update the scroll view for settings
    [self createOrUpdateSettingsScrollView:rect x:x width:width];
#endif
}

- (void)drawGeneralSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = rect.size.height - 80;
    CGFloat lineHeight = 25;
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect titleRect = CGRectMake(x + padding, startY, width - (padding * 2), lineHeight);
    [@"General Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [UIFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGFloat currentY = startY - 40;
    
    // Show general settings info
    NSArray *generalSettings = @[
        @"• Application preferences and behavior",
        @"• Default playback settings and controls", 
        @"• Network configuration and timeout",
        @"• Cache management and storage",
        @"• Auto-play and resume settings",
        @"• Language and region preferences"
    ];
    
    for (NSString *setting in generalSettings) {
        CGRect settingRect = CGRectMake(x + padding, currentY, width - (padding * 2), lineHeight);
        [setting drawInRect:settingRect withAttributes:labelAttrs];
        currentY -= lineHeight + 5;
    }
}

#if TARGET_OS_IOS
- (void)drawSubtitleSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    // Create or update the scroll view for subtitle settings
    [self createOrUpdateSubtitleSettingsScrollView:rect x:x width:width];
}
#endif

- (void)drawMovieInfoSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = rect.size.height - 80;
    CGFloat lineHeight = 25;
    CGFloat buttonHeight = 40;
    CGFloat buttonWidth = 260;
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect titleRect = CGRectMake(x + padding, startY, width - (padding * 2), lineHeight);
    [@"Movie Information Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    NSDictionary *descAttrs = @{
        NSFontAttributeName: [UIFont systemFontOfSize:12],
        NSForegroundColorAttributeName: [UIColor lightGrayColor]
    };
    
    CGRect descRect = CGRectMake(x + padding, startY - 25, width - (padding * 2), 16);
    [@"Manage movie information and poster images" drawInRect:descRect withAttributes:descAttrs];
    
    // Get cache directory info
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *cacheDir = [documentsPath stringByAppendingPathComponent:@"VLCCache"];
    NSString *movieInfoCacheDir = [cacheDir stringByAppendingPathComponent:@"MovieInfo"];
    NSString *posterCacheDir = [cacheDir stringByAppendingPathComponent:@"Posters"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // Count files in cache directories
    NSInteger movieInfoCount = 0;
    NSInteger posterCount = 0;
    NSError *error = nil;
    
    if ([fileManager fileExistsAtPath:movieInfoCacheDir]) {
        NSArray *files = [fileManager contentsOfDirectoryAtPath:movieInfoCacheDir error:&error];
        if (!error) {
            movieInfoCount = files.count;
        }
    }
    
    if ([fileManager fileExistsAtPath:posterCacheDir]) {
        NSArray *posterFiles = [fileManager contentsOfDirectoryAtPath:posterCacheDir error:&error];
        if (!error) {
            posterCount = posterFiles.count;
        }
    }
    
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [UIFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGFloat currentY = startY - 60;
    
    // Show cache information
    NSString *cacheInfo = [NSString stringWithFormat:@"• Movie info files cached: %ld", (long)movieInfoCount];
    CGRect cacheRect = CGRectMake(x + padding, currentY, width - (padding * 2), lineHeight);
    [cacheInfo drawInRect:cacheRect withAttributes:labelAttrs];
    currentY -= lineHeight + 5;
    
    NSString *posterInfo = [NSString stringWithFormat:@"• Movie posters cached: %ld", (long)posterCount];
    CGRect posterRect = CGRectMake(x + padding, currentY, width - (padding * 2), lineHeight);
    [posterInfo drawInRect:posterRect withAttributes:labelAttrs];
    currentY -= lineHeight + 15;
    
    // Draw cache management buttons
    CGRect clearCacheButtonRect = CGRectMake(x + padding, currentY, buttonWidth, buttonHeight);
    
    // Draw button background
    [[UIColor colorWithRed:0.8 green:0.2 blue:0.2 alpha:1.0] setFill];
    UIBezierPath *buttonPath = [UIBezierPath bezierPathWithRoundedRect:clearCacheButtonRect cornerRadius:8];
    [buttonPath fill];
    
    // Draw button text
    NSDictionary *buttonAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:14],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect buttonTextRect = CGRectMake(clearCacheButtonRect.origin.x + 10,
                                      clearCacheButtonRect.origin.y + 12,
                                      clearCacheButtonRect.size.width - 20,
                                      clearCacheButtonRect.size.height - 24);
    [@"Clear Movie Info Cache" drawInRect:buttonTextRect withAttributes:buttonAttrs];
    
    // Store button rect for touch handling
    _clearMovieInfoCacheButtonRect = clearCacheButtonRect;
}

- (void)drawThemeSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
#if TARGET_OS_TV
    // tvOS: Draw theme controls with highlighting
    [self drawTVOSThemeSettings:rect x:x width:width];
#else
    // iOS: Create or update the scroll view for theme settings
    [self createOrUpdateThemeSettingsScrollView:rect x:x width:width];
#endif
}

- (void)drawDefaultSettingsPanel:(CGRect)rect x:(CGFloat)x width:(CGFloat)width group:(NSString *)groupName {
    CGFloat padding = 20;
    CGFloat startY = rect.size.height - 80;
    CGFloat lineHeight = 25;
    
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    NSString *title = [NSString stringWithFormat:@"%@ Settings", groupName];
    CGRect titleRect = CGRectMake(x + padding, startY, width - (padding * 2), lineHeight);
    [title drawInRect:titleRect withAttributes:titleAttrs];
    
    NSDictionary *labelAttrs = @{
        NSFontAttributeName: [UIFont systemFontOfSize:14],
        NSForegroundColorAttributeName: [UIColor lightGrayColor]
    };
    
    CGFloat currentY = startY - 40;
    NSString *placeholder = [NSString stringWithFormat:@"Settings for %@ will be implemented here", groupName];
    CGRect placeholderRect = CGRectMake(x + padding, currentY, width - (padding * 2), lineHeight);
    [placeholder drawInRect:placeholderRect withAttributes:labelAttrs];
}

#pragma mark - Interactive Settings UI Elements (iOS)

- (void)createOrUpdateSettingsScrollView:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    // Only recreate if scroll view doesn't exist or size changed significantly
    BOOL needsRecreation = NO;
    if (!_settingsScrollViewiOS) {
        needsRecreation = YES;
    } else {
        CGRect currentFrame = _settingsScrollViewiOS.frame;
        CGRect newFrame = CGRectMake(x, 0, width, rect.size.height);
        if (fabs(currentFrame.size.width - newFrame.size.width) > 10 || 
            fabs(currentFrame.size.height - newFrame.size.height) > 10) {
            needsRecreation = YES;
        }
    }
    
    if (!needsRecreation) {
        // Just update the frame
        _settingsScrollViewiOS.frame = CGRectMake(x, 0, width, rect.size.height);
        return;
    }
    
    // Remove existing scroll view if it exists
    if (_settingsScrollViewiOS) {
        [_settingsScrollViewiOS removeFromSuperview];
        [_settingsScrollViewiOS release];
        _settingsScrollViewiOS = nil;
    }
    
    // Create scroll view
    CGRect scrollFrame = CGRectMake(x, 0, width, rect.size.height);
    _settingsScrollViewiOS = [[UIScrollView alloc] initWithFrame:scrollFrame];
    _settingsScrollViewiOS.backgroundColor = [UIColor clearColor];
    _settingsScrollViewiOS.showsVerticalScrollIndicator = YES;
    _settingsScrollViewiOS.showsHorizontalScrollIndicator = NO;
    
    // Create content view inside scroll view
    CGFloat padding = 20;
    CGFloat lineHeight = 25;
    CGFloat fieldHeight = 35;
    CGFloat buttonHeight = 40;
    CGFloat currentY = padding;
    
    // Section title
    UILabel *titleLabel = [[UILabel alloc] init];
    titleLabel.text = @"Playlist Settings";
    titleLabel.font = [UIFont boldSystemFontOfSize:16];
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight);
    [_settingsScrollViewiOS addSubview:titleLabel];
    [titleLabel release];
    currentY += lineHeight + 20;
    
    // M3U URL Label
    UILabel *m3uLabel = [[UILabel alloc] init];
    m3uLabel.text = @"M3U URL:";
    m3uLabel.font = [UIFont systemFontOfSize:14];
    m3uLabel.textColor = [UIColor whiteColor];
    m3uLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight);
    [_settingsScrollViewiOS addSubview:m3uLabel];
    [m3uLabel release];
    currentY += lineHeight + 5;
    
    // M3U URL Text Field
    [self createOrUpdateM3UTextField:CGRectMake(padding, currentY, width - (padding * 2), fieldHeight) inParent:_settingsScrollViewiOS];
    currentY += fieldHeight + 10;
    
    // Load URL Button
    UIButton *loadUrlButton = [self createActionButton:@"Load URL" 
                                                 frame:CGRectMake(padding, currentY, 120, buttonHeight)
                                                action:@selector(loadUrlButtonTapped:)];
    [_settingsScrollViewiOS addSubview:loadUrlButton];
    currentY += buttonHeight + 20;
    
    // EPG URL Label
    UILabel *epgLabel = [[UILabel alloc] init];
    epgLabel.text = @"EPG XML URL (auto-generated):";
    epgLabel.font = [UIFont systemFontOfSize:14];
    epgLabel.textColor = [UIColor whiteColor];
    epgLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight);
    [_settingsScrollViewiOS addSubview:epgLabel];
    [epgLabel release];
    currentY += lineHeight + 5;
    
    // EPG URL Display
    [self createOrUpdateEPGLabel:CGRectMake(padding, currentY, width - (padding * 2), fieldHeight) inParent:_settingsScrollViewiOS];
    currentY += fieldHeight + 10;
    
    // Update EPG Button
    UIButton *updateEpgButton = [self createActionButton:@"Update EPG" 
                                                   frame:CGRectMake(padding, currentY, 120, buttonHeight)
                                                  action:@selector(updateEpgButtonTapped:)];
    [_settingsScrollViewiOS addSubview:updateEpgButton];
    currentY += buttonHeight + 20;
    
    // EPG Time Offset Label
    UILabel *offsetLabel = [[UILabel alloc] init];
    offsetLabel.text = @"EPG Time Offset:";
    offsetLabel.font = [UIFont systemFontOfSize:14];
    offsetLabel.textColor = [UIColor whiteColor];
    offsetLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight);
    [_settingsScrollViewiOS addSubview:offsetLabel];
    [offsetLabel release];
    currentY += lineHeight + 5;
    
    // EPG Time Offset Button
    [self createOrUpdateTimeOffsetButton:CGRectMake(padding, currentY, 150, fieldHeight) inParent:_settingsScrollViewiOS];
    currentY += fieldHeight + 30;
    
    // Additional Settings Section
    UILabel *additionalLabel = [[UILabel alloc] init];
    additionalLabel.text = @"Additional Actions:";
    additionalLabel.font = [UIFont boldSystemFontOfSize:16];
    additionalLabel.textColor = [UIColor whiteColor];
    additionalLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight);
    [_settingsScrollViewiOS addSubview:additionalLabel];
    [additionalLabel release];
    currentY += lineHeight + 15;
    
    // Clear Cache Button
    UIButton *clearCacheButton = [self createActionButton:@"Clear Cache" 
                                                     frame:CGRectMake(padding, currentY, 120, buttonHeight)
                                                    action:@selector(clearCacheButtonTapped:)];
    [_settingsScrollViewiOS addSubview:clearCacheButton];
    currentY += buttonHeight + 10;
    
    // Reload Channels Button
    UIButton *reloadChannelsButton = [self createActionButton:@"Reload Channels" 
                                                         frame:CGRectMake(padding + 130, currentY - buttonHeight, 140, buttonHeight)
                                                        action:@selector(reloadChannelsButtonTapped:)];
    [_settingsScrollViewiOS addSubview:reloadChannelsButton];
    currentY += buttonHeight + 20;
    
    // Instructions
    UILabel *instructionLabel = [[UILabel alloc] init];
    instructionLabel.text = @"Settings changes are automatically saved and sync with the macOS version.";
    instructionLabel.font = [UIFont systemFontOfSize:12];
    instructionLabel.textColor = [UIColor lightGrayColor];
    instructionLabel.numberOfLines = 0;
    instructionLabel.frame = CGRectMake(padding, currentY, width - (padding * 2), lineHeight * 2);
    [_settingsScrollViewiOS addSubview:instructionLabel];
    [instructionLabel release];
    currentY += lineHeight * 2 + padding;
    
    // Set scroll view content size
    _settingsScrollViewiOS.contentSize = CGSizeMake(width, currentY);
    
    [self addSubview:_settingsScrollViewiOS];
}

- (UIButton *)createActionButton:(NSString *)title frame:(CGRect)frame action:(SEL)action {
    UIButton *button = [[UIButton alloc] initWithFrame:frame];
    button.backgroundColor = [UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:0.8];
    [button setTitle:title forState:UIControlStateNormal];
    [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    button.titleLabel.font = [UIFont systemFontOfSize:14];
    button.layer.cornerRadius = 8;
    button.layer.borderWidth = 1;
    button.layer.borderColor = [UIColor colorWithRed:0.0 green:0.4 blue:0.8 alpha:1.0].CGColor;
    
    [button addTarget:self action:action forControlEvents:UIControlEventTouchUpInside];
    
    return [button autorelease];
}

- (void)createOrUpdateM3UTextField:(CGRect)frame {
    [self createOrUpdateM3UTextField:frame inParent:self];
}

- (void)createOrUpdateM3UTextField:(CGRect)frame inParent:(UIView *)parent {
    // Remove existing text field if it exists
    if (_m3uTextFieldiOS) {
        [_m3uTextFieldiOS removeFromSuperview];
        [_m3uTextFieldiOS release];
        _m3uTextFieldiOS = nil;
    }
    
    // Create new text field
    _m3uTextFieldiOS = [[UITextField alloc] initWithFrame:frame];
    _m3uTextFieldiOS.backgroundColor = [UIColor colorWithWhite:0.2 alpha:0.8];
    _m3uTextFieldiOS.textColor = [UIColor whiteColor];
    _m3uTextFieldiOS.font = [UIFont systemFontOfSize:14];
    _m3uTextFieldiOS.borderStyle = UITextBorderStyleRoundedRect;
    _m3uTextFieldiOS.placeholder = @"Enter M3U URL or path";
    _m3uTextFieldiOS.text = self.m3uFilePath ?: @"";
    _m3uTextFieldiOS.delegate = self;
    _m3uTextFieldiOS.returnKeyType = UIReturnKeyDone;
    _m3uTextFieldiOS.clearButtonMode = UITextFieldViewModeWhileEditing;
    
    [parent addSubview:_m3uTextFieldiOS];
}

- (void)createOrUpdateEPGLabel:(CGRect)frame {
    [self createOrUpdateEPGLabel:frame inParent:self];
}

- (void)createOrUpdateEPGLabel:(CGRect)frame inParent:(UIView *)parent {
    // Remove existing label if it exists
    if (_epgLabeliOS) {
        [_epgLabeliOS removeFromSuperview];
        [_epgLabeliOS release];
        _epgLabeliOS = nil;
    }
    
    // Create new label that looks like a text field but is clickable
    _epgLabeliOS = [[UILabel alloc] initWithFrame:frame];
    _epgLabeliOS.backgroundColor = [UIColor colorWithWhite:0.15 alpha:0.8];
    _epgLabeliOS.textColor = [UIColor lightGrayColor];
    _epgLabeliOS.font = [UIFont systemFontOfSize:14];
    _epgLabeliOS.layer.cornerRadius = 8;
    _epgLabeliOS.layer.borderWidth = 1;
    _epgLabeliOS.layer.borderColor = [UIColor darkGrayColor].CGColor;
    _epgLabeliOS.textAlignment = NSTextAlignmentLeft;
    _epgLabeliOS.userInteractionEnabled = YES;
    
    // Set EPG URL text - auto-generate if needed
    NSString *epgText;
    if (self.epgUrl && [self.epgUrl length] > 0) {
        epgText = self.epgUrl;
    } else if (self.m3uFilePath && [self.m3uFilePath hasPrefix:@"http"]) {
        // Auto-generate and display the EPG URL
        [self updateEPGURLFromM3U];
        epgText = self.epgUrl ?: @"Auto-generated from M3U URL";
    } else {
        epgText = @"Enter M3U URL first to auto-generate";
    }
    _epgLabeliOS.text = [NSString stringWithFormat:@"  %@", epgText]; // Add padding
    
    // Add tap gesture
    UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(epgLabelTapped:)];
    [_epgLabeliOS addGestureRecognizer:tapGesture];
    [tapGesture release];
    
    [parent addSubview:_epgLabeliOS];
}

- (void)createOrUpdateTimeOffsetButton:(CGRect)frame {
    [self createOrUpdateTimeOffsetButton:frame inParent:self];
}

- (void)createOrUpdateTimeOffsetButton:(CGRect)frame inParent:(UIView *)parent {
    // Remove existing button if it exists
    if (_timeOffsetButtoniOS) {
        [_timeOffsetButtoniOS removeFromSuperview];
        [_timeOffsetButtoniOS release];
        _timeOffsetButtoniOS = nil;
    }
    
    // Create new button
    _timeOffsetButtoniOS = [[UIButton alloc] initWithFrame:frame];
    _timeOffsetButtoniOS.backgroundColor = [UIColor colorWithWhite:0.2 alpha:0.8];
    [_timeOffsetButtoniOS setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    _timeOffsetButtoniOS.titleLabel.font = [UIFont systemFontOfSize:14];
    _timeOffsetButtoniOS.layer.cornerRadius = 8;
    _timeOffsetButtoniOS.layer.borderWidth = 1;
    _timeOffsetButtoniOS.layer.borderColor = [UIColor darkGrayColor].CGColor;
    _timeOffsetButtoniOS.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
    
    // Set current offset value
    NSInteger offset = (NSInteger)self.epgTimeOffsetHours;
    NSString *offsetText = [NSString stringWithFormat:@"  %+d hours", (int)offset];
    [_timeOffsetButtoniOS setTitle:offsetText forState:UIControlStateNormal];
    
    [_timeOffsetButtoniOS addTarget:self action:@selector(timeOffsetButtonTapped:) forControlEvents:UIControlEventTouchUpInside];
    
    [parent addSubview:_timeOffsetButtoniOS];
}

#pragma mark - Settings Action Handlers (iOS)

- (void)loadUrlButtonTapped:(UIButton *)button {
    NSLog(@"🔧 Load URL button tapped");
    
    // Check current loading states first
    NSLog(@"🔧 Current loading states - M3U: %d, EPG: %d, isLoading: %d", _isDownloadingChannels, _isDownloadingEPG, self.isLoading);
    
    NSString *m3uUrl = _m3uTextFieldiOS.text;
    if (m3uUrl && [m3uUrl length] > 0) {
        // Ensure we have a clean state before starting
        NSLog(@"🔧 About to clear channel loading state...");
        [self clearChannelLoadingState];
        NSLog(@"🔧 Channel loading state cleared - new states: downloading=%d, isLoading=%d", _isDownloadingChannels, self.isLoading);
        
        // Update the property
        self.m3uFilePath = m3uUrl;
        
        // Show proper loading panel like macOS
        [self showLoadingPanel];
        
        // Call the macOS-compatible channel loading method - this will update progress via real callbacks
        [self loadChannelsFromM3uFile:m3uUrl];
        
        // Auto-generate EPG URL
        [self updateEPGURLFromM3U];
        
        // Update EPG label to show the auto-generated URL
        if (_epgLabeliOS) {
            NSString *epgText = self.epgUrl ?: @"Auto-generated from M3U URL";
            _epgLabeliOS.text = [NSString stringWithFormat:@"  %@", epgText];
        }
        
        // Save settings
        [self saveSettings];
        
        NSLog(@"🔧 M3U URL loaded: %@", m3uUrl);
    } else {
        [self showBriefMessage:@"Please enter a valid M3U URL first" at:button.center];
    }
}

- (void)updateEpgButtonTapped:(UIButton *)button {
    NSLog(@"🔧 [UPDATE-EPG-BUTTON] ===== UPDATE EPG BUTTON CLICKED =====");
    
    // Try to auto-generate EPG URL if it's missing
    if (self.m3uFilePath && [self.m3uFilePath hasPrefix:@"http"]) {
        NSString *generatedEpgUrl = [self.m3uFilePath stringByReplacingOccurrencesOfString:@"get.php" withString:@"xmltv.php"];
        
        if (![generatedEpgUrl isEqualToString:self.m3uFilePath]) {
            if (!self.epgUrl || [self.epgUrl length] == 0 || ![self.epgUrl isEqualToString:generatedEpgUrl]) {
                self.epgUrl = generatedEpgUrl;
                [self saveSettings]; // Save the updated URL
            }
        }
    }
    
    NSString *epgUrl = self.epgUrl;
    
    if (epgUrl && [epgUrl length] > 0) {
        // Show loading panel
        [self showLoadingPanel];
        
        // FORCE FRESH EPG DOWNLOAD: Use the existing forceReloadEpgData method
        NSLog(@"🔧 [UPDATE-EPG] About to call forceReloadEpgData");
        if ([self respondsToSelector:@selector(forceReloadEpgData)]) {
            NSLog(@"🔧 [UPDATE-EPG] ✅ forceReloadEpgData method is available - calling it");
            [self forceReloadEpgData];
        } else {
            NSLog(@"🔧 [UPDATE-EPG] ❌ forceReloadEpgData method not available - falling back to loadEpgDataWithRetryCount");
            // Fallback: bypass cache manually and call direct download
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [self loadEpgDataWithRetryCount:0];
            });
        }
    } else {
        [self showBriefMessage:@"Load M3U URL first to generate EPG URL" at:button.center];
    }
}



#pragma mark - Settings UI Actions (iOS)

- (void)epgLabelTapped:(UITapGestureRecognizer *)gesture {
    NSString *epgUrl = self.epgUrl;
    if (epgUrl && [epgUrl length] > 0) {
        #if TARGET_OS_IOS
        // Copy EPG URL to clipboard (iOS only)
        UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
        pasteboard.string = epgUrl;
        [self showBriefMessage:@"EPG URL copied to clipboard" at:_epgLabeliOS.center];
        #else
        // tvOS doesn't have clipboard
        [self showBriefMessage:@"EPG URL displayed (clipboard not available on tvOS)" at:_epgLabeliOS.center];
        #endif
    } else {
        [self showBriefMessage:@"Enter M3U URL first to generate EPG URL" at:_epgLabeliOS.center];
    }
}

- (void)timeOffsetButtonTapped:(UIButton *)button {
    NSLog(@"🔧 Time offset button tapped");
    
    // Create action sheet with time offset options
    UIAlertController *actionSheet = [UIAlertController alertControllerWithTitle:@"EPG Time Offset" 
                                                                         message:@"Select timezone offset for EPG data" 
                                                                  preferredStyle:UIAlertControllerStyleActionSheet];
    
    // Add offset options from -12 to +12 hours
    for (NSInteger offset = -12; offset <= 12; offset++) {
        NSString *title = [NSString stringWithFormat:@"%+d hours", (int)offset];
        UIAlertAction *action = [UIAlertAction actionWithTitle:title style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
            [self setEpgTimeOffset:offset];
        }];
        [actionSheet addAction:action];
    }
    
    // Add cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [actionSheet addAction:cancelAction];
    
    // Configure popover for iPad
    if (actionSheet.popoverPresentationController) {
        actionSheet.popoverPresentationController.sourceView = button;
        actionSheet.popoverPresentationController.sourceRect = button.bounds;
        actionSheet.popoverPresentationController.permittedArrowDirections = UIPopoverArrowDirectionAny;
    }
    
    // Present action sheet
    UIViewController *rootVC = [self findRootViewController];
    if (rootVC) {
        [rootVC presentViewController:actionSheet animated:YES completion:nil];
    }
}

- (void)setEpgTimeOffset:(NSInteger)offset {
    // Update the offset value
    self.epgTimeOffsetHours = offset;
    
    // Update button title
    NSString *offsetText = [NSString stringWithFormat:@"%+d hours", (int)offset];
    [_timeOffsetButtoniOS setTitle:offsetText forState:UIControlStateNormal];
    
    NSLog(@"🔧 EPG time offset set to %+d hours", (int)offset);
}

- (void)showBriefMessage:(NSString *)message at:(CGPoint)point {
    // Create a brief popup message
    UILabel *messageLabel = [[UILabel alloc] init];
    messageLabel.text = message;
    messageLabel.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.8];
    messageLabel.textColor = [UIColor whiteColor];
    messageLabel.font = [UIFont systemFontOfSize:12];
    messageLabel.textAlignment = NSTextAlignmentCenter;
    messageLabel.layer.cornerRadius = 6;
    messageLabel.clipsToBounds = YES;
    
    // Size to fit content
    [messageLabel sizeToFit];
    CGRect frame = messageLabel.frame;
    frame.size.width += 20; // Add padding
    frame.size.height += 10;
    messageLabel.frame = frame;
    messageLabel.center = point;
    
    [self addSubview:messageLabel];
    
    // Fade out after 2 seconds
    [UIView animateWithDuration:0.3 delay:2.0 options:0 animations:^{
        messageLabel.alpha = 0.0;
    } completion:^(BOOL finished) {
        [messageLabel removeFromSuperview];
        [messageLabel release];
    }];
}

#pragma mark - Loading Panel (iOS - matching macOS style)

- (void)showLoadingPanel {
    // Remove existing panel if it exists
    [self hideLoadingPanel];
    
    // Create loading panel container (positioned at bottom right like macOS)
    CGFloat panelWidth = 300;
    CGFloat panelHeight = 120;
    CGFloat padding = 20;
    CGFloat panelX = self.bounds.size.width - panelWidth - padding;
    CGFloat panelY = self.bounds.size.height - panelHeight - padding;
    
    _loadingPaneliOS = [[UIView alloc] initWithFrame:CGRectMake(panelX, panelY, panelWidth, panelHeight)];
    _loadingPaneliOS.backgroundColor = [UIColor colorWithWhite:0.1 alpha:0.9];
    _loadingPaneliOS.layer.cornerRadius = 12;
    _loadingPaneliOS.layer.borderWidth = 1;
    _loadingPaneliOS.layer.borderColor = [UIColor colorWithWhite:0.3 alpha:1.0].CGColor;
    _loadingPaneliOS.layer.shadowColor = [UIColor blackColor].CGColor;
    _loadingPaneliOS.layer.shadowOffset = CGSizeMake(0, 2);
    _loadingPaneliOS.layer.shadowOpacity = 0.5;
    _loadingPaneliOS.layer.shadowRadius = 4;
    
    CGFloat contentPadding = 15;
    CGFloat currentY = contentPadding;
    
    // Loading title
    UILabel *titleLabel = [[UILabel alloc] init];
    titleLabel.text = @"Loading...";
    titleLabel.font = [UIFont boldSystemFontOfSize:16];
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.frame = CGRectMake(contentPadding, currentY, panelWidth - (contentPadding * 2), 20);
    [_loadingPaneliOS addSubview:titleLabel];
    [titleLabel release];
    currentY += 25;
    
    // M3U Progress Label
    _m3uProgressLabeliOS = [[UILabel alloc] init];
    _m3uProgressLabeliOS.text = @"M3U: Ready";
    _m3uProgressLabeliOS.font = [UIFont systemFontOfSize:12];
    _m3uProgressLabeliOS.textColor = [UIColor lightGrayColor];
    _m3uProgressLabeliOS.frame = CGRectMake(contentPadding, currentY, panelWidth - (contentPadding * 2), 15);
    [_loadingPaneliOS addSubview:_m3uProgressLabeliOS];
    currentY += 18;
    
    // M3U Progress Bar
    _m3uProgressBariOS = [[UIProgressView alloc] initWithProgressViewStyle:UIProgressViewStyleDefault];
    _m3uProgressBariOS.frame = CGRectMake(contentPadding, currentY, panelWidth - (contentPadding * 2), 2);
    _m3uProgressBariOS.progressTintColor = [UIColor colorWithRed:0.0 green:0.6 blue:1.0 alpha:1.0];
    _m3uProgressBariOS.trackTintColor = [UIColor colorWithWhite:0.3 alpha:1.0];
    _m3uProgressBariOS.progress = 0.0f;
    [_loadingPaneliOS addSubview:_m3uProgressBariOS];
    currentY += 15;
    
    // EPG Progress Label
    _epgProgressLabeliOS = [[UILabel alloc] init];
    _epgProgressLabeliOS.text = @"EPG: Ready";
    _epgProgressLabeliOS.font = [UIFont systemFontOfSize:12];
    _epgProgressLabeliOS.textColor = [UIColor lightGrayColor];
    _epgProgressLabeliOS.frame = CGRectMake(contentPadding, currentY, panelWidth - (contentPadding * 2), 15);
    [_loadingPaneliOS addSubview:_epgProgressLabeliOS];
    currentY += 18;
    
    // EPG Progress Bar
    _epgProgressBariOS = [[UIProgressView alloc] initWithProgressViewStyle:UIProgressViewStyleDefault];
    _epgProgressBariOS.frame = CGRectMake(contentPadding, currentY, panelWidth - (contentPadding * 2), 2);
    _epgProgressBariOS.progressTintColor = [UIColor colorWithRed:0.0 green:0.8 blue:0.4 alpha:1.0];
    _epgProgressBariOS.trackTintColor = [UIColor colorWithWhite:0.3 alpha:1.0];
    _epgProgressBariOS.progress = 0.0f;
    [_loadingPaneliOS addSubview:_epgProgressBariOS];
    
    // Add panel to view with animation
    _loadingPaneliOS.alpha = 0.0;
    _loadingPaneliOS.transform = CGAffineTransformMakeScale(0.8, 0.8);
    [self addSubview:_loadingPaneliOS];
    
    [UIView animateWithDuration:0.3 delay:0 usingSpringWithDamping:0.8 initialSpringVelocity:0 options:0 animations:^{
        self->_loadingPaneliOS.alpha = 1.0;
        self->_loadingPaneliOS.transform = CGAffineTransformIdentity;
    } completion:nil];
}

- (void)hideLoadingPanel {
    if (_loadingPaneliOS) {
        [UIView animateWithDuration:0.2 animations:^{
            self->_loadingPaneliOS.alpha = 0.0;
            self->_loadingPaneliOS.transform = CGAffineTransformMakeScale(0.9, 0.9);
        } completion:^(BOOL finished) {
            [self->_loadingPaneliOS removeFromSuperview];
            [self->_loadingPaneliOS release];
            self->_loadingPaneliOS = nil;
            
            // Clean up progress elements
            [self->_m3uProgressLabeliOS release];
            self->_m3uProgressLabeliOS = nil;
            [self->_m3uProgressBariOS release];
            self->_m3uProgressBariOS = nil;
            [self->_epgProgressLabeliOS release];
            self->_epgProgressLabeliOS = nil;
            [self->_epgProgressBariOS release];
            self->_epgProgressBariOS = nil;
        }];
    }
}

- (void)updateLoadingProgress:(float)progress status:(NSString *)status {
    if (_m3uProgressBariOS && _m3uProgressLabeliOS) {
        _m3uProgressBariOS.progress = progress;
        _m3uProgressLabeliOS.text = [NSString stringWithFormat:@"M3U: %@", status];
        
        // Only set properties if they're different to avoid recursion
        if (self.isLoading != (progress < 1.0f)) {
            _isLoading = progress < 1.0f; // Set backing variable directly
        }
        
        // Auto-hide loading panel when complete
        if (progress >= 1.0f) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (!self.isLoadingEpg) { // Only hide if EPG is not loading
                    [self hideLoadingPanel];
                    [self showBriefMessage:@"M3U file loaded successfully" at:CGPointMake(self.bounds.size.width - 150, self.bounds.size.height - 50)];
                }
            });
        }
    }
}

- (void)updateEPGLoadingProgress:(float)progress status:(NSString *)status {
    if (_epgProgressBariOS && _epgProgressLabeliOS) {
        _epgProgressBariOS.progress = progress;
        _epgProgressLabeliOS.text = [NSString stringWithFormat:@"EPG: %@", status];
        
        // Only set properties if they're different to avoid recursion
        if (self.isLoadingEpg != (progress < 1.0f)) {
            _isLoadingEpg = progress < 1.0f; // Set backing variable directly
        }
        
        // Auto-hide loading panel when complete
        if (progress >= 1.0f) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (!self.isLoading) { // Only hide if M3U is not loading
                    [self hideLoadingPanel];
                    [self showBriefMessage:@"EPG data updated successfully" at:CGPointMake(self.bounds.size.width - 150, self.bounds.size.height - 50)];
                }
            });
        }
    }
}

#pragma mark - UITextFieldDelegate (iOS)

- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    [textField resignFirstResponder];
    return YES;
}

- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
    if (textField == _m3uTextFieldiOS) {
        // Get the text that will be in the field after this change
        NSString *newText = [textField.text stringByReplacingCharactersInRange:range withString:string];
        
        // Real-time EPG URL generation as user types (like macOS)
        NSLog(@"🔧 [REAL-TIME] M3U URL changing to: %@", newText);
        
        // Auto-generate EPG URL from the new M3U URL in real-time
        if (newText && [newText length] > 0 && [newText hasPrefix:@"http"]) {
            NSString *generatedEpgUrl = [newText stringByReplacingOccurrencesOfString:@"get.php" withString:@"xmltv.php"];
            
            // Fallback: Also try .m3u to .xml replacement for different URL formats
            if ([generatedEpgUrl isEqualToString:newText]) {
                // No replacement occurred, try file extension replacement
                generatedEpgUrl = [newText stringByReplacingOccurrencesOfString:@".m3u" withString:@".xml"];
                generatedEpgUrl = [generatedEpgUrl stringByReplacingOccurrencesOfString:@".M3U" withString:@".xml"];
            }
            
            // Only update if it generated a different URL
            if (![generatedEpgUrl isEqualToString:newText] && [generatedEpgUrl length] > 0) {
                self.epgUrl = generatedEpgUrl;
                NSLog(@"🔧 [REAL-TIME] Auto-generated EPG URL: %@", generatedEpgUrl);
                
                // Update EPG label immediately
                if (_epgLabeliOS) {
                    _epgLabeliOS.text = [NSString stringWithFormat:@"  %@", generatedEpgUrl];
                }
            }
        } else if ([newText length] == 0) {
            // Clear EPG URL when M3U URL is empty
            self.epgUrl = @"";
            if (_epgLabeliOS) {
                _epgLabeliOS.text = @"  Enter M3U URL first to auto-generate";
            }
            NSLog(@"🔧 [REAL-TIME] Cleared EPG URL (M3U URL is empty)");
        }
        
        // Temporarily store the new M3U text for real-time feedback
        // Note: Don't save to self.m3uFilePath yet - wait for textFieldDidEndEditing
    }
    
    // Allow the text change
    return YES;
}

- (void)textFieldDidEndEditing:(UITextField *)textField {
    if (textField == _m3uTextFieldiOS) {
        // Update M3U file path (final save)
        self.m3uFilePath = textField.text;
        NSLog(@"🔧 M3U URL finalized to: %@", textField.text);
        
        // Final EPG URL update and save
        [self updateEPGURLFromM3U];
        
        // Final EPG label refresh
        if (_epgLabeliOS) {
            NSString *epgText = self.epgUrl ?: @"Auto-generated from M3U URL";
            _epgLabeliOS.text = [NSString stringWithFormat:@"  %@", epgText];
        }
        
        // Save settings
        [self saveSettings];
    }
}

- (void)updateEPGURLFromM3U {
    NSString *m3uUrl = self.m3uFilePath;
    if (m3uUrl && [m3uUrl hasPrefix:@"http"]) {
        // Generate EPG URL by replacing get.php with xmltv.php (like macOS)
        // This keeps all parameters including type=m3u_plus intact
        NSString *epgUrl = [m3uUrl stringByReplacingOccurrencesOfString:@"get.php" withString:@"xmltv.php"];
        
        // Fallback: Also try .m3u to .xml replacement for different URL formats
        if ([epgUrl isEqualToString:m3uUrl]) {
            // No replacement occurred, try file extension replacement
            epgUrl = [m3uUrl stringByReplacingOccurrencesOfString:@".m3u" withString:@".xml"];
            epgUrl = [epgUrl stringByReplacingOccurrencesOfString:@".M3U" withString:@".xml"];
        }
        
        self.epgUrl = epgUrl;
        NSLog(@"🔧 EPG URL auto-generated from M3U: %@", epgUrl);
        NSLog(@"🔧 Original M3U URL: %@", m3uUrl);
    } else {
        NSLog(@"🔧 Cannot auto-generate EPG URL - M3U URL is invalid or missing");
    }
}

- (UIViewController *)findRootViewController {
    // Find the root view controller properly for iOS 13+
    UIViewController *rootVC = nil;
    
    if (@available(iOS 13.0, *)) {
        // Use connected scenes for iOS 13+
        for (UIWindowScene *scene in [UIApplication sharedApplication].connectedScenes) {
            if (scene.activationState == UISceneActivationStateForegroundActive) {
                for (UIWindow *window in scene.windows) {
                    if (window.isKeyWindow) {
                        rootVC = window.rootViewController;
                        break;
                    }
                }
                if (rootVC) break;
            }
        }
    } else {
        // Fallback for iOS 12 and earlier
        #pragma clang diagnostic push
        #pragma clang diagnostic ignored "-Wdeprecated-declarations"
        rootVC = [UIApplication sharedApplication].keyWindow.rootViewController;
        #pragma clang diagnostic pop
    }
    
    // Find the topmost presented view controller
    while (rootVC.presentedViewController) {
        rootVC = rootVC.presentedViewController;
    }
    
    return rootVC;
}

#pragma mark - Data Access Methods (Shared with macOS)

- (NSArray *)getGroupsForSelectedCategory {
    // Use real data structures like macOS but with safe property access
    //NSLog(@"🔧 Universal getGroupsForSelectedCategory called");
    
    // Ensure data structures are initialized
    [self ensureDataStructuresInitialized];
    
    NSString *categoryKey = @"";
    switch (_selectedCategoryIndex) {
        case CATEGORY_SEARCH: categoryKey = @"SEARCH"; break;
        case CATEGORY_FAVORITES: categoryKey = @"FAVORITES"; break;
        case CATEGORY_TV: categoryKey = @"TV"; break;
        case CATEGORY_MOVIES: categoryKey = @"MOVIES"; break;
        case CATEGORY_SERIES: categoryKey = @"SERIES"; break;
        case CATEGORY_SETTINGS: categoryKey = @"SETTINGS"; break;
        default: categoryKey = @"SETTINGS"; break;
    }
    
    // Use property accessor for safe access
    NSMutableDictionary *groupsByCategory = self.groupsByCategory;
    if (!groupsByCategory) {
        //NSLog(@"⚠️ groupsByCategory property is nil, using fallback");
        return [categoryKey isEqualToString:@"SETTINGS"] ? @[@"General", @"Playlist"] : @[@"General"];
    }
    
    NSArray *groups = [groupsByCategory objectForKey:categoryKey];
    return groups ?: ([categoryKey isEqualToString:@"SETTINGS"] ? @[@"Playlist", @"General", @"Subtitles", @"Movie Info", @"Themes"] : @[@"General"]);
}

- (NSArray *)getChannelsForCurrentGroup {
   // NSLog(@"🔧 iOS getChannelsForCurrentGroup - returning real channel data");
    
    // Handle no group selection
    if (_selectedGroupIndex < 0) {
        //NSLog(@"🔧 No group selected - returning empty array");
        return @[];
    }
    
    // Get groups for selected category
    NSArray *groups = [self getGroupsForSelectedCategory];
    if (_selectedGroupIndex >= groups.count) {
        //NSLog(@"🔧 Selected group index out of bounds - returning empty array");
        return @[];
    }
    
    // Get the selected group name
    NSString *groupName = groups[_selectedGroupIndex];
    //NSLog(@"🔧 Getting channels for group: %@", groupName);
    
    // Return channels from channelsByGroup dictionary
    if (_channelsByGroup && groupName) {
        NSArray *channelsInGroup = [_channelsByGroup objectForKey:groupName];
        if (channelsInGroup && [channelsInGroup count] > 0) {
            //NSLog(@"🔧 Found %lu real channels in group: %@", (unsigned long)[channelsInGroup count], groupName);
            
            // Debug: Check what type of objects are in the array
            if ([channelsInGroup count] > 0) {
                id firstObject = [channelsInGroup objectAtIndex:0];
                //NSLog(@"🔧 First object in channels array is type: %@", [firstObject class]);
                if ([firstObject isKindOfClass:[VLCChannel class]]) {
                    VLCChannel *channel = (VLCChannel *)firstObject;
                    //NSLog(@"🔧 First channel name: %@, group: %@", channel.name, channel.group);
                } else if ([firstObject isKindOfClass:[NSString class]]) {
                    //NSLog(@"🔧 First object is a string: %@", (NSString *)firstObject);
                }
            }
            
            return channelsInGroup;
        }
    }
    
    // If no channels found in the data structures, check if we're in settings
    if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
        //NSLog(@"🔧 Settings category - returning empty array (handled by settings panel)");
        return @[];
    }
    
    // No channels loaded yet
    //NSLog(@"🔧 No channels loaded for group: %@", groupName);
    return @[];
}

#pragma mark - Channel Data Preparation (Shared with macOS)

- (void)prepareSimpleChannelLists {
    @synchronized(self) {
        @try {
            // Get current category and group
            NSString *currentCategory = nil;
            NSArray *categoryTitles = @[@"SEARCH", @"FAVORITES", @"TV", @"MOVIES", @"SERIES", @"SETTINGS"];
            if (_selectedCategoryIndex >= 0 && _selectedCategoryIndex < categoryTitles.count) {
                currentCategory = [categoryTitles objectAtIndex:_selectedCategoryIndex];
            }
            
            NSString *currentGroup = nil;
            NSArray *groups = [self getGroupsForSelectedCategory];
            
            // Get the current group from the selected index
            if (groups && _selectedGroupIndex >= 0 && _selectedGroupIndex < groups.count) {
                currentGroup = [groups objectAtIndex:_selectedGroupIndex];
            }
            
            // Get channels for the current group
            NSArray *channelsInGroup = nil;
            if (currentGroup && _channelsByGroup) {
                channelsInGroup = [_channelsByGroup objectForKey:currentGroup];
            }
            
            // Create simple arrays for the UI
            NSMutableArray *names = [NSMutableArray array];
            NSMutableArray *urls = [NSMutableArray array];
            
            if (channelsInGroup && [channelsInGroup count] > 0) {
                for (VLCChannel *channel in channelsInGroup) {
                    if ([channel isKindOfClass:[VLCChannel class]]) {
                        [names addObject:channel.name ? channel.name : @"Unknown"];
                        [urls addObject:channel.url ? channel.url : @""];
                    }
                }
            }
            
            // Update the simple lists with the new data (if they exist as properties)
            if ([self respondsToSelector:@selector(setSimpleChannelNames:)]) {
                [self setValue:[names copy] forKey:@"simpleChannelNames"];
            }
            if ([self respondsToSelector:@selector(setSimpleChannelUrls:)]) {
                [self setValue:[names copy] forKey:@"simpleChannelUrls"];
            }
            
            NSLog(@"📺 prepareSimpleChannelLists - prepared %lu channels for group: %@", 
                  (unsigned long)names.count, currentGroup ?: @"(none)");
            
        } @catch (NSException *exception) {
            NSLog(@"❌ Exception in prepareSimpleChannelLists: %@", exception);
        }
    }
}

#pragma mark - Gesture Handlers

- (void)handleSingleTap:(UITapGestureRecognizer *)gesture {
    CGPoint tapPoint = [gesture locationInView:self];
    
    // Calculate responsive dimensions for tap handling
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat programGuideWidth = [self programGuideWidth];
    CGFloat channelAreaWidth = self.bounds.size.width - categoryWidth - groupWidth - programGuideWidth;
    CGFloat totalUIWidth = categoryWidth + groupWidth + channelAreaWidth;
    CGFloat programGuideX = totalUIWidth;
    
    if (!_isChannelListVisible) {
        // Only show channel list if tapping in the UI areas (left side), not on video area (right side)
        if (tapPoint.x < totalUIWidth) {
            _isChannelListVisible = YES;
            [self setNeedsDisplay];
        }
        // If tapping on video area (right side), do nothing - keep menu hidden
        return;
    }
    
    // Menu is visible - handle taps in different regions
    if (tapPoint.x < categoryWidth) {
        // Tap in categories area
        [self handleCategoryTap:tapPoint];
    } else if (tapPoint.x < categoryWidth + groupWidth) {
        // Tap in groups area
        [self handleGroupTap:tapPoint];
    } else if (tapPoint.x < totalUIWidth) {
        // Tap in channel list area
        [self handleChannelTapWithGesture:gesture];
    } else if (tapPoint.x < programGuideX + programGuideWidth) {
        // Tap in program guide area
        [self handleEpgTap:tapPoint];
    } else {
        // Tap in video area (right side) - hide the menu and all settings
        [self hideAllSettingsScrollViews];
        _isChannelListVisible = NO;
        [self setNeedsDisplay];
    }
}

- (void)handleEpgTap:(CGPoint)tapPoint {
    // Check if we have a channel with EPG data
    VLCChannel *channel = [self getChannelAtIndex:_hoveredChannelIndex >= 0 ? _hoveredChannelIndex : _selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) {
        return;
    }
    
    // Calculate which program was tapped
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat programGuideWidth = [self programGuideWidth];
    CGFloat channelAreaWidth = self.bounds.size.width - categoryWidth - groupWidth - programGuideWidth;
    CGFloat programGuideX = categoryWidth + groupWidth + channelAreaWidth;
    
    // Calculate program guide area dimensions
    CGFloat programHeight = 60;
    CGFloat programSpacing = 5;
    CGFloat contentStartY = self.bounds.size.height - 90; // Leave space for channel name
    
    // Calculate tapped program relative to scroll position
    CGFloat relativeY = tapPoint.y - 20; // Account for top margin
    CGFloat scrollAdjustedY = relativeY + _programGuideScrollPosition;
    NSInteger tappedProgramIndex = (NSInteger)(scrollAdjustedY / (programHeight + programSpacing));
    
    // Sort programs by start time to match display order
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    // Validate tapped program index
    if (tappedProgramIndex >= 0 && tappedProgramIndex < sortedPrograms.count) {
        // Enable EPG navigation mode and select the tapped program
        self.epgNavigationMode = YES;
        self.selectedEpgProgramIndex = tappedProgramIndex;
        
        VLCProgram *tappedProgram = sortedPrograms[tappedProgramIndex];
        NSLog(@"📺 [iOS-EPG-TAP] Selected program %ld: %@ at %@", 
              (long)tappedProgramIndex, tappedProgram.title, tappedProgram.startTime);
        
        [self setNeedsDisplay];
        
        // Start timer to auto-clear selection after 5 seconds (shorter than channel hover)
        [self startEpgSelectionClearTimer];
    }
}

- (void)startEpgSelectionClearTimer {
    // Clear any existing timer
    [self.hoverClearTimer invalidate];
    self.hoverClearTimer = nil;
    
    // Start new timer to clear EPG selection after 5 seconds
    self.hoverClearTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
                                                            target:self
                                                          selector:@selector(clearEpgSelection)
                                                          userInfo:nil
                                                           repeats:NO];
}

- (void)clearEpgSelection {
    if (self.epgNavigationMode) {
        self.epgNavigationMode = NO;
        self.selectedEpgProgramIndex = -1;
        [self setNeedsDisplay];
        NSLog(@"📺 [iOS-EPG] Auto-cleared EPG selection after timeout");
    }
    
    self.hoverClearTimer = nil;
}

- (void)handleCategoryTap:(CGPoint)point {
    NSInteger categoryIndex = (NSInteger)(point.y / [self rowHeight]);
    if (categoryIndex >= 0 && categoryIndex < 6) { // 6 categories
        NSInteger previousCategoryIndex = _selectedCategoryIndex;
        _selectedCategoryIndex = categoryIndex;
        _selectedGroupIndex = -1; // Reset group selection
        
        // Clear hover state when switching categories
        _hoveredChannelIndex = -1;
        [self.hoverClearTimer invalidate];
        self.hoverClearTimer = nil;
        
        // Handle settings panel visibility and hide all settings scroll views when switching
        if (previousCategoryIndex == CATEGORY_SETTINGS && categoryIndex != CATEGORY_SETTINGS) {
            // Switching away from Settings - hide the settings panel and all scroll views
            [self hideSettingsPanel];
            [self hideAllSettingsScrollViews];
        } else if (categoryIndex == CATEGORY_SETTINGS && previousCategoryIndex != CATEGORY_SETTINGS) {
            // Switching to Settings - show the settings panel
            [self showSettingsPanel];
        }
        
        // Always hide all settings scroll views when switching categories (not just from settings)
        [self hideAllSettingsScrollViews];
        
        [self setNeedsDisplay];
    }
}

- (void)handleGroupTap:(CGPoint)point {
    NSInteger groupIndex = (NSInteger)((point.y + _groupScrollPosition) / [self rowHeight]);
    NSArray *groups = [self getGroupsForSelectedCategory];
    if (groupIndex >= 0 && groupIndex < groups.count) {
        _selectedGroupIndex = groupIndex;
        _selectedChannelIndex = -1; // Reset channel selection when switching groups
        _channelScrollPosition = 0; // Reset channel scroll when switching groups
        
        // Clear hover state when switching groups
        _hoveredChannelIndex = -1;
        [self.hoverClearTimer invalidate];
        self.hoverClearTimer = nil;
        
        // Always hide all settings scroll views when switching groups (fixes visibility issue)
        [self hideAllSettingsScrollViews];
        
        [self setNeedsDisplay];
        NSLog(@"🎯 Selected group: %@ (index: %ld)", groups[groupIndex], (long)groupIndex);
    }
}

- (void)handleChannelTapWithGesture:(UITapGestureRecognizer *)gesture {
    CGPoint point = [gesture locationInView:self];
    
    // Check if we're in settings category and handle settings panel taps
    if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
        [self handleSettingsPanelTap:point];
        return;
    }
    
    NSArray *channels = [self getChannelsForCurrentGroup];
    NSInteger channelIndex = (NSInteger)((point.y + _channelScrollPosition) / [self rowHeight]);
    if (channelIndex >= 0 && channelIndex < channels.count) {
        
        // Check if this is a force touch (3D Touch on supported devices)
        BOOL isForceTouch = NO;
        if (@available(iOS 9.0, *)) {
            if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) {
                // Check for force - threshold for "hard press"
                CGFloat forceThreshold = 2.0; // Adjust as needed
                if (gesture.view.gestureRecognizers.count > 0) {
                    // Try to get force from the gesture (this requires setup in the view controller)
                    // For now, we'll use a simpler approach
                }
            }
        }
        
        if (isForceTouch) {
            // Force touch = select and play channel immediately
            _selectedChannelIndex = channelIndex;
            _hoveredChannelIndex = -1; // Clear hover when selecting
            
            // Play the selected channel
            [self playChannelAtIndex:channelIndex];
            
            // Hide menu and all settings after selection
            [self hideAllSettingsScrollViews];
            _isChannelListVisible = NO;
            [self setNeedsDisplay];
            
            NSLog(@"💪 Force touch - Playing channel: %ld", (long)channelIndex);
        } else {
            // Normal light tap = hover effect (like macOS hover)
            // This just highlights the channel without playing it
            _hoveredChannelIndex = channelIndex;
            
            // Don't change selected channel or play anything
            // This gives the user a preview of which channel they're about to select
            [self setNeedsDisplay];
            
            // Start/restart timer to clear hover after 10 seconds
            [self startHoverClearTimer];
            
            NSLog(@"🎯 ✅ Light tap - Set hoveredChannelIndex to: %ld (should show program guide)", (long)channelIndex);
        }
    }
}

// Keep the old method for backward compatibility (used in settings)
- (void)handleChannelTap:(CGPoint)point {
    // Legacy method - just create a fake gesture for the new method
    // This is used by settings panel handling
    if (_selectedCategoryIndex == CATEGORY_SETTINGS) {
        [self handleSettingsPanelTap:point];
        return;
    }
    
    // For non-settings, redirect to the new gesture-aware method
    // Create a minimal gesture object (this is a bit of a hack but works)
    NSArray *channels = [self getChannelsForCurrentGroup];
    NSInteger channelIndex = (NSInteger)((point.y + _channelScrollPosition) / [self rowHeight]);
    if (channelIndex >= 0 && channelIndex < channels.count) {
        // Just do hover behavior for legacy calls
        _hoveredChannelIndex = channelIndex;
        [self setNeedsDisplay];
        NSLog(@"🎯 Legacy hover over channel: %ld", (long)channelIndex);
    }
}

- (void)handleSettingsPanelTap:(CGPoint)point {
    // Handle taps in the settings panel area
    if (_selectedGroupIndex >= 0) {
        NSArray *settingsGroups = [self getGroupsForSelectedCategory];
        if (_selectedGroupIndex < settingsGroups.count) {
            NSString *selectedGroup = settingsGroups[_selectedGroupIndex];
            
            if ([selectedGroup isEqualToString:@"Movie Info"]) {
                // Check if tap is on clear cache button
                if (CGRectContainsPoint(_clearMovieInfoCacheButtonRect, point)) {
                    [self clearMovieInfoCache];
                }
            }
            // Add more settings button handling here for other groups as needed
        }
    }
}

- (void)clearMovieInfoCache {
    // Get cache directory paths
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *cacheDir = [documentsPath stringByAppendingPathComponent:@"VLCCache"];
    NSString *movieInfoCacheDir = [cacheDir stringByAppendingPathComponent:@"MovieInfo"];
    NSString *posterCacheDir = [cacheDir stringByAppendingPathComponent:@"Posters"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    // Clear movie info cache
    if ([fileManager fileExistsAtPath:movieInfoCacheDir]) {
        [fileManager removeItemAtPath:movieInfoCacheDir error:&error];
        if (error) {
            NSLog(@"❌ Error clearing movie info cache: %@", error.localizedDescription);
        } else {
            NSLog(@"✅ Movie info cache cleared successfully");
        }
    }
    
    // Clear poster cache
    if ([fileManager fileExistsAtPath:posterCacheDir]) {
        [fileManager removeItemAtPath:posterCacheDir error:&error];
        if (error) {
            NSLog(@"❌ Error clearing poster cache: %@", error.localizedDescription);
        } else {
            NSLog(@"✅ Poster cache cleared successfully");
        }
    }
    
    // Recreate directories for future use
    [fileManager createDirectoryAtPath:movieInfoCacheDir withIntermediateDirectories:YES attributes:nil error:&error];
    [fileManager createDirectoryAtPath:posterCacheDir withIntermediateDirectories:YES attributes:nil error:&error];
    
    // Refresh the settings panel to show updated cache counts
    [self setNeedsDisplay];
    
    // Show success message (optional - could add a temporary overlay)
    NSLog(@"🧹 Movie info and poster caches have been cleared");
}

#pragma mark - Hover State Management

- (void)startHoverClearTimer {
    // DISABLED: Program guide should stay open as long as menu is open
    // The program guide relies on hoveredChannelIndex and should only close when menu closes
    // Timer was causing program guide to disappear after 10 seconds which is bad UX
    
    // Cancel any existing timer but don't start a new one
    [self.hoverClearTimer invalidate];
    self.hoverClearTimer = nil;
    
    NSLog(@"🎯 Hover clear timer disabled - program guide will stay open with menu");
    
    // NOTE: Hover state will now only be cleared when:
    // 1. Menu is closed (hoveredChannelIndex = -1)
    // 2. User explicitly selects a different channel
    // 3. User navigates away from the channel
}

- (void)clearHoverState {
    if (_hoveredChannelIndex >= 0) {
        _hoveredChannelIndex = -1;
        [self setNeedsDisplay];
        NSLog(@"⏰ Hover state cleared automatically");
    }
    self.hoverClearTimer = nil;
}

#if TARGET_OS_IOS
- (void)handleDoubleTap:(UITapGestureRecognizer *)gesture {
    CGPoint tapPoint = [gesture locationInView:self];
    
    // Calculate responsive dimensions for double tap handling
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat programGuideWidth = [self programGuideWidth];
    CGFloat channelAreaWidth = self.bounds.size.width - categoryWidth - groupWidth - programGuideWidth;
    CGFloat totalUIWidth = categoryWidth + groupWidth + channelAreaWidth;
    CGFloat programGuideX = totalUIWidth;
    
    if (!_isChannelListVisible) {
        return; // Don't handle double taps when menu is hidden
    }
    
    // Check if double tap is in the channel area
    if (tapPoint.x >= categoryWidth + groupWidth && tapPoint.x < totalUIWidth) {
        // Double tap in channel area = select and play channel
        if (_selectedCategoryIndex != CATEGORY_SETTINGS) {
            NSArray *channels = [self getChannelsForCurrentGroup];
            NSInteger channelIndex = (NSInteger)((tapPoint.y + _channelScrollPosition) / [self rowHeight]);
            if (channelIndex >= 0 && channelIndex < channels.count) {
                _selectedChannelIndex = channelIndex;
                _hoveredChannelIndex = -1; // Clear hover when selecting
                
                // Play the selected channel
                [self playChannelAtIndex:channelIndex];
                
                // Hide menu after selection
                _isChannelListVisible = NO;
                [self setNeedsDisplay];
                
                NSLog(@"🎬 Double tap - Playing channel: %ld", (long)channelIndex);
                return;
            }
        }
    } else if (tapPoint.x >= programGuideX && tapPoint.x < programGuideX + programGuideWidth) {
        // Double tap in program guide area = select and play program
        if (self.epgNavigationMode && self.selectedEpgProgramIndex >= 0) {
            // Use the shared selection handler (same as tvOS)
            [self handleTVOSEpgProgramSelection];
            NSLog(@"🎬 [iOS-EPG] Double tap - Selected EPG program");
            return;
        }
    }
    
    // If not handled as channel selection, toggle fullscreen
    [[NSNotificationCenter defaultCenter] postNotificationName:@"ToggleFullscreen" object:nil];
}
#endif

- (void)handlePanGesture:(UIPanGestureRecognizer *)gesture {
    // ANTI-FLICKER: Strict checks to prevent pan from interfering with tap
    
    // 1. Only process if menu is visible and stable
    if (!_isChannelListVisible) {
        return;
    }
    
    CGPoint translation = [gesture translationInView:self];
    CGPoint location = [gesture locationInView:self];
    CGPoint velocity = [gesture velocityInView:self];
    
    // 2. Require significant movement before considering it a pan
    CGFloat movementThreshold = 15.0; // Increased threshold - more restrictive
    CGFloat totalMovement = sqrt(translation.x * translation.x + translation.y * translation.y);
    
    // 3. Don't process until we have clear intent to scroll
    if (gesture.state == UIGestureRecognizerStateBegan) {
        return; // Never process "began" state
    }
    
    if (totalMovement < movementThreshold && gesture.state != UIGestureRecognizerStateEnded) {
        return; // Movement too small - definitely a tap, not scroll
    }
    
    // 4. Additional check - ensure we're in a scrollable area
    if (location.x < [self categoryWidth]) {
        return; // Don't scroll in category area
    }
    
    // iPhone-style scrolling with proper state tracking
    static BOOL _isActivelyScrolling = NO;
    static NSDate *_lastPanTime = nil;
    
    if (gesture.state == UIGestureRecognizerStateChanged && totalMovement >= movementThreshold) {
        _isActivelyScrolling = YES;
        _lastPanTime = [NSDate date];
        // Stop any ongoing momentum animations for true 1:1 finger tracking
        [self stopAllMomentumAnimations];
    } else if (gesture.state == UIGestureRecognizerStateEnded || gesture.state == UIGestureRecognizerStateCancelled) {
        _isActivelyScrolling = NO;
    }
    
    // Direct finger tracking - 1:1 movement like iPhone
    CGFloat deltaY = translation.y;
    
    // Calculate responsive dimensions for gesture handling
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    
    // Determine which area is being scrolled
    if (location.x >= categoryWidth && location.x < categoryWidth + groupWidth) {
        // Scrolling in groups area - iPhone-style with bounce
        NSArray *groups = [self getGroupsForSelectedCategory];
        CGFloat contentHeight = groups.count * [self rowHeight];
        CGFloat visibleHeight = self.bounds.size.height;
        CGFloat maxScroll = MAX(0, contentHeight - visibleHeight);
        
        // Calculate new position
        CGFloat newPosition = _groupScrollPosition - deltaY;
        
        // iPhone-style bounce at edges
        if (newPosition < 0) {
            // Bounce at top - slow down as we go beyond bounds
            CGFloat overscroll = -newPosition;
            _groupScrollPosition = -(overscroll * 0.3); // Rubber band effect
        } else if (newPosition > maxScroll) {
            // Bounce at bottom - slow down as we go beyond bounds
            CGFloat overscroll = newPosition - maxScroll;
            _groupScrollPosition = maxScroll + (overscroll * 0.3); // Rubber band effect
        } else {
            // Normal scrolling within bounds
            _groupScrollPosition = newPosition;
        }
        
        [gesture setTranslation:CGPointZero inView:self];
        [self setNeedsDisplay];
        
        // Add momentum scrolling on gesture end with bounce-back
        if (gesture.state == UIGestureRecognizerStateEnded) {
            [self addMomentumScrollingForGroups:velocity.y maxScroll:maxScroll];
        }
        
    } else if (location.x > categoryWidth + groupWidth) {
        // Calculate program guide area
        CGFloat programGuideWidth = [self programGuideWidth];
        CGFloat channelListWidth = self.bounds.size.width - categoryWidth - groupWidth - programGuideWidth;
        CGFloat programGuideX = categoryWidth + groupWidth + channelListWidth;
        
        if (location.x >= programGuideX && (_hoveredChannelIndex >= 0 || _selectedChannelIndex >= 0)) {
            // Scrolling in program guide area - iPhone-style with bounce
            VLCChannel *channel = [self getChannelAtIndex:_hoveredChannelIndex >= 0 ? _hoveredChannelIndex : _selectedChannelIndex];
            if (channel && channel.programs && channel.programs.count > 0) {
                CGFloat programHeight = 60;
                CGFloat programSpacing = 5;
                CGFloat contentHeight = channel.programs.count * (programHeight + programSpacing);
                // Use same calculation as in program guide drawing for consistency
                CGFloat contentStartY = self.bounds.size.height - 90; // Leave space for channel name
                CGFloat visibleHeight = contentStartY - 20; // Bottom margin - matches drawing logic
                CGFloat maxScroll = MAX(0, contentHeight - visibleHeight);
                
                // Calculate new position (now that programs flow top-to-bottom, use normal scrolling)
                CGFloat newPosition = _programGuideScrollPosition - deltaY;
                
                // DEBUG: Log pan gesture scroll calculations
                NSLog(@"📺 [PAN-SCROLL] Programs: %ld, ContentHeight: %.1f, VisibleHeight: %.1f, MaxScroll: %.1f, NewPosition: %.1f", 
                      (long)channel.programs.count, contentHeight, visibleHeight, maxScroll, newPosition);
                
                // iPhone-style bounce at edges
                if (newPosition < 0) {
                    CGFloat overscroll = -newPosition;
                    _programGuideScrollPosition = -(overscroll * 0.3); // Rubber band effect
                } else if (newPosition > maxScroll) {
                    CGFloat overscroll = newPosition - maxScroll;
                    _programGuideScrollPosition = maxScroll + (overscroll * 0.3); // Rubber band effect
                } else {
                    _programGuideScrollPosition = newPosition;
                }
                
                [gesture setTranslation:CGPointZero inView:self];
                [self setNeedsDisplay];
                
                // Add momentum scrolling on gesture end (invert velocity to match new direction)
                if (gesture.state == UIGestureRecognizerStateEnded) {
                    [self addMomentumScrollingForProgramGuide:-velocity.y maxScroll:maxScroll];
                }
            }
        } else {
            // Scrolling in channel list area - iPhone-style with bounce
            NSArray *channels = [self getChannelsForCurrentGroup];
            CGFloat contentHeight = channels.count * [self rowHeight];
            CGFloat visibleHeight = self.bounds.size.height;
            CGFloat maxScroll = MAX(0, contentHeight - visibleHeight);
            
            // Calculate new position
            CGFloat newPosition = _channelScrollPosition - deltaY;
            
            // iPhone-style bounce at edges
            if (newPosition < 0) {
                // Bounce at top - slow down as we go beyond bounds
                CGFloat overscroll = -newPosition;
                _channelScrollPosition = -(overscroll * 0.3); // Rubber band effect
            } else if (newPosition > maxScroll) {
                // Bounce at bottom - slow down as we go beyond bounds
                CGFloat overscroll = newPosition - maxScroll;
                _channelScrollPosition = maxScroll + (overscroll * 0.3); // Rubber band effect
            } else {
                // Normal scrolling within bounds
                _channelScrollPosition = newPosition;
            }
            
            [gesture setTranslation:CGPointZero inView:self];
            [self setNeedsDisplay];
            
            // Add momentum scrolling on gesture end with bounce-back
            if (gesture.state == UIGestureRecognizerStateEnded) {
                [self addMomentumScrollingForChannels:velocity.y maxScroll:maxScroll];
            }
        }
    }
}

- (void)addMomentumScrollingForGroups:(CGFloat)velocity maxScroll:(CGFloat)maxScroll {
    // True iPhone-style momentum with CADisplayLink for smooth animation
    if (fabs(velocity) < 50) {
        // Too slow for momentum - just snap back if needed
        [self snapGroupScrollToValidPosition:maxScroll];
        return;
    }
    
    // Stop any existing momentum
    [self stopGroupMomentumAnimation];
    
    // Store momentum parameters as instance variables
    _groupMomentumVelocity = velocity;
    _groupMomentumMaxScroll = maxScroll;
    
    // Create display link for smooth 60fps momentum animation
    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateGroupMomentumScroll:)];
    _groupMomentumDisplayLink = displayLink; // weak reference
    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)updateGroupMomentumScroll:(CADisplayLink *)displayLink {
    // iPhone deceleration rate
    CGFloat deceleration = 2000.0; // pixels per second^2
    CGFloat frameTime = displayLink.targetTimestamp - displayLink.timestamp;
    
    // Update velocity with deceleration
    if (_groupMomentumVelocity > 0) {
        _groupMomentumVelocity = MAX(0, _groupMomentumVelocity - deceleration * frameTime);
    } else {
        _groupMomentumVelocity = MIN(0, _groupMomentumVelocity + deceleration * frameTime);
    }
    
    // Update position
    _groupScrollPosition -= _groupMomentumVelocity * frameTime;
    
    // Handle bouncing at edges
    if (_groupScrollPosition < 0) {
        _groupScrollPosition = _groupScrollPosition * 0.5; // Rubber band
        _groupMomentumVelocity *= 0.8; // Reduce velocity when bouncing
    } else if (_groupScrollPosition > _groupMomentumMaxScroll) {
        CGFloat overshoot = _groupScrollPosition - _groupMomentumMaxScroll;
        _groupScrollPosition = _groupMomentumMaxScroll + overshoot * 0.5; // Rubber band
        _groupMomentumVelocity *= 0.8; // Reduce velocity when bouncing
    }
    
    // Stop if velocity is too low
    if (fabs(_groupMomentumVelocity) < 10) {
        [self stopGroupMomentumAnimation];
        [self snapGroupScrollToValidPosition:_groupMomentumMaxScroll];
        return;
    }
    
    [self setNeedsDisplay];
}

- (void)snapGroupScrollToValidPosition:(CGFloat)maxScroll {
    if (_groupScrollPosition < 0 || _groupScrollPosition > maxScroll) {
        CGFloat targetPosition = MAX(0, MIN(_groupScrollPosition, maxScroll));
        [UIView animateWithDuration:0.3
                              delay:0
             usingSpringWithDamping:0.8
              initialSpringVelocity:0
                            options:UIViewAnimationOptionCurveEaseOut
                         animations:^{
                             self->_groupScrollPosition = targetPosition;
                             [self setNeedsDisplay];
                         } completion:nil];
    }
}

- (void)addMomentumScrollingForChannels:(CGFloat)velocity maxScroll:(CGFloat)maxScroll {
    // True iPhone-style momentum with CADisplayLink for smooth animation
    if (fabs(velocity) < 50) {
        // Too slow for momentum - just snap back if needed
        [self snapChannelScrollToValidPosition:maxScroll];
        return;
    }
    
    // Stop any existing momentum
    [self stopChannelMomentumAnimation];
    
    // Store momentum parameters as instance variables
    _channelMomentumVelocity = velocity;
    _channelMomentumMaxScroll = maxScroll;
    
    // Create display link for smooth 60fps momentum animation
    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateChannelMomentumScroll:)];
    _channelMomentumDisplayLink = displayLink; // weak reference
    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)updateChannelMomentumScroll:(CADisplayLink *)displayLink {
    // iPhone deceleration rate
    CGFloat deceleration = 2000.0; // pixels per second^2
    CGFloat frameTime = displayLink.targetTimestamp - displayLink.timestamp;
    
    // Update velocity with deceleration
    if (_channelMomentumVelocity > 0) {
        _channelMomentumVelocity = MAX(0, _channelMomentumVelocity - deceleration * frameTime);
    } else {
        _channelMomentumVelocity = MIN(0, _channelMomentumVelocity + deceleration * frameTime);
    }
    
    // Update position
    _channelScrollPosition -= _channelMomentumVelocity * frameTime;
    
    // Handle bouncing at edges
    if (_channelScrollPosition < 0) {
        _channelScrollPosition = _channelScrollPosition * 0.5; // Rubber band
        _channelMomentumVelocity *= 0.8; // Reduce velocity when bouncing
    } else if (_channelScrollPosition > _channelMomentumMaxScroll) {
        CGFloat overshoot = _channelScrollPosition - _channelMomentumMaxScroll;
        _channelScrollPosition = _channelMomentumMaxScroll + overshoot * 0.5; // Rubber band
        _channelMomentumVelocity *= 0.8; // Reduce velocity when bouncing
    }
    
    // Stop if velocity is too low
    if (fabs(_channelMomentumVelocity) < 10) {
        [self stopChannelMomentumAnimation];
        [self snapChannelScrollToValidPosition:_channelMomentumMaxScroll];
        return;
    }
    
    [self setNeedsDisplay];
}

- (void)snapChannelScrollToValidPosition:(CGFloat)maxScroll {
    if (_channelScrollPosition < 0 || _channelScrollPosition > maxScroll) {
        CGFloat targetPosition = MAX(0, MIN(_channelScrollPosition, maxScroll));
        [UIView animateWithDuration:0.3
                              delay:0
             usingSpringWithDamping:0.8
              initialSpringVelocity:0
                            options:UIViewAnimationOptionCurveEaseOut
                         animations:^{
                             self->_channelScrollPosition = targetPosition;
                             [self setNeedsDisplay];
                         } completion:nil];
    }
}

- (void)stopGroupMomentumAnimation {
    CADisplayLink *displayLink = _groupMomentumDisplayLink;
    if (displayLink) {
        [displayLink invalidate];
        _groupMomentumDisplayLink = nil;
        _groupMomentumVelocity = 0;
    }
}

- (void)stopChannelMomentumAnimation {
    CADisplayLink *displayLink = _channelMomentumDisplayLink;
    if (displayLink) {
        [displayLink invalidate];
        _channelMomentumDisplayLink = nil;
        _channelMomentumVelocity = 0;
    }
}

- (void)addMomentumScrollingForProgramGuide:(CGFloat)velocity maxScroll:(CGFloat)maxScroll {
    // Program guide momentum scrolling
    if (fabs(velocity) < 50) {
        [self snapProgramGuideScrollToValidPosition:maxScroll];
        return;
    }
    
    [self stopProgramGuideMomentumAnimation];
    
    _programGuideMomentumVelocity = velocity;
    _programGuideMomentumMaxScroll = maxScroll;
    
    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateProgramGuideMomentumScroll:)];
    _programGuideMomentumDisplayLink = displayLink;
    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)updateProgramGuideMomentumScroll:(CADisplayLink *)displayLink {
    // Smoother deceleration for better feel
    CGFloat deceleration = 1200.0;  // Reduced from 2000 for smoother scrolling
    CGFloat frameTime = displayLink.targetTimestamp - displayLink.timestamp;
    
    if (_programGuideMomentumVelocity > 0) {
        _programGuideMomentumVelocity = MAX(0, _programGuideMomentumVelocity - deceleration * frameTime);
    } else {
        _programGuideMomentumVelocity = MIN(0, _programGuideMomentumVelocity + deceleration * frameTime);
    }
    
    _programGuideScrollPosition += _programGuideMomentumVelocity * frameTime;
    
    // Smoother rubber band effect with less aggressive dampening
    if (_programGuideScrollPosition < 0) {
        _programGuideScrollPosition = _programGuideScrollPosition * 0.7;  // Less aggressive bounce back
        _programGuideMomentumVelocity *= 0.9;  // Less velocity reduction
    } else if (_programGuideScrollPosition > _programGuideMomentumMaxScroll) {
        CGFloat overshoot = _programGuideScrollPosition - _programGuideMomentumMaxScroll;
        _programGuideScrollPosition = _programGuideMomentumMaxScroll + overshoot * 0.7;  // Less aggressive bounce back
        _programGuideMomentumVelocity *= 0.9;  // Less velocity reduction
    }
    
    // Lower threshold for stopping animation to reduce jerkiness
    if (fabs(_programGuideMomentumVelocity) < 5) {  // Reduced from 10 for smoother stop
        [self stopProgramGuideMomentumAnimation];
        [self snapProgramGuideScrollToValidPosition:_programGuideMomentumMaxScroll];
        return;
    }
    
    [self setNeedsDisplay];
}

- (void)snapProgramGuideScrollToValidPosition:(CGFloat)maxScroll {
    if (_programGuideScrollPosition < 0 || _programGuideScrollPosition > maxScroll) {
        CGFloat targetPosition = MAX(0, MIN(_programGuideScrollPosition, maxScroll));
        
        // Smoother spring animation with reduced duration and improved damping
        [UIView animateWithDuration:0.4  // Slightly longer for smoother feel
                              delay:0
             usingSpringWithDamping:0.9   // Higher damping for less oscillation
              initialSpringVelocity:0.3   // Small initial velocity for natural movement
                            options:UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionAllowUserInteraction
                         animations:^{
                             self->_programGuideScrollPosition = targetPosition;
                             [self setNeedsDisplay];
                         } completion:nil];
    }
}

- (void)stopProgramGuideMomentumAnimation {
    CADisplayLink *displayLink = _programGuideMomentumDisplayLink;
    if (displayLink) {
        [displayLink invalidate];
        _programGuideMomentumDisplayLink = nil;
        _programGuideMomentumVelocity = 0;
    }
}

- (void)stopAllMomentumAnimations {
    [self stopGroupMomentumAnimation];
    [self stopChannelMomentumAnimation];
    [self stopProgramGuideMomentumAnimation];
}

#pragma mark - Shared Timeshift Methods (iOS Implementation)

- (BOOL)isCurrentlyPlayingTimeshift {
    // iOS implementation of timeshift detection
    if (!self.player || !self.player.media) {
        return NO;
    }
    
    NSString *currentUrl = [self.player.media.url absoluteString];
    if (!currentUrl) {
        return NO;
    }
    
    // Check if URL contains timeshift parameters
    return ([currentUrl rangeOfString:@"timeshift.php"].location != NSNotFound ||
            [currentUrl rangeOfString:@"timeshift"].location != NSNotFound);
}

- (VLCProgram *)getCurrentTimeshiftPlayingProgram {
    // iOS implementation of timeshift program detection
    NSLog(@"📺 iOS getCurrentTimeshiftPlayingProgram - basic implementation");
    
    // Check if we're actually playing timeshift content
    if (![self isCurrentlyPlayingTimeshift]) {
        return nil;
    }
    
    // Basic implementation: return nil for now, can be enhanced later
    // The macOS version has complex logic, but for iOS we'll start simple
    NSLog(@"📺 getCurrentTimeshiftPlayingProgram - returning nil (basic iOS implementation)");
    return nil;
}

- (void)clearLoadingState {
    // Clear all loading states to prevent concurrent operations
    _isDownloadingChannels = NO;
    _isDownloadingEPG = NO;
    self.isLoading = NO;
    self.isLoadingEpg = NO;
    NSLog(@"🔧 All loading states cleared");
}

- (void)clearChannelLoadingState {
    // Clear only M3U/channel loading states (keeps EPG separate)
    _isDownloadingChannels = NO;
    self.isLoading = NO;
    NSLog(@"🔧 Channel loading states cleared");
}

- (void)clearEpgLoadingState {
    // Clear only EPG loading states (keeps M3U separate)
    _isDownloadingEPG = NO;
    self.isLoadingEpg = NO;
    NSLog(@"🔧 EPG loading states cleared");
}

- (void)safelyReplaceChannelData:(NSMutableArray *)newChannels 
                          groups:(NSMutableArray *)newGroups 
                 channelsByGroup:(NSMutableDictionary *)newChannelsByGroup 
                groupsByCategory:(NSMutableDictionary *)newGroupsByCategory {
    
    NSLog(@"🔧 safelyReplaceChannelData called with:");
    NSLog(@"🔧   - %lu channels", (unsigned long)[newChannels count]);
    NSLog(@"🔧   - %lu groups", (unsigned long)[newGroups count]);
    NSLog(@"🔧   - %lu groups by category", (unsigned long)[newChannelsByGroup count]);
    NSLog(@"🔧   - %lu categories", (unsigned long)[newGroupsByCategory count]);
    
    // Replace data atomically to prevent enumeration crashes
    @synchronized(self) {
        // Release old data
        [_channels release];
        [_groups release];
        [_channelsByGroup release];
        [_groupsByCategory release];
        
        // Set new data
        _channels = [newChannels retain];
        _groups = [newGroups retain];
        _channelsByGroup = [newChannelsByGroup retain];
        _groupsByCategory = [newGroupsByCategory retain];
        
        NSLog(@"🔧 Data replacement completed - new counts:");
        NSLog(@"🔧   - _channels: %lu", (unsigned long)[_channels count]);
        NSLog(@"🔧   - _groups: %lu", (unsigned long)[_groups count]);
        NSLog(@"🔧   - _channelsByGroup: %lu", (unsigned long)[_channelsByGroup count]);
        NSLog(@"🔧   - _groupsByCategory: %lu", (unsigned long)[_groupsByCategory count]);
        
        // Populate _categories from the loaded data
        NSMutableArray *loadedCategories = [[NSMutableArray alloc] init];
        // Add standard categories first
        [loadedCategories addObject:@"SEARCH"];
        [loadedCategories addObject:@"FAVORITES"];
        
        // Add categories that have actual data
        for (NSString *category in [_groupsByCategory allKeys]) {
            if (![loadedCategories containsObject:category]) {
                [loadedCategories addObject:category];
            }
        }
        
        // Always ensure Settings is last
        if (![loadedCategories containsObject:@"SETTINGS"]) {
            [loadedCategories addObject:@"SETTINGS"];
        }
        
        // Replace categories array
        [_categories release];
        _categories = [loadedCategories retain];
        [loadedCategories release];
        
        NSLog(@"🔧 Updated _categories with %lu categories: %@", (unsigned long)[_categories count], _categories);
        
        // Auto-trigger EPG loading now that channels are loaded
        if ([_channels count] > 0 && !self.isEpgLoaded && !self.isLoadingEpg) {
            NSLog(@"📅 ✅ Channels loaded successfully - triggering EPG loading automatically");
            dispatch_async(dispatch_get_main_queue(), ^{
                [self loadEpgDataAtStartup];
            });
        }
    }
}

#pragma mark - Channel Playback (Shared Interface)

- (void)playChannelAtIndex:(NSInteger)index {
    NSArray *channels = [self getChannelsForCurrentGroup];
    NSLog(@"📺 playChannelAtIndex:%ld with %lu channels available", (long)index, (unsigned long)channels.count);
    
    if (index < 0 || index >= channels.count) {
        NSLog(@"❌ Invalid channel index: %ld (available: %lu)", (long)index, (unsigned long)channels.count);
        return;
    }
    
    id channel = channels[index];
    NSString *channelUrl = nil;
    NSString *channelName = @"Unknown Channel";
    
    if ([channel isKindOfClass:[VLCChannel class]]) {
        VLCChannel *vlcChannel = (VLCChannel *)channel;
        channelUrl = vlcChannel.url;
        channelName = vlcChannel.name;
        NSLog(@"📺 Playing VLCChannel: %@ (URL: %@)", channelName, channelUrl);
    } else if ([channel isKindOfClass:[NSString class]]) {
        // If it's a simple string, check if we have URLs array
        channelName = (NSString *)channel;
        if (index < _simpleChannelUrls.count) {
            channelUrl = _simpleChannelUrls[index];
            NSLog(@"📺 Playing simple channel: %@ (URL: %@)", channelName, channelUrl);
        } else {
            NSLog(@"❌ No URL available for simple channel: %@", channelName);
        }
    } else {
        NSLog(@"❌ Unknown channel type: %@", NSStringFromClass([channel class]));
    }
    
    if (channelUrl && [channelUrl length] > 0 && self.player) {
        NSURL *url = [NSURL URLWithString:channelUrl];
        if (url) {
            VLCMedia *media = [VLCMedia mediaWithURL:url];
            [self.player setMedia:media];
            [self.player play];
            
            NSLog(@"✅ Started playback for: %@ (%@)", channelName, channelUrl);
        } else {
            NSLog(@"❌ Invalid URL format: %@", channelUrl);
        }
    } else {
        if (!channelUrl) {
            NSLog(@"❌ No URL available for channel: %@", channelName);
        } else if (!self.player) {
            NSLog(@"❌ No VLC player available");
        }
    }
}

#pragma mark - Data Structure Management (Shared with macOS)

- (void)ensureDataStructuresInitialized {
    //NSLog(@"🔧 Safe data structure initialization for iOS");
    
    // Initialize all data structures if not already done
    if (!_channels) {
        _channels = [[NSMutableArray alloc] init];
       // NSLog(@"🔧 Initialized _channels array");
    }
    
    if (!_groups) {
        _groups = [[NSMutableArray alloc] init];
        //NSLog(@"🔧 Initialized _groups array");
    }
    
    if (!_channelsByGroup) {
        _channelsByGroup = [[NSMutableDictionary alloc] init];
        //NSLog(@"🔧 Initialized _channelsByGroup dictionary");
    }
    
    if (!_groupsByCategory) {
        _groupsByCategory = [[NSMutableDictionary alloc] init];
        //NSLog(@"🔧 Initialized _groupsByCategory dictionary");
        
        // Add the real macOS settings groups
        NSMutableArray *settingsGroups = [NSMutableArray arrayWithObjects:
            @"General", @"Playlist", @"Subtitles", @"Movie Info", @"Themes", nil];
        [_groupsByCategory setObject:settingsGroups forKey:@"SETTINGS"];
        
        // Set other categories with empty arrays
        for (NSString *category in @[@"SEARCH", @"FAVORITES", @"TV", @"MOVIES", @"SERIES"]) {
            [_groupsByCategory setObject:[NSMutableArray array] forKey:category];
        }
    }
    
    if (!_categories) {
        _categories = [@[@"SEARCH", @"FAVORITES", @"TV", @"MOVIES", @"SERIES", @"SETTINGS"] retain];
        //NSLog(@"🔧 Initialized _categories array");
    }
    
    // Initialize EPG data dictionary - CRITICAL FIX for cache loading
    if (!self.epgData) {
        self.epgData = [NSMutableDictionary dictionary];
        NSLog(@"🔧 ✅ Initialized self.epgData dictionary - required for EPG cache loading");
    }
    
    //NSLog(@"🔧 All data structures initialized successfully");
}

#pragma mark - Layout

- (void)layoutSubviews {
    // Prevent infinite layout loops that cause memory crashes
    if (_isInLayoutUpdate) {
        return;
    }
    _isInLayoutUpdate = YES;
    
    [super layoutSubviews];
    
    CGFloat screenWidth = self.bounds.size.width;
    CGFloat screenHeight = self.bounds.size.height;
    
    NSLog(@"📱 layoutSubviews called - updating landscape-optimized layout for bounds: %@ (width: %.0f)", 
          NSStringFromCGRect(self.bounds), screenWidth);
    
    // Invalidate font caches when layout changes to prevent memory leaks
    [self invalidateFontCaches];
    
    // Update scroll view frame if it exists using responsive dimensions
    if (_settingsScrollViewiOS) {
        CGFloat catWidth = [self categoryWidth];
        CGFloat groupWidth = [self groupWidth];
        CGFloat settingsPanelX = catWidth + groupWidth;
        CGFloat settingsPanelWidth = self.bounds.size.width - settingsPanelX;
        
        CGRect newFrame = CGRectMake(settingsPanelX, 0, settingsPanelWidth, self.bounds.size.height);
        if (!CGRectEqualToRect(_settingsScrollViewiOS.frame, newFrame)) {
            _settingsScrollViewiOS.frame = newFrame;
            NSLog(@"📱 Updated settings scroll view frame: %@", NSStringFromCGRect(newFrame));
        }
    }
    
    // Update loading panel position if it exists
    if (_loadingPaneliOS) {
        CGFloat panelWidth = 300;
        CGFloat panelHeight = 120;
        CGFloat padding = 20;
        CGFloat panelX = self.bounds.size.width - panelWidth - padding;
        CGFloat panelY = self.bounds.size.height - panelHeight - padding;
        
        CGRect newLoadingFrame = CGRectMake(panelX, panelY, panelWidth, panelHeight);
        if (!CGRectEqualToRect(_loadingPaneliOS.frame, newLoadingFrame)) {
            _loadingPaneliOS.frame = newLoadingFrame;
            NSLog(@"📱 Updated loading panel frame: %@", NSStringFromCGRect(newLoadingFrame));
        }
    }
    
    // Trigger a redraw since our responsive calculations depend on bounds
    [self setNeedsDisplay];
    
    _isInLayoutUpdate = NO;
}

#pragma mark - iOS-Specific Method Implementations

// iOS implementations - load settings from NSUserDefaults
- (void)loadSettings {
    NSLog(@"📋 iOS loadSettings - loading from NSUserDefaults");
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Load M3U file path
    NSString *savedM3uPath = [defaults stringForKey:@"m3uFilePath"];
    if (savedM3uPath && [savedM3uPath length] > 0) {
        self.m3uFilePath = savedM3uPath;
        NSLog(@"📂 Loaded M3U path: %@", self.m3uFilePath);
    } else {
        NSLog(@"📂 No saved M3U path found");
    }
    
    // Load EPG URL
    NSString *savedEpgUrl = [defaults stringForKey:@"epgUrl"];
    if (savedEpgUrl && [savedEpgUrl length] > 0) {
        self.epgUrl = savedEpgUrl;
        NSLog(@"📅 Loaded EPG URL: %@", self.epgUrl);
    } else {
        NSLog(@"📅 No saved EPG URL found");
    }
    
    // Load EPG time offset
    if ([defaults objectForKey:@"epgTimeOffsetHours"]) {
        self.epgTimeOffsetHours = [defaults floatForKey:@"epgTimeOffsetHours"];
        NSLog(@"⏰ Loaded EPG time offset: %.1f hours", self.epgTimeOffsetHours);
    }
    
    NSLog(@"📋 Settings loading completed");
}

- (void)loadThemeSettings {
    NSLog(@"🎨 iOS loadThemeSettings - loading theme from NSUserDefaults");
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Load custom selection colors
    if ([defaults objectForKey:@"customSelectionRed"]) {
        self.customSelectionRed = [defaults floatForKey:@"customSelectionRed"];
        self.customSelectionGreen = [defaults floatForKey:@"customSelectionGreen"];
        self.customSelectionBlue = [defaults floatForKey:@"customSelectionBlue"];
        
        // Update hover color based on custom selection
        _hoverColor = [UIColor colorWithRed:self.customSelectionRed 
                                      green:self.customSelectionGreen 
                                       blue:self.customSelectionBlue 
                                      alpha:0.6];
        
        NSLog(@"🎨 Loaded custom selection color: R=%.2f G=%.2f B=%.2f", 
              self.customSelectionRed, self.customSelectionGreen, self.customSelectionBlue);
    }
    
    NSLog(@"🎨 Theme settings loading completed");
}

- (void)loadViewModePreference {
    NSLog(@"👁 iOS loadViewModePreference - loading view mode from NSUserDefaults");
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Load view mode preference
    if ([defaults objectForKey:@"currentViewMode"]) {
        _currentViewMode = [defaults integerForKey:@"currentViewMode"];
        _isGridViewActive = (_currentViewMode == VIEW_MODE_GRID);
        _isStackedViewActive = (_currentViewMode == VIEW_MODE_STACKED);
        
        NSLog(@"👁 Loaded view mode: %ld", (long)_currentViewMode);
    }
    
    NSLog(@"👁 View mode preference loading completed");
}

- (BOOL)loadChannelsFromCache:(NSString *)sourcePath {
    NSLog(@"📺 iOS loadChannelsFromCache for: %@", sourcePath);
    [self logMemoryUsage:@"start of loadChannelsFromCache"];
    
    NSString *cachePath = [self channelCacheFilePath:sourcePath];
    
    // Check if the cache file exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cachePath]) {
        NSLog(@"Cache file does not exist: %@", cachePath);
        return NO;
    }
    
    // CRITICAL: Check cache file size before attempting to load
    NSError *fileError = nil;
    NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:cachePath error:&fileError];
    if (fileAttributes) {
        NSNumber *fileSize = [fileAttributes objectForKey:NSFileSize];
        NSUInteger fileSizeMB = [fileSize unsignedIntegerValue] / (1024 * 1024);
        
        NSLog(@"📁 Cache file size: %luMB", (unsigned long)fileSizeMB);
        
        // Load full cache regardless of size
        NSLog(@"📺 Cache file size: %luMB - loading FULL channel list", (unsigned long)fileSizeMB);
    }
    
    // Load from the cache file
    NSDictionary *cacheDict = [NSDictionary dictionaryWithContentsOfFile:cachePath];
    if (!cacheDict) {
        NSLog(@"Failed to load channels cache from %@", cachePath);
        return NO;
    }
    
    // Check cache version
    NSString *cacheVersion = [cacheDict objectForKey:@"cacheVersion"];
    if (!cacheVersion || (![cacheVersion isEqualToString:@"1.0"] && ![cacheVersion isEqualToString:@"1.1"])) {
        NSLog(@"Unsupported cache version: %@", cacheVersion);
        return NO;
    }
    
    // Check timestamp (1 week max)
    NSDate *cacheDate = [cacheDict objectForKey:@"cacheDate"];
    if (cacheDate) {
        NSTimeInterval cacheAge = [[NSDate date] timeIntervalSinceDate:cacheDate];
        NSTimeInterval oneWeek = 7 * 24 * 60 * 60; // 7 days in seconds
        
        if (cacheAge > oneWeek) {
            NSLog(@"Cache is too old (%.1f days), will refresh", cacheAge / (24 * 60 * 60));
            return NO;
        }
    }
    
    // Load cached data
    NSArray *serializedChannels = [cacheDict objectForKey:@"channels"];
    NSArray *groups = [cacheDict objectForKey:@"groups"];
    NSDictionary *serializedChannelsByGroup = [cacheDict objectForKey:@"channelsByGroup"];
    NSDictionary *groupsByCategory = [cacheDict objectForKey:@"groupsByCategory"];
    
    if (!serializedChannels || !groups) {
        NSLog(@"Invalid cache data structure");
        return NO;
    }
    
    // Initialize data structures
    [self ensureDataStructuresInitialized];
    
    // Update progress
    dispatch_async(dispatch_get_main_queue(), ^{
        [self setLoadingStatusText:@"Loading channels from cache..."];
        self.loadingProgress = 0.0;
    });
    
    // Deserialize channels - NO LIMITS, load full channel list with memory optimization
    NSUInteger totalChannels = [serializedChannels count];
    NSMutableArray *channels = [[NSMutableArray alloc] initWithCapacity:totalChannels];
    
    NSLog(@"📺 Loading FULL channel list from cache: %lu channels", (unsigned long)totalChannels);
    
    for (NSUInteger i = 0; i < totalChannels; i++) {
        @autoreleasepool { // Wrap each channel creation in autorelease pool
        if (i % 500 == 0) { // Check more frequently for memory issues
            float progress = (float)i / (float)totalChannels;
            dispatch_async(dispatch_get_main_queue(), ^{
                self.loadingProgress = progress;
                [self setLoadingStatusText:[NSString stringWithFormat:@"Loading channel %lu of %lu from cache...", 
                                          (unsigned long)(i + 1), (unsigned long)totalChannels]];
            });
            
            // Memory monitoring (informational only - no limits)
            if (i > 1000 && i % 1000 == 0) {
                NSUInteger currentMemoryMB = [self getCurrentMemoryUsageMB];
                NSLog(@"📊 Memory usage: %luMB at channel %lu of %lu", 
                      (unsigned long)currentMemoryMB, (unsigned long)i, (unsigned long)totalChannels);
            }
        }
        
        NSDictionary *channelDict = [serializedChannels objectAtIndex:i];
        if (![channelDict isKindOfClass:[NSDictionary class]]) continue;
        
        VLCChannel *channel = [[VLCChannel alloc] init];
        channel.name = [channelDict objectForKey:@"name"];
        channel.url = [channelDict objectForKey:@"url"];
        channel.group = [channelDict objectForKey:@"group"];
        channel.logo = [channelDict objectForKey:@"logo"];
        channel.channelId = [channelDict objectForKey:@"channelId"];
        channel.category = [channelDict objectForKey:@"category"];
        channel.programs = [[NSMutableArray alloc] init];
        
        // Load catch-up properties
        channel.supportsCatchup = [[channelDict objectForKey:@"supportsCatchup"] boolValue];
        channel.catchupDays = [[channelDict objectForKey:@"catchupDays"] integerValue];
        channel.catchupSource = [channelDict objectForKey:@"catchupSource"];
        channel.catchupTemplate = [channelDict objectForKey:@"catchupTemplate"];
        
        [channels addObject:channel];
        } // End autorelease pool
    }
    
    // Set the loaded data using underlying instance variables (properties are readonly)
    _channels = channels;
    _groups = [groups mutableCopy];
    _groupsByCategory = [groupsByCategory mutableCopy];
    
    // Rebuild channelsByGroup from indices
    NSMutableDictionary *channelsByGroup = [[NSMutableDictionary alloc] init];
    for (NSString *group in [serializedChannelsByGroup allKeys]) {
        NSArray *indices = [serializedChannelsByGroup objectForKey:group];
        NSMutableArray *groupChannels = [[NSMutableArray alloc] init];
        
        for (NSNumber *indexNum in indices) {
            NSUInteger index = [indexNum unsignedIntegerValue];
            if (index < [channels count]) {
                [groupChannels addObject:[channels objectAtIndex:index]];
            }
        }
        
        [channelsByGroup setObject:groupChannels forKey:group];
    }
    _channelsByGroup = channelsByGroup;
    
    // Update UI
    dispatch_async(dispatch_get_main_queue(), ^{
        self.loadingProgress = 1.0;
        [self setLoadingStatusText:[NSString stringWithFormat:@"Loaded %lu channels from cache", 
                                  (unsigned long)totalChannels]];
        
        // Auto-start EPG loading if we have EPG URL
        if (self.epgUrl && [self.epgUrl length] > 0) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), 
                          dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [self loadEpgData];
            });
        }
        
        // Clear loading state after a brief delay
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            self.isLoading = NO;
            [self setNeedsDisplay];
        });
    });
    
    NSLog(@"Successfully loaded %lu channels from cache", (unsigned long)totalChannels);
    
    // Count and log timeshift channels loaded from cache
    NSInteger timeshiftChannelCount = 0;
    for (VLCChannel *channel in channels) {
        if (channel.supportsCatchup || channel.catchupDays > 0) {
            timeshiftChannelCount++;
        }
    }
    NSLog(@"🔧 [TIMESHIFT-CACHE] Found %ld channels with timeshift support from cache", (long)timeshiftChannelCount);
    [self logMemoryUsage:@"end of loadChannelsFromCache"];
    return YES;
}

// Cache cleanup utilities for memory management
- (void)clearOversizedCache {
    NSLog(@"🧹 Clearing oversized cache files...");
    
    NSString *cachePath = [self channelCacheFilePath:self.m3uFilePath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if ([fileManager fileExistsAtPath:cachePath]) {
        NSError *error = nil;
        if ([fileManager removeItemAtPath:cachePath error:&error]) {
            NSLog(@"✅ Oversized cache cleared successfully");
        } else {
            NSLog(@"❌ Failed to clear cache: %@", error.localizedDescription);
        }
    }
}

- (BOOL)isCacheOversized:(NSString *)sourcePath {
    // Always return NO - no cache is considered oversized anymore
    return NO;
}

- (NSString *)channelCacheFilePath:(NSString *)sourcePath {
    // Create a unique cache path based on the source path
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *cacheFileName;
    
    // For URLs (especially with query parameters), create a sanitized filename
    if ([sourcePath hasPrefix:@"http://"] || [sourcePath hasPrefix:@"https://"]) {
        // Create a hash of the URL to use as the filename
        NSString *hash = [self md5HashForString:sourcePath];
        cacheFileName = [NSString stringWithFormat:@"channels_%@.plist", hash];
    } else {
        // For local files, use a sanitized version of the filename
        NSString *lastComponent = [sourcePath lastPathComponent];
        if ([lastComponent length] == 0) {
            cacheFileName = @"default_channels_cache.plist";
        } else {
            // Replace any invalid filename characters
            NSCharacterSet *invalidChars = [NSCharacterSet characterSetWithCharactersInString:@":/\\?%*|\"<>"];
            NSString *sanitized = [[lastComponent componentsSeparatedByCharactersInSet:invalidChars] componentsJoinedByString:@"_"];
            cacheFileName = [NSString stringWithFormat:@"%@_cache.plist", sanitized];
        }
    }
    
    NSString *cachePath = [appSupportDir stringByAppendingPathComponent:cacheFileName];
    return cachePath;
}

- (BOOL)saveChannelsToCache:(NSString *)sourcePath {
    NSString *cachePath = [self channelCacheFilePath:sourcePath];
    
    @try {
        // Create a dictionary to store the cache
        NSMutableDictionary *cacheDict = [NSMutableDictionary dictionary];
        
        // Store metadata
        [cacheDict setObject:@"1.1" forKey:@"cacheVersion"];
        [cacheDict setObject:[NSDate date] forKey:@"cacheDate"];
        [cacheDict setObject:sourcePath forKey:@"sourcePath"];
        
        // Get arrays to serialize
        NSArray *channels = self.channels;
        NSArray *groups = self.groups;
        NSDictionary *channelsByGroup = self.channelsByGroup;
        NSDictionary *groupsByCategory = self.groupsByCategory;
        
        // Store total counts for progress reporting
        NSUInteger totalChannels = [channels count];
        
        // Single progress update - start serializing
        dispatch_async(dispatch_get_main_queue(), ^{
            [self setLoadingStatusText:@"Saving channels to cache..."];
            self.epgLoadingProgress = 0.0;
        });
        
        // Prepare all the data structures in a single pass
        NSMutableArray *serializedChannels = [NSMutableArray array];
        NSMutableDictionary *serializedChannelsByGroup = [NSMutableDictionary dictionary];
        
        // First, pre-initialize the serializedChannelsByGroup with empty arrays for each group
        for (NSString *group in [channelsByGroup allKeys]) {
            [serializedChannelsByGroup setObject:[NSMutableArray array] forKey:group];
        }
        
        // Now process all channels in a single pass
        for (NSUInteger i = 0; i < totalChannels; i++) {
            VLCChannel *channel = [channels objectAtIndex:i];
            
            // Serialize channel for main array
            NSMutableDictionary *serializedChannel = [NSMutableDictionary dictionary];
            [serializedChannel setObject:(channel.name ? channel.name : @"") forKey:@"name"];
            [serializedChannel setObject:(channel.url ? channel.url : @"") forKey:@"url"];
            [serializedChannel setObject:(channel.group ? channel.group : @"") forKey:@"group"];
            if (channel.logo) [serializedChannel setObject:channel.logo forKey:@"logo"];
            if (channel.channelId) [serializedChannel setObject:channel.channelId forKey:@"channelId"];
            if (channel.category) [serializedChannel setObject:channel.category forKey:@"category"];
            
            // Save catch-up properties
            [serializedChannel setObject:@(channel.supportsCatchup) forKey:@"supportsCatchup"];
            if (channel.catchupDays > 0) [serializedChannel setObject:@(channel.catchupDays) forKey:@"catchupDays"];
            if (channel.catchupSource) [serializedChannel setObject:channel.catchupSource forKey:@"catchupSource"];
            if (channel.catchupTemplate) [serializedChannel setObject:channel.catchupTemplate forKey:@"catchupTemplate"];
            
            // Add to serialized channels array
            [serializedChannels addObject:serializedChannel];
            
            // Add channel index to its group's array in serializedChannelsByGroup
            NSString *groupName = channel.group;
            if (groupName) {
                NSMutableArray *groupIndices = [serializedChannelsByGroup objectForKey:groupName];
                if (groupIndices) {
                    [groupIndices addObject:@(i)];
                }
            }
            
            // Update progress periodically
            if (i % 1000 == 0 || i == totalChannels - 1) {
                float progress = (float)i / (float)totalChannels;
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.epgLoadingProgress = progress;
                    [self setLoadingStatusText:[NSString stringWithFormat:@"Caching channel %lu of %lu...", 
                                              (unsigned long)(i + 1), (unsigned long)totalChannels]];
                });
            }
        }
        
        // Store all the serialized data
        [cacheDict setObject:serializedChannels forKey:@"channels"];
        [cacheDict setObject:groups forKey:@"groups"];
        [cacheDict setObject:serializedChannelsByGroup forKey:@"channelsByGroup"];
        [cacheDict setObject:groupsByCategory forKey:@"groupsByCategory"];
        
        // Update progress - final step
        dispatch_async(dispatch_get_main_queue(), ^{
            [self setLoadingStatusText:@"Writing cache file..."];
            self.epgLoadingProgress = 0.9;
        });
        
        // Write to file
        BOOL success = [cacheDict writeToFile:cachePath atomically:YES];
        
        // Final progress update
        dispatch_async(dispatch_get_main_queue(), ^{
            if (success) {
                [self setLoadingStatusText:[NSString stringWithFormat:@"Saved %lu channels to cache", 
                                          (unsigned long)totalChannels]];
                NSLog(@"Successfully saved channels cache to %@", cachePath);
            } else {
                [self setLoadingStatusText:@"Failed to write cache file"];
                NSLog(@"Failed to write channels cache to %@", cachePath);
            }
            self.epgLoadingProgress = 1.0;
        });
        
        return success;
    } @catch (NSException *exception) {
        NSLog(@"Exception while saving channels cache: %@", exception);
        
        // Update progress on error
        dispatch_async(dispatch_get_main_queue(), ^{
            [self setLoadingStatusText:[NSString stringWithFormat:@"Error saving cache: %@", [exception reason]]];
            self.epgLoadingProgress = 0.0;
        });
        
        return NO;
    }
}

- (NSString *)md5HashForString:(NSString *)string {
    const char *cStr = [string UTF8String];
    unsigned char result[16];
    CC_MD5(cStr, (CC_LONG)strlen(cStr), result);
    
    NSMutableString *hash = [NSMutableString string];
    for (int i = 0; i < 16; i++) {
        [hash appendFormat:@"%02x", result[i]];
    }
    
    return hash;
}

- (NSString *)applicationSupportDirectory {
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
    NSString *appSupportDir = [paths firstObject];
    
    // Create app-specific subdirectory
    NSString *appName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleName"];
    if (!appName) appName = @"BasicIPTV";
    
    NSString *appSpecificDir = [appSupportDir stringByAppendingPathComponent:appName];
    
    // Ensure the directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:appSpecificDir]) {
        NSError *error = nil;
        [fileManager createDirectoryAtPath:appSpecificDir 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:&error];
        if (error) {
            NSLog(@"Error creating Application Support directory: %@", error);
        }
    }
    
    return appSpecificDir;
}



- (NSString *)settingsFilePath {
    NSString *appSupportDir = [self applicationSupportDirectory];
    return [appSupportDir stringByAppendingPathComponent:@"settings.plist"];
}

- (BOOL)shouldUpdateM3UAtStartup {
    NSLog(@"🔄 Universal shouldUpdateM3UAtStartup - using macOS implementation");
    // The macOS VLCOverlayView+Caching.m handles update logic
    return YES; // Will be implemented by macOS category method
}

- (BOOL)shouldUpdateEPGAtStartup {
    NSLog(@"🔄 iOS shouldUpdateEPGAtStartup - checking 6-hour rule");
    
    // Check if we have a valid EPG URL first
    if (!self.epgUrl || [self.epgUrl length] == 0) {
        NSLog(@"🔄 No EPG URL - no update needed");
        return NO;
    }
    
    // Load EPG download timestamp from NSUserDefaults (iOS style)
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    NSDate *lastDownload = [defaults objectForKey:@"lastEPGDownloadDate"];
    
    if (!lastDownload) {
        // No previous download, should update
        NSLog(@"🔄 No previous EPG download date found - will update");
        return YES;
    }
    
    NSTimeInterval timeSinceDownload = [[NSDate date] timeIntervalSinceDate:lastDownload];
    NSTimeInterval sixHoursInSeconds = 6 * 60 * 60; // 6 hours
    
    BOOL shouldUpdate = timeSinceDownload > sixHoursInSeconds;
    NSLog(@"🔄 Last EPG download was %.1f hours ago - %@", 
          timeSinceDownload / 3600.0, 
          shouldUpdate ? @"will update" : @"using cache");
    
    return shouldUpdate;
}

- (void)loadEpgFromCacheOnly {
    NSLog(@"📅 loadEpgFromCacheOnly - attempting to load EPG from cache");
    
    // This method attempts to load EPG data from cache without downloading
    // If cache load fails, it does nothing (no download)
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Try to load EPG data from cache (iOS implementation now has direct methods)
        BOOL success = [self loadEpgDataFromCacheWithoutChecks];
        if (success) {
            NSLog(@"📅 ✅ Successfully loaded EPG from cache");
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isEpgLoaded = YES;
                self.isLoadingEpg = NO;
                [self setNeedsDisplay];
            });
        } else {
            NSLog(@"📅 ❌ Failed to load EPG from cache");
        }
    });
}

- (void)loadEpgDataAtStartup {
    NSLog(@"📅 loadEpgDataAtStartup called on iOS - implementing 6-hour caching rule");
    
    // Check if we have a valid EPG URL
    if (!self.epgUrl || [self.epgUrl isEqualToString:@""]) {
        NSLog(@"📅 No EPG URL specified for startup EPG loading");
        return;
    }
    
    // If channels aren't loaded yet, schedule EPG loading for later
    if (!self.channels || [self.channels count] == 0) {
        NSLog(@"📅 Channels not loaded yet - scheduling EPG loading for after channel loading");
        // Schedule EPG loading for after channels are loaded
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@"📅 Retrying EPG loading after channel loading delay...");
            [self loadEpgDataAtStartup];
        });
        return;
    }
    
    NSLog(@"📅 ✅ Starting EPG load sequence with 6-hour rule check (%lu channels)", (unsigned long)[self.channels count]);
    
    // Check if we need to update the EPG data (6-hour rule)
    BOOL shouldDownloadEPG = [self shouldUpdateEPGAtStartup];
    
    if (shouldDownloadEPG) {
        NSLog(@"📅 EPG data is older than 6 hours or doesn't exist - downloading fresh data");
        // Set EPG loading state and download fresh data
        self.isLoadingEpg = YES;
        [self loadEpgData];
    } else {
        NSLog(@"📅 Using cached EPG data (updated within the last 6 hours)");
        // Try to load existing EPG data from cache
        [self loadEpgFromCacheOnly];
    }
}

- (void)startEarlyPlaybackIfAvailable {
    NSLog(@"▶️ Universal startEarlyPlaybackIfAvailable - using macOS implementation");
    // The macOS VLCOverlayView+PlayerControls.m handles early playback
}

- (void)loadChannelsFile {
    NSLog(@"📺 Universal loadChannelsFile - using macOS implementation");
    // The macOS VLCOverlayView+ChannelManagement.m handles file loading
}

- (NSString *)localM3uFilePath {
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths firstObject];
    return [documentsDirectory stringByAppendingPathComponent:@"channels.m3u"];
}

#pragma mark - Method Stubs (iOS-specific implementations)

- (void)loadChannelsFromM3uFile:(NSString *)path {
    NSLog(@"🔧 loadChannelsFromM3uFile called on iOS - using iOS implementation");
    NSLog(@"🔧 Input path: %@", path);
    NSLog(@"🔧 Current downloading state: %s", _isDownloadingChannels ? "YES" : "NO");
    NSLog(@"🔧 Current loading state: %s", self.isLoading ? "YES" : "NO");
    
    // Prevent multiple simultaneous loads
    if (_isDownloadingChannels || self.isLoading) {
        NSLog(@"⚠️ Channel loading already in progress - ignoring duplicate request");
        return;
    }
    
    if (!path || [path length] == 0) {
        NSLog(@"❌ No M3U file path specified");
        dispatch_async(dispatch_get_main_queue(), ^{
            [self clearLoadingState];
            [self setLoadingStatusText:@"Error: No file path specified"];
        });
        return;
    }
    
    // Cancel any existing downloads first
    [self cancelAllDownloads];
    
    // Check if path is URL or local file
    BOOL isUrl = [path hasPrefix:@"http://"] || [path hasPrefix:@"https://"];
    NSLog(@"🔧 Is URL: %s", isUrl ? "YES" : "NO");
    
    if (isUrl) {
        NSLog(@"🔧 Detected URL - calling loadChannelsFromUrl (which will set its own loading state)");
        NSLog(@"🔧 States just before calling loadChannelsFromUrl: downloading=%d, isLoading=%d", _isDownloadingChannels, self.isLoading);
        // For URLs, call our iOS URL loading method (don't set loading state here - let loadChannelsFromUrl do it)
        [self loadChannelsFromUrl:path];
        NSLog(@"🔧 States just after calling loadChannelsFromUrl: downloading=%d, isLoading=%d", _isDownloadingChannels, self.isLoading);
    } else {
        NSLog(@"🔧 Detected local file - processing locally");
        // For local files, set loading state here since we handle it directly
        _isDownloadingChannels = YES;
        self.isLoading = YES;
        // For local files, implement basic file loading
        self.loadingProgress = 0.1f;
        [self setLoadingStatusText:@"Reading local M3U file..."];
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            // Simulate local file processing
            for (int i = 1; i <= 5; i++) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    float progress = 0.1f + (i / 5.0f) * 0.9f;
                    self.loadingProgress = progress;
                    [self setLoadingStatusText:[NSString stringWithFormat:@"Processing local file: %d%%", (int)(progress * 100)]];
                    
                    if (progress >= 1.0f) {
                        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                            [self clearLoadingState];
                            [self setLoadingStatusText:@"Local file loaded successfully"];
                            NSLog(@"✅ Local file loading completed: %@", path);
                        });
                    }
                });
                usleep(200000); // 200ms between updates
            }
        });
    }
}

- (void)saveCurrentPlaybackPosition {
    NSLog(@"🔧 saveCurrentPlaybackPosition called on iOS (stub implementation)");
    // TODO: Implement playback position saving for iOS
    // For now, this is a stub to satisfy the compiler
}

- (NSString *)getLastPlayedChannelUrl {
    NSLog(@"🔧 getLastPlayedChannelUrl called on iOS (stub implementation)");
    // TODO: Implement last played channel retrieval for iOS
    // For now, return nil to satisfy the compiler
    return nil;
}

- (void)saveSettings {
    NSLog(@"💾 iOS saveSettings - saving to NSUserDefaults");
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    // Save M3U file path
    if (self.m3uFilePath) {
        [defaults setObject:self.m3uFilePath forKey:@"m3uFilePath"];
        NSLog(@"💾 Saved M3U path: %@", self.m3uFilePath);
    }
    
    // Save EPG URL
    if (self.epgUrl) {
        [defaults setObject:self.epgUrl forKey:@"epgUrl"];
        NSLog(@"💾 Saved EPG URL: %@", self.epgUrl);
    }
    
    // Save EPG time offset
    [defaults setFloat:self.epgTimeOffsetHours forKey:@"epgTimeOffsetHours"];
    
    // Save custom selection colors
    [defaults setFloat:self.customSelectionRed forKey:@"customSelectionRed"];
    [defaults setFloat:self.customSelectionGreen forKey:@"customSelectionGreen"];
    [defaults setFloat:self.customSelectionBlue forKey:@"customSelectionBlue"];
    
    // Save view mode preference
    [defaults setInteger:_currentViewMode forKey:@"currentViewMode"];
    
    // Force synchronization
    [defaults synchronize];
    
    NSLog(@"💾 Settings saved successfully");
}

// Compatibility method for macOS setNeedsDisplay: - UIKit doesn't use the boolean parameter
- (void)setNeedsDisplay:(BOOL)flag {
    // On iOS/tvOS, just call setNeedsDisplay (UIKit ignores the boolean parameter)
    [self setNeedsDisplay];
}

#pragma mark - EPG Cache Methods (iOS/tvOS Implementation)

#if TARGET_OS_IOS || TARGET_OS_TV

- (NSString *)epgCacheFilePath {
    NSLog(@"📅 [CACHE] Getting EPG cache file path for iOS/tvOS");
    
    // Get the app's Documents directory
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths firstObject];
    
    // Create a subfolder for cache files if it doesn't exist
    NSString *cacheDirectory = [documentsDirectory stringByAppendingPathComponent:@"EPGCache"];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cacheDirectory]) {
        NSError *error = nil;
        [fileManager createDirectoryAtPath:cacheDirectory withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            NSLog(@"📅 [CACHE] ⚠️ Error creating cache directory: %@", error.localizedDescription);
        }
    }

    NSString *cacheFileName;
    
    // If we have an EPG URL, use it to create a unique filename
    if (self.epgUrl && [self.epgUrl length] > 0) {
        // Create a hash of the URL to use as the filename
        NSString *hash = [self md5HashForString:self.epgUrl];
        cacheFileName = [NSString stringWithFormat:@"epg_%@.plist", hash];
    } else {
        // Default filename if no URL is available
        cacheFileName = @"epg_default_cache.plist";
    }
    
    NSString *epgCachePath = [cacheDirectory stringByAppendingPathComponent:cacheFileName];
    NSLog(@"📅 [CACHE] Cache file path: %@", epgCachePath);
    return epgCachePath;
}
#else

- (NSString *)epgCacheFilePath {
    NSString *appSupportDir = [self applicationSupportDirectory];
    NSString *cacheFileName;
    
    // If we have an EPG URL, use it to create a unique filename
    if (self.epgUrl && [self.epgUrl length] > 0) {
        // Create a hash of the URL to use as the filename
        NSString *hash = [self md5HashForString:self.epgUrl];
        cacheFileName = [NSString stringWithFormat:@"epg_%@.plist", hash];
    } else {
        // Default filename if no URL is available
        cacheFileName = @"epg_default_cache.plist";
    }
    
    NSString *epgCachePath = [appSupportDir stringByAppendingPathComponent:cacheFileName];
    return epgCachePath;
}
#endif
- (BOOL)loadEpgDataFromCache {
    NSLog(@"📅 [CACHE] loadEpgDataFromCache called for iOS/tvOS");
    
    // Always run in background thread to avoid hanging the UI
    __block BOOL success = NO;
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Show loading indicator
        dispatch_async(dispatch_get_main_queue(), ^{
            self.isLoading = YES;
            self.isLoadingEpg = YES;
            [self startProgressRedrawTimer];
            
            // Display a message about loading from cache
            NSString *cachePath = [self epgCacheFilePath];
            NSFileManager *fileManager = [NSFileManager defaultManager];
            NSDictionary *attributes = [fileManager attributesOfItemAtPath:cachePath error:nil];
            if (attributes) {
                NSDate *modDate = [attributes fileModificationDate];
                NSTimeInterval timeSince = [[NSDate date] timeIntervalSinceDate:modDate];
                int hoursAgo = (int)(timeSince / 3600);
                [self setLoadingStatusText:[NSString stringWithFormat:@"Loading EPG from cache (last updated %d hours ago)...", hoursAgo]];
            } else {
                [self setLoadingStatusText:@"Loading EPG from cache..."];
            }
            [self setNeedsDisplay];
        });
        
        success = [self loadEpgDataFromCacheWithoutChecks];
        
        // Update UI on main thread after completion
        dispatch_async(dispatch_get_main_queue(), ^{
            if (success) {
                [self setLoadingStatusText:@"EPG loaded from cache successfully"];
                NSLog(@"📅 [CACHE] ✅ EPG successfully loaded from cache");
            } else {
                [self setLoadingStatusText:@"No valid EPG cache found, will download from URL"];
                NSLog(@"📅 [CACHE] ❌ EPG cache loading failed");
            }
            [self setNeedsDisplay];
        });
    });
    
    // Always return YES because we're handling the loading asynchronously
    return YES;
}

- (BOOL)loadEpgDataFromCacheWithoutChecks {
    NSLog(@"📅 [CACHE] loadEpgDataFromCacheWithoutChecks for iOS/tvOS");
    
    // First verify that we have channel data - don't load EPG without channels
    if (!self.channels || [self.channels count] == 0) {
        NSLog(@"📅 [CACHE] Cannot load EPG data from cache - no channels loaded yet");
        return NO;
    }
    
    NSString *cachePath = [self epgCacheFilePath];
    
    // Check if cache file exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cachePath]) {
        NSLog(@"📅 [CACHE] EPG cache file does not exist: %@", cachePath);
        return NO;
    }
    
    // Load cache data
    NSDictionary *cacheDict = [NSDictionary dictionaryWithContentsOfFile:cachePath];
    if (!cacheDict) {
        NSLog(@"📅 [CACHE] Failed to load EPG cache from %@", cachePath);
        return NO;
    }
    
    // Check cache version
    NSString *cacheVersion = [cacheDict objectForKey:@"epgCacheVersion"];
    if (!cacheVersion || ![cacheVersion isEqualToString:@"1.0"]) {
        NSLog(@"📅 [CACHE] Unsupported EPG cache version: %@", cacheVersion);
        return NO;
    }
    
    // Check cache date (not older than 24 hours)
    NSDate *cacheDate = [cacheDict objectForKey:@"epgCacheDate"];
    if (!cacheDate) {
        NSLog(@"📅 [CACHE] Invalid EPG cache date");
        return NO;
    }
    
    NSTimeInterval timeSinceCache = [[NSDate date] timeIntervalSinceDate:cacheDate];
    if (timeSinceCache > 24 * 60 * 60) { // 24 hours
        NSLog(@"📅 [CACHE] EPG cache is too old (%f hours), reloading", timeSinceCache / 3600.0);
        return NO;
    }
    
    // Process EPG data
    NSDictionary *epgData = [cacheDict objectForKey:@"epgData"];
    if (!epgData) {
        NSLog(@"📅 [CACHE] No EPG data in cache");
        return NO;
    }
    
    // Clear existing EPG data
    @synchronized(self.epgData) {
        [self.epgData removeAllObjects];
        
        // Process each channel
        for (NSString *channelId in epgData) {
            NSArray *programDicts = [epgData objectForKey:channelId];
            NSMutableArray *programs = [NSMutableArray array];
            
            for (NSDictionary *programDict in programDicts) {
                VLCProgram *program = [[VLCProgram alloc] init];
                program.title = [programDict objectForKey:@"title"];
                program.programDescription = [programDict objectForKey:@"description"];
                program.startTime = [programDict objectForKey:@"startTime"];
                program.endTime = [programDict objectForKey:@"endTime"];
                program.channelId = [programDict objectForKey:@"channelId"];
                
                // Check for catch-up attributes
                NSString *hasArchive = [programDict objectForKey:@"catchup"];
                if (hasArchive && [hasArchive isEqualToString:@"1"]) {
                    program.hasArchive = YES;
                }
                
                NSString *archiveDays = [programDict objectForKey:@"catchup-days"];
                if (archiveDays) {
                    program.archiveDays = [archiveDays integerValue];
                }
                
                [programs addObject:program];
                [program release];
            }
            
                        [self.epgData setObject:programs forKey:channelId];
        }
    }
    
    NSLog(@"📅 [CACHE] ✅ Populated self.epgData with %lu channels after cache load", (unsigned long)[self.epgData count]);
    
    // Match EPG data with channels
    [self matchEpgWithChannels];
    
    // Update UI
    dispatch_async(dispatch_get_main_queue(), ^{
        self.isEpgLoaded = YES;
        self.isLoadingEpg = NO;
        [self setNeedsDisplay];
    });
    
    NSLog(@"📅 [CACHE] ✅ Successfully loaded EPG data from cache with %lu channels", (unsigned long)[epgData count]);
    return YES;
}

- (BOOL)loadEpgDataFromCacheWithoutAgeCheck {
    NSLog(@"📅 [CACHE] loadEpgDataFromCacheWithoutAgeCheck for iOS/tvOS");
    
    NSString *cachePath = [self epgCacheFilePath];
    
    // Check if cache file exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:cachePath]) {
        NSLog(@"📅 [CACHE] EPG cache file does not exist: %@", cachePath);
        return NO;
    }
    
    // Load cache data
    NSDictionary *cacheDict = [NSDictionary dictionaryWithContentsOfFile:cachePath];
    if (!cacheDict) {
        NSLog(@"📅 [CACHE] Failed to load EPG cache from %@", cachePath);
        return NO;
    }
    
    // Check cache version
    NSString *cacheVersion = [cacheDict objectForKey:@"epgCacheVersion"];
    if (!cacheVersion || ![cacheVersion isEqualToString:@"1.0"]) {
        NSLog(@"📅 [CACHE] Unsupported EPG cache version: %@", cacheVersion);
        return NO;
    }
    
    // Process EPG data (without age check)
    NSDictionary *epgData = [cacheDict objectForKey:@"epgData"];
    if (!epgData) {
        NSLog(@"📅 [CACHE] No EPG data in cache");
        return NO;
    }
    
    // Clear existing EPG data
    @synchronized(self.epgData) {
        [self.epgData removeAllObjects];
        
        // Process each channel
        for (NSString *channelId in epgData) {
            NSArray *programDicts = [epgData objectForKey:channelId];
            NSMutableArray *programs = [NSMutableArray array];
            
            for (NSDictionary *programDict in programDicts) {
                VLCProgram *program = [[VLCProgram alloc] init];
                program.title = [programDict objectForKey:@"title"];
                program.programDescription = [programDict objectForKey:@"description"];
                program.startTime = [programDict objectForKey:@"startTime"];
                program.endTime = [programDict objectForKey:@"endTime"];
                program.channelId = [programDict objectForKey:@"channelId"];
                
                // Check for catch-up attributes
                NSString *hasArchive = [programDict objectForKey:@"catchup"];
                if (hasArchive && [hasArchive isEqualToString:@"1"]) {
                    program.hasArchive = YES;
                }
                
                NSString *archiveDays = [programDict objectForKey:@"catchup-days"];
                if (archiveDays) {
                    program.archiveDays = [archiveDays integerValue];
                }
                
                [programs addObject:program];
                [program release];
            }
            
                        [self.epgData setObject:programs forKey:channelId];
        }
    }
    
    NSLog(@"📅 [CACHE] ✅ Populated self.epgData with %lu channels after cache load (no age check)", (unsigned long)[self.epgData count]);
    
    // Match EPG data with channels
    [self matchEpgWithChannels];
    
    // Update UI
    dispatch_async(dispatch_get_main_queue(), ^{
        self.isEpgLoaded = YES;
        self.isLoadingEpg = NO;
        [self setNeedsDisplay];
    });
    
    NSLog(@"📅 [CACHE] ✅ Successfully loaded EPG data from cache without age check with %lu channels", (unsigned long)[epgData count]);
    return YES;
}

- (void)saveEpgDataToCache_implementation {
    NSLog(@"📅 [CACHE] saveEpgDataToCache_implementation for iOS/tvOS");
    // Debug logging removed - issue resolved
    
    if (!self.epgData || [self.epgData count] == 0) {
        NSLog(@"📅 [CACHE] No EPG data to save to cache");
        return;
    }
    
    // Create a thread-safe copy of the EPG data
    __block NSDictionary *epgDataCopy = nil;
    
    // Always copy on the main thread to ensure thread safety
    if ([NSThread isMainThread]) {
        @try {
            @synchronized(self.epgData) {
                if (self.epgData && [self.epgData isKindOfClass:[NSDictionary class]]) {
                    epgDataCopy = [[NSDictionary alloc] initWithDictionary:self.epgData copyItems:YES];
    } else {
                    NSLog(@"📅 [CACHE] ERROR: self.epgData is not a valid NSDictionary: %@", [self.epgData class]);
                    return;
                }
            }
        } @catch (NSException *exception) {
            NSLog(@"📅 [CACHE] ERROR: Exception while copying EPG data: %@", exception);
            return;
        }
    } else {
        dispatch_sync(dispatch_get_main_queue(), ^{
            @try {
                @synchronized(self.epgData) {
                    if (self.epgData && [self.epgData isKindOfClass:[NSDictionary class]]) {
                        epgDataCopy = [[NSDictionary alloc] initWithDictionary:self.epgData copyItems:YES];
                    } else {
                        NSLog(@"📅 [CACHE] ERROR: self.epgData is not a valid NSDictionary: %@", [self.epgData class]);
                    }
                }
            } @catch (NSException *exception) {
                NSLog(@"📅 [CACHE] ERROR: Exception while copying EPG data: %@", exception);
            }
        });
    }
    
    if (!epgDataCopy || ![epgDataCopy isKindOfClass:[NSDictionary class]]) {
        NSLog(@"📅 [CACHE] ERROR: Failed to create valid EPG data copy");
        return;
    }
    
    // Update UI to show we're saving
    dispatch_async(dispatch_get_main_queue(), ^{
        self.isLoading = YES;
        [self setLoadingStatusText:@"Saving EPG data to cache..."];
        [self startProgressRedrawTimer];
        [self setNeedsDisplay];
    });
    
    // Run the actual save operation in background
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Create dictionary to save
        NSMutableDictionary *cacheDict = [NSMutableDictionary dictionary];
        
        // Add metadata
        [cacheDict setObject:@"1.0" forKey:@"epgCacheVersion"];
        [cacheDict setObject:[NSDate date] forKey:@"epgCacheDate"];
        
        // Process EPG data (convert VLCProgram objects to dictionaries)
        NSMutableDictionary *epgDataDict = [NSMutableDictionary dictionary];
        NSInteger totalPrograms = 0;
        
        for (NSString *channelId in [epgDataCopy allKeys]) {
            id channelPrograms = [epgDataCopy objectForKey:channelId];
            if (![channelPrograms isKindOfClass:[NSArray class]]) {
                continue;
            }
            
            NSArray *programs = (NSArray *)channelPrograms;
            NSMutableArray *programDicts = [NSMutableArray array];
            
            for (VLCProgram *program in programs) {
                if (![program isKindOfClass:[VLCProgram class]]) {
                    continue;
                }
                
                NSMutableDictionary *programDict = [NSMutableDictionary dictionary];
                
                if (program.title) [programDict setObject:program.title forKey:@"title"];
                if (program.programDescription) [programDict setObject:program.programDescription forKey:@"description"];
                if (program.startTime) [programDict setObject:program.startTime forKey:@"startTime"];
                if (program.endTime) [programDict setObject:program.endTime forKey:@"endTime"];
                if (program.channelId) [programDict setObject:program.channelId forKey:@"channelId"];
                
                // Add catch-up information
                if (program.hasArchive) {
                    [programDict setObject:@"1" forKey:@"catchup"];
                }
                
                if (program.archiveDays > 0) {
                    [programDict setObject:[NSString stringWithFormat:@"%ld", (long)program.archiveDays] forKey:@"catchup-days"];
                }
                
                [programDicts addObject:programDict];
                totalPrograms++;
            }
            
            [epgDataDict setObject:programDicts forKey:channelId];
        }
        
        [cacheDict setObject:epgDataDict forKey:@"epgData"];
        
        // Write to file
        NSString *cachePath = [self epgCacheFilePath];
        NSString *cacheDir = [cachePath stringByDeletingLastPathComponent];
        [[NSFileManager defaultManager] createDirectoryAtPath:cacheDir 
                                  withIntermediateDirectories:YES 
                                                   attributes:nil 
                                                        error:nil];
        
        BOOL success = [cacheDict writeToFile:cachePath atomically:YES];
        
        if (success) {
            NSLog(@"📅 [CACHE] ✅ Successfully saved EPG cache with %ld programs to %@", (long)totalPrograms, cachePath);
        } else {
            NSLog(@"📅 [CACHE] ❌ Failed to save EPG cache to %@", cachePath);
        }
        
        // Update UI on completion
        dispatch_async(dispatch_get_main_queue(), ^{
            if (success) {
                [self setLoadingStatusText:[NSString stringWithFormat:@"EPG cache saved: %ld programs", (long)totalPrograms]];
            } else {
                [self setLoadingStatusText:@"Error saving EPG cache to disk"];
            }
            
            [self setNeedsDisplay];
            
            // Clear display after a delay
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                self.isLoading = NO;
                [self stopProgressRedrawTimer];
                [self setNeedsDisplay];
            });
        });
        
        // Clean up the copy
        [epgDataCopy release];
    });
}

// Progress timer methods for EPG module compatibility
- (void)startProgressRedrawTimer {
    if (gProgressRedrawTimer) {
        [gProgressRedrawTimer invalidate];
        gProgressRedrawTimer = nil;
    }
    
    gProgressRedrawTimer = [NSTimer scheduledTimerWithTimeInterval:0.1
                                                           target:self
                                                         selector:@selector(progressRedrawTimerFired:)
                                                         userInfo:nil
                                                          repeats:YES];
}

- (void)stopProgressRedrawTimer {
    if (gProgressRedrawTimer) {
        [gProgressRedrawTimer invalidate];
        gProgressRedrawTimer = nil;
    }
}

- (void)progressRedrawTimerFired:(NSTimer *)timer {
    if (self.isLoading || self.isLoadingEpg) {
    [self setNeedsDisplay];
    } else {
        [self stopProgressRedrawTimer];
    }
}

- (void)clearCacheButtonTapped:(UIButton *)button {
    NSLog(@"🔧 Clear Cache button tapped");
    
    // Call the macOS-compatible cache clearing methods
    if ([self respondsToSelector:@selector(clearCachedTimeshiftChannel)]) {
        [self clearCachedTimeshiftChannel];
    }
    if ([self respondsToSelector:@selector(clearCachedTimeshiftProgramInfo)]) {
        [self clearCachedTimeshiftProgramInfo];
    }
    
    [self showBriefMessage:@"Cache cleared" at:button.center];
}

- (void)reloadChannelsButtonTapped:(UIButton *)button {
    NSLog(@"🔧 Reload Channels button tapped");
    NSLog(@"🔧 Current M3U file path: %@", self.m3uFilePath);
    NSLog(@"🔧 M3U file path length: %lu", (unsigned long)[self.m3uFilePath length]);
    
    if (self.m3uFilePath && [self.m3uFilePath length] > 0) {
        NSLog(@"✅ M3U URL is valid, starting channel loading...");
        [self showBriefMessage:@"Reloading channels..." at:button.center];
        [self showLoadingPanel];
        [self loadChannelsFromM3uFile:self.m3uFilePath];
    } else {
        NSLog(@"❌ No M3U URL set - showing error message");
        [self showBriefMessage:@"Set M3U URL first" at:button.center];
    }
}

#pragma mark - Property Setters (iOS Progress Integration)

- (void)setLoadingProgress:(float)loadingProgress {
    _loadingProgress = loadingProgress;
    
    // Automatically update iOS UI when progress changes
    if (_m3uProgressBariOS && _m3uProgressLabeliOS) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSString *status = self.loadingStatusText ?: @"Loading...";
            [self updateLoadingProgress:loadingProgress status:status];
        });
    }
}

- (void)setEpgLoadingProgress:(float)epgLoadingProgress {
    _epgLoadingProgress = epgLoadingProgress;
    
    // Automatically update iOS UI when progress changes
    if (_epgProgressBariOS && _epgProgressLabeliOS) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSString *status = self.epgLoadingStatusText ?: @"Loading EPG...";
            [self updateEPGLoadingProgress:epgLoadingProgress status:status];
        });
    }
}

- (void)setIsLoading:(BOOL)isLoading {
    _isLoading = isLoading;
    
    // Show/hide loading panel based on loading state
    if (isLoading && !_loadingPaneliOS) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLoadingPanel];
        });
    }
}

- (void)setIsLoadingEpg:(BOOL)isLoadingEpg {
    _isLoadingEpg = isLoadingEpg;
    
    // Show/hide loading panel based on EPG loading state
    if (isLoadingEpg && !_loadingPaneliOS) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLoadingPanel];
        });
    }
}

- (void)setLoadingStatusText:(NSString *)loadingStatusText {
    if (_loadingStatusText != loadingStatusText) {
        [_loadingStatusText release];
        _loadingStatusText = [loadingStatusText retain];
        
        // Update iOS UI with new status text
        if (_m3uProgressBariOS && _m3uProgressLabeliOS) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self updateLoadingProgress:self.loadingProgress status:loadingStatusText];
            });
        }
    }
}

- (void)setEpgLoadingStatusText:(NSString *)epgLoadingStatusText {
    if (_epgLoadingStatusText != epgLoadingStatusText) {
        [_epgLoadingStatusText release];
        _epgLoadingStatusText = [epgLoadingStatusText retain];
        
        // Update iOS UI with new EPG status text
        if (_epgProgressBariOS && _epgProgressLabeliOS) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self updateEPGLoadingProgress:self.epgLoadingProgress status:epgLoadingStatusText];
            });
        }
    }
}

#pragma mark - Channel Loading (Shared with macOS)

- (void)loadChannelsFromUrl:(NSString *)urlStr {
    NSLog(@"🔧 iOS loadChannelsFromUrl called: %@", urlStr);
    
    // Prevent multiple simultaneous loads
    if (_isDownloadingChannels || self.isLoading) {
        NSLog(@"⚠️ Channel loading already in progress - ignoring duplicate request");
        return;
    }
    
    if (!urlStr || [urlStr length] == 0) {
        NSLog(@"❌ Invalid URL string passed to loadChannelsFromUrl");
        dispatch_async(dispatch_get_main_queue(), ^{
            [self clearLoadingState];
            [self setLoadingStatusText:@"Error: Invalid URL"];
        });
        return;
    }
    
    // Set loading states
    _isDownloadingChannels = YES;
    self.isLoading = YES;
    self.loadingProgress = 0.0f;
    [self setLoadingStatusText:[NSString stringWithFormat:@"Connecting to server..."]];
    
    // Set up temporary file
    NSString *tempFileName = [NSString stringWithFormat:@"temp_channels_%@.m3u", [[NSUUID UUID] UUIDString]];
    NSString *tempFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:tempFileName];
    
    // Remove any existing file
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if ([fileManager fileExistsAtPath:tempFilePath]) {
        [fileManager removeItemAtPath:tempFilePath error:nil];
    }
    
    // Create URL object for host display
    NSURL *url = [NSURL URLWithString:urlStr];
    if (url && [url host]) {
        [self setLoadingStatusText:[NSString stringWithFormat:@"Connecting to %@...", [url host]]];
    }
    
    // Set up download manager
    DownloadManager *manager = [[DownloadManager alloc] init];
    NSLog(@"Starting M3U download from URL: %@", urlStr);
    
    [manager startDownloadFromURL:urlStr
                  progressHandler:^(int64_t received, int64_t total) {
                      // Calculate progress percentage
                      float progress = (total > 0) ? ((float)received / (float)total) : 0.0f;
                      
                      // Format size in appropriate units
                      NSString *sizeInfo;
                      if (received < 1024 * 1024) { // Less than 1MB
                          sizeInfo = [NSString stringWithFormat:@"%.1f KB / %.1f MB", 
                                     (float)received / 1024.0, 
                                     (float)total / 1048576.0];
                      } else {
                          sizeInfo = [NSString stringWithFormat:@"%.2f / %.2f MB", 
                                     (float)received / 1048576.0, 
                                     (float)total / 1048576.0];
                      }
                      
                      // Update UI on main thread with real progress
                      dispatch_async(dispatch_get_main_queue(), ^{
                          self.loadingProgress = progress;
                          
                          // Create detailed status text with percentage and size information
                          NSString *statusText = [NSString stringWithFormat:@"Downloading: %.1f%% %@", 
                                                 progress * 100.0, sizeInfo];
                          [self setLoadingStatusText:statusText];
                      });
                  }
                completionHandler:^(NSString *filePath, NSError *error) {
                      if (error) {
                          NSLog(@"❌ M3U download failed: %@", error);
                          
                          // Show appropriate error message
                          NSString *errorMsg;
                          if ([error.domain isEqualToString:NSURLErrorDomain]) {
                              switch (error.code) {
                                  case NSURLErrorTimedOut:
                                      errorMsg = @"Connection timed out. Server not responding.";
                                      break;
                                  case NSURLErrorCannotFindHost:
                                      errorMsg = @"Cannot find host. Check URL and network.";
                                      break;
                                  case NSURLErrorCannotConnectToHost:
                                      errorMsg = @"Cannot connect to host. Server may be down.";
                                      break;
                                  case NSURLErrorNetworkConnectionLost:
                                      errorMsg = @"Network connection lost.";
                                      break;
                                  case NSURLErrorNotConnectedToInternet:
                                      errorMsg = @"Not connected to the internet.";
                                      break;
                                  default:
                                      errorMsg = [NSString stringWithFormat:@"Download error: %@", [error localizedDescription]];
                                      break;
                              }
                          } else {
                              errorMsg = [NSString stringWithFormat:@"Error: %@", [error localizedDescription]];
                          }
                          
                          dispatch_async(dispatch_get_main_queue(), ^{
                              [self clearLoadingState];
                              [self setLoadingStatusText:errorMsg];
                              
                              // Clear error message after a delay
                              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                                  [self setLoadingStatusText:@""];
                              });
                          });
                          [manager release];
        return;
    }
    
                      // Download succeeded
                      NSLog(@"✅ M3U download completed, processing file: %@", filePath);
                      
                      // Get file size for reporting
                      NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];
                      unsigned long long fileSize = [fileAttributes fileSize];
                      
                      dispatch_async(dispatch_get_main_queue(), ^{
                          [self setLoadingStatusText:[NSString stringWithFormat:@"Download complete: %.2f MB, processing...", 
                                                   (float)fileSize / 1048576.0]];
                      });
                      
                      // Process the downloaded M3U file by calling our existing processM3uContent method
                      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                          // Read the file content
                          NSError *readError = nil;
                          NSString *fileContents = [NSString stringWithContentsOfFile:filePath 
                                                                            encoding:NSUTF8StringEncoding 
                                                                               error:&readError];
                          
                          if (readError || !fileContents) {
                              NSLog(@"❌ Error reading downloaded M3U file: %@", readError);
                              dispatch_async(dispatch_get_main_queue(), ^{
                                  [self clearLoadingState];
                                  [self setLoadingStatusText:@"Error: Cannot read downloaded file"];
                              });
                          } else {
                              NSLog(@"✅ M3U file read successfully, size: %lu characters", (unsigned long)[fileContents length]);
                              
                              // Call processM3uContent to handle the content
                              [self processM3uContent:fileContents sourcePath:urlStr];
                          }
                          
                          [manager release];
                      });
                  }
                  destinationPath:tempFilePath];
}



// loadChannelsFromLocalFile implementation removed - using the one in VLCOverlayView+ChannelManagement.m category

- (void)processM3uContent:(NSString *)content sourcePath:(NSString *)sourcePath {
    NSLog(@"🔧 OPTIMIZED processM3uContent: %lu chars", (unsigned long)[content length]);
    
    // Split content efficiently
    NSArray *lines = [content componentsSeparatedByString:@"\n"];
    NSUInteger lineCount = [lines count];
    
    if (lineCount == 0) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self clearLoadingState];
            [self setLoadingStatusText:@"Error: Empty M3U file"];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
                [self setLoadingStatusText:@""];
            });
        });
        return;
    }
    
    [self ensureDataStructuresInitialized];
    [self setLoadingStatusText:@"Processing channels..."];
    
    // OPTIMIZED: Minimal temporary collections
    NSMutableArray *tempChannels = [[NSMutableArray alloc] initWithCapacity:50000];
    NSMutableArray *tempGroups = [[NSMutableArray alloc] initWithCapacity:200];
    NSMutableDictionary *tempChannelsByGroup = [[NSMutableDictionary alloc] initWithCapacity:200];
    NSMutableDictionary *tempGroupsByCategory = [[NSMutableDictionary alloc] initWithCapacity:5];
    
    // OPTIMIZED: Global string intern table for maximum memory efficiency
    static NSMutableDictionary *stringInternTable = nil;
    if (!stringInternTable) {
        stringInternTable = [[NSMutableDictionary alloc] initWithCapacity:10000];
    }
    
    // OPTIMIZED: Pre-compiled regex patterns (compiled once, used many times)
    static NSRegularExpression *groupRegex = nil;
    static NSRegularExpression *logoRegex = nil;
    static NSRegularExpression *idRegex = nil;
    
    if (!groupRegex) {
        groupRegex = [[NSRegularExpression alloc] initWithPattern:@"group-title=\"([^\"]*)\""
                                                          options:0 error:nil];
        logoRegex = [[NSRegularExpression alloc] initWithPattern:@"tvg-logo=\"([^\"]*)\""
                                                         options:0 error:nil];
        idRegex = [[NSRegularExpression alloc] initWithPattern:@"tvg-id=\"([^\"]*)\""
                                                       options:0 error:nil];
    }
    
    VLCChannel *currentChannel = nil;
    
    for (NSUInteger i = 0; i < lineCount; i++) {
        @autoreleasepool {
            // Show processing progress like macOS version
            if (i % 1000 == 0) {
                NSUInteger percentage = (i * 100) / lineCount;
                NSUInteger channelCount = [tempChannels count];
                
                // Update UI on main thread to show progress
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self setLoadingStatusText:[NSString stringWithFormat:@"Processing: %lu%% (%lu/%lu) - %lu channels", 
                                               (unsigned long)percentage, 
                                               (unsigned long)i, 
                                               (unsigned long)lineCount,
                                               (unsigned long)channelCount]];
                });
                
                // Memory monitoring every 5000 lines
                if (i % 5000 == 0 && i > 0) {
                    NSUInteger memoryMB = [self getCurrentMemoryUsageMB];
                    NSLog(@"📊 Processing line %lu: %luMB memory, %lu channels loaded", 
                          (unsigned long)i, (unsigned long)memoryMB, (unsigned long)channelCount);
                    
                    if (memoryMB > 3000) { // 3GB limit
                        NSLog(@"🚨 Memory limit reached at %luMB", (unsigned long)memoryMB);
                        break;
                    }
                }
            }
            
            NSString *line = [[lines objectAtIndex:i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            if ([line length] == 0 || ([line hasPrefix:@"#"] && ![line hasPrefix:@"#EXTINF"])) {
                continue;
            }
            
            if ([line hasPrefix:@"#EXTINF"]) {
                // Clean up previous channel
                if (currentChannel) {
                    [currentChannel release];
                    currentChannel = nil;
                }
                
                currentChannel = [[VLCChannel alloc] init];
                
                // OPTIMIZED: Extract channel name efficiently
                NSRange commaRange = [line rangeOfString:@"," options:NSBackwardsSearch];
                NSString *channelName = @"Unknown Channel";
                if (commaRange.location != NSNotFound) {
                    channelName = [[line substringFromIndex:commaRange.location + 1] 
                                   stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
                }
                
                // OPTIMIZED: Intern channel name
                NSString *internedName = [stringInternTable objectForKey:channelName];
                if (!internedName) {
                    internedName = [channelName copy];
                    [stringInternTable setObject:internedName forKey:channelName];
                    [internedName release];
                }
                currentChannel.name = internedName;
                
                // OPTIMIZED: Extract group using pre-compiled regex
                NSString *group = @"General";
                NSTextCheckingResult *groupMatch = [groupRegex firstMatchInString:line options:0 
                                                                            range:NSMakeRange(0, line.length)];
                if (groupMatch && groupMatch.numberOfRanges > 1) {
                    group = [line substringWithRange:[groupMatch rangeAtIndex:1]];
                }
                
                // OPTIMIZED: Intern group name
                NSString *internedGroup = [stringInternTable objectForKey:group];
                if (!internedGroup) {
                    internedGroup = [group copy];
                    [stringInternTable setObject:internedGroup forKey:group];
                    [internedGroup release];
                }
                currentChannel.group = internedGroup;
                
                // OPTIMIZED: Only extract logo if reasonable size
                NSTextCheckingResult *logoMatch = [logoRegex firstMatchInString:line options:0 
                                                                         range:NSMakeRange(0, line.length)];
                if (logoMatch && logoMatch.numberOfRanges > 1) {
                    NSString *logo = [line substringWithRange:[logoMatch rangeAtIndex:1]];
                    if (logo.length > 0 && logo.length < 200) {
                        NSString *internedLogo = [stringInternTable objectForKey:logo];
                        if (!internedLogo) {
                            internedLogo = [logo copy];
                            [stringInternTable setObject:internedLogo forKey:logo];
                            [internedLogo release];
                        }
                        currentChannel.logo = internedLogo;
                    }
                }
                
                // OPTIMIZED: Extract ID efficiently
                NSTextCheckingResult *idMatch = [idRegex firstMatchInString:line options:0 
                                                                      range:NSMakeRange(0, line.length)];
                if (idMatch && idMatch.numberOfRanges > 1) {
                    NSString *channelId = [line substringWithRange:[idMatch rangeAtIndex:1]];
                    if (channelId.length > 0 && channelId.length < 50) {
                        NSString *internedId = [stringInternTable objectForKey:channelId];
                        if (!internedId) {
                            internedId = [channelId copy];
                            [stringInternTable setObject:internedId forKey:channelId];
                            [internedId release];
                        }
                        currentChannel.channelId = internedId;
                    }
                }
                
                // TIMESHIFT DETECTION: Parse catchup attributes (iOS/tvOS implementation)
                // NSLog(@"🔧 [TIMESHIFT] Parsing catchup attributes for channel: %@", currentChannel.name);
                
                // Extract catchup value
                NSRange catchupRange = [line rangeOfString:@"catchup=\""];
                if (catchupRange.location != NSNotFound) {
                    NSUInteger startPos = catchupRange.location + catchupRange.length;
                    NSRange endQuoteRange = [line rangeOfString:@"\"" options:0 range:NSMakeRange(startPos, line.length - startPos)];
                    if (endQuoteRange.location != NSNotFound) {
                        NSString *catchupValue = [line substringWithRange:NSMakeRange(startPos, endQuoteRange.location - startPos)];
                        
                        // FIXED: Only consider specific valid catchup values as supporting timeshift
                        currentChannel.supportsCatchup = ([catchupValue isEqualToString:@"1"] || 
                                                         [catchupValue isEqualToString:@"default"] || 
                                                         [catchupValue isEqualToString:@"append"] ||
                                                         [catchupValue isEqualToString:@"timeshift"] ||
                                                         [catchupValue isEqualToString:@"shift"]);
                        currentChannel.catchupSource = catchupValue;
                        
                        // NSLog(@"🔧 [TIMESHIFT] Channel '%@' supports catch-up: %@ (source: %@)", 
                        //       currentChannel.name, currentChannel.supportsCatchup ? @"YES" : @"NO", catchupValue);
                    }
                }
                
                // Extract catchup-days value
                NSRange catchupDaysRange = [line rangeOfString:@"catchup-days=\""];
                if (catchupDaysRange.location != NSNotFound) {
                    NSUInteger startPos = catchupDaysRange.location + catchupDaysRange.length;
                    NSRange endQuoteRange = [line rangeOfString:@"\"" options:0 range:NSMakeRange(startPos, line.length - startPos)];
                    if (endQuoteRange.location != NSNotFound) {
                        NSString *catchupDaysStr = [line substringWithRange:NSMakeRange(startPos, endQuoteRange.location - startPos)];
                        currentChannel.catchupDays = [catchupDaysStr integerValue];
                        // NSLog(@"🔧 [TIMESHIFT] Channel '%@' catch-up days: %ld", currentChannel.name, (long)currentChannel.catchupDays);
                    }
                } else if (currentChannel.supportsCatchup) {
                    // Default to 7 days if catch-up is supported but no days specified
                    currentChannel.catchupDays = 7;
                    // NSLog(@"🔧 [TIMESHIFT] Channel '%@' defaulting to 7 days catchup", currentChannel.name);
                }
                
                // Extract catchup-template value
                NSRange catchupTemplateRange = [line rangeOfString:@"catchup-template=\""];
                if (catchupTemplateRange.location != NSNotFound) {
                    NSUInteger startPos = catchupTemplateRange.location + catchupTemplateRange.length;
                    NSRange endQuoteRange = [line rangeOfString:@"\"" options:0 range:NSMakeRange(startPos, line.length - startPos)];
                    if (endQuoteRange.location != NSNotFound) {
                        NSString *catchupTemplate = [line substringWithRange:NSMakeRange(startPos, endQuoteRange.location - startPos)];
                        currentChannel.catchupTemplate = catchupTemplate;
                        // NSLog(@"🔧 [TIMESHIFT] Channel '%@' catchup template: %@", currentChannel.name, catchupTemplate);
                    }
                }
                
            } else if (currentChannel && [line hasPrefix:@"http"]) {
                // OPTIMIZED: Intern URL
                NSString *internedUrl = [stringInternTable objectForKey:line];
                if (!internedUrl) {
                    internedUrl = [line copy];
                    [stringInternTable setObject:internedUrl forKey:line];
                    [internedUrl release];
                }
                currentChannel.url = internedUrl;
                
                // OPTIMIZED: Determine and intern category
                NSString *category = [self determineCategoryForGroup:currentChannel.group];
                NSString *internedCategory = [stringInternTable objectForKey:category];
                if (!internedCategory) {
                    internedCategory = [category copy];
                    [stringInternTable setObject:internedCategory forKey:category];
                    [internedCategory release];
                }
                currentChannel.category = internedCategory;
                
                // Add to collections efficiently
                [tempChannels addObject:currentChannel];
                
                if (![tempGroups containsObject:currentChannel.group]) {
                    [tempGroups addObject:currentChannel.group];
                }
                
                NSMutableArray *groupChannels = [tempChannelsByGroup objectForKey:currentChannel.group];
                if (!groupChannels) {
                    groupChannels = [[NSMutableArray alloc] initWithCapacity:500];
                    [tempChannelsByGroup setObject:groupChannels forKey:currentChannel.group];
                    [groupChannels release];
                }
                [groupChannels addObject:currentChannel];
                
                NSMutableArray *categoryGroups = [tempGroupsByCategory objectForKey:currentChannel.category];
                if (!categoryGroups) {
                    categoryGroups = [[NSMutableArray alloc] initWithCapacity:100];
                    [tempGroupsByCategory setObject:categoryGroups forKey:currentChannel.category];
                    [categoryGroups release];
                }
                if (![categoryGroups containsObject:currentChannel.group]) {
                    [categoryGroups addObject:currentChannel.group];
                }
                
                currentChannel = nil; // Clear reference
            }
        }
    }
    
    // Clean up any remaining channel
    if (currentChannel) {
        [currentChannel release];
    }
    
    // Atomically replace data
    [self safelyReplaceChannelData:tempChannels 
                            groups:tempGroups 
                   channelsByGroup:tempChannelsByGroup 
                  groupsByCategory:tempGroupsByCategory];
    
    // Clean up
    [tempChannels release];
    [tempGroups release]; 
    [tempChannelsByGroup release];
    [tempGroupsByCategory release];
    
    // Save channels to cache for faster startup next time
    NSString *cacheSourcePath = self.m3uFilePath;
    if ([sourcePath hasPrefix:NSTemporaryDirectory()]) {
        // Use original URL for cache instead of temp file
        cacheSourcePath = self.m3uFilePath;
    } else {
        cacheSourcePath = sourcePath;
    }
    [self saveChannelsToCache:cacheSourcePath];
    
    NSLog(@"✅ OPTIMIZED: %lu channels loaded efficiently", (unsigned long)[_channels count]);
    
    // Count and log timeshift channels for debugging
    NSInteger timeshiftChannelCount = 0;
    for (VLCChannel *channel in _channels) {
        if (channel.supportsCatchup || channel.catchupDays > 0) {
            timeshiftChannelCount++;
        }
    }
    NSLog(@"🔧 [TIMESHIFT-SUMMARY] Found %ld channels with timeshift support out of %lu total channels", 
          (long)timeshiftChannelCount, (unsigned long)[_channels count]);
    
    // Complete loading
    dispatch_async(dispatch_get_main_queue(), ^{
        [self clearChannelLoadingState];
        
        // Show final loading statistics like macOS
        NSUInteger totalChannels = [_channels count];
        NSUInteger totalGroups = [_channelsByGroup count];
        [self setLoadingStatusText:[NSString stringWithFormat:@"✅ Loaded %lu channels in %lu groups", 
                                   (unsigned long)totalChannels, (unsigned long)totalGroups]];
        
        // Clear status after delay
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
            [self setLoadingStatusText:@""];
        });
        
        [self setNeedsDisplay];
        
        // Auto-select best category and first group
        if ([_categories count] > 0) {
            // Find TV category or category with most groups (skip Settings)
            NSInteger bestCategoryIndex = 0;
            NSInteger bestGroupCount = 0;
            
            for (NSInteger i = 0; i < [_categories count]; i++) {
                NSString *category = [_categories objectAtIndex:i];
                if ([category isEqualToString:@"SETTINGS"]) continue;
                
                NSArray *groupsForCategory = [_groupsByCategory objectForKey:category];
                NSInteger groupCount = [groupsForCategory count];
                
                if ([category isEqualToString:@"TV"] || groupCount > bestGroupCount) {
                    bestCategoryIndex = i;
                    bestGroupCount = groupCount;
                    if ([category isEqualToString:@"TV"]) break;
                }
            }
            
            NSInteger previousCategoryIndex = _selectedCategoryIndex;
            _selectedCategoryIndex = bestCategoryIndex;
            
            // Handle settings panel visibility
            if (previousCategoryIndex == CATEGORY_SETTINGS && _selectedCategoryIndex != CATEGORY_SETTINGS) {
                [self hideSettingsPanel];
            } else if (_selectedCategoryIndex == CATEGORY_SETTINGS && previousCategoryIndex != CATEGORY_SETTINGS) {
                [self showSettingsPanel];
            }
            
            NSString *selectedCategory = [_categories objectAtIndex:_selectedCategoryIndex];
            NSArray *groupsForCategory = [_groupsByCategory objectForKey:selectedCategory];
            
            if ([groupsForCategory count] > 0) {
                _selectedGroupIndex = 0;
                _selectedChannelIndex = 0;
                NSLog(@"✅ Auto-selected category: %@ (%lu groups)", selectedCategory, (unsigned long)[groupsForCategory count]);
            }
        }
        
        // Auto-fetch catchup info for channels
        NSLog(@"🔄 Checking if autoFetchCatchupInfo method is available...");
        if ([self respondsToSelector:@selector(autoFetchCatchupInfo)]) {
            NSLog(@"✅ autoFetchCatchupInfo method found - calling it...");
            [self autoFetchCatchupInfo];
        } else {
            NSLog(@"❌ autoFetchCatchupInfo method NOT found - this should not happen anymore!");
        }
        
        // Auto-start EPG loading if configured
        if (self.epgUrl && [self.epgUrl length] > 0) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC), 
                          dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [self loadEpgData];
            });
        }
    });
}

#pragma mark - Settings Panel Management (iOS)

- (void)showSettingsPanel {
    NSLog(@"🔧 showSettingsPanel called");
    
    // Only show if we're in the Settings category
    if (_selectedCategoryIndex != CATEGORY_SETTINGS) {
        return;
    }
    
    // If settings scroll view doesn't exist, create it by triggering a redraw
    if (!_settingsScrollViewiOS) {
        // Trigger the drawing system to create the settings panel
        [self setNeedsDisplay];
        
        // Give the drawing system a chance to create the UI elements
        dispatch_async(dispatch_get_main_queue(), ^{
            if (_settingsScrollViewiOS) {
                _settingsScrollViewiOS.hidden = NO;
                if (_settingsScrollViewiOS.superview != self) {
                    [self addSubview:_settingsScrollViewiOS];
                }
            }
        });
    } else {
        // Make sure it's visible and added to the view
        if (_settingsScrollViewiOS.superview != self) {
            [self addSubview:_settingsScrollViewiOS];
        }
        _settingsScrollViewiOS.hidden = NO;
    }
}

- (void)hideSettingsPanel {
    NSLog(@"🔧 hideSettingsPanel called");
    
    if (_settingsScrollViewiOS) {
        // Hide the scroll view instead of removing it completely
        _settingsScrollViewiOS.hidden = YES;
        
        // Optionally remove from superview to save memory
        [_settingsScrollViewiOS removeFromSuperview];
    }
}

- (NSString *)determineCategoryForGroup:(NSString *)group {
    // Implement your logic to determine category based on group
    // This is just a placeholder implementation
    if ([group isEqualToString:@"General"]) return @"Settings";
    if ([group isEqualToString:@"Playlist"]) return @"Settings";
    if ([group isEqualToString:@"Subtitles"]) return @"Settings";
    if ([group isEqualToString:@"Movie Info"]) return @"Settings";
    if ([group isEqualToString:@"Themes"]) return @"Settings";
    return @"TV";
}

- (void)loadEpgData {
    NSLog(@"📺 iOS loadEpgData - starting EPG download");
    
    // Prevent overlapping downloads that cause memory crashes
    if (_isDownloadingEPG) {
        NSLog(@"⚠️ EPG download already in progress - skipping duplicate request");
        return;
    }
    
    if (!self.epgUrl || [self.epgUrl length] == 0) {
        NSLog(@"No EPG URL configured");
        dispatch_async(dispatch_get_main_queue(), ^{
            [self clearEpgLoadingState];
            [self setEpgLoadingStatusText:@"No EPG URL configured"];
        });
        return;
    }
    
    // Cancel any existing EPG download
    if (_currentEPGDownloadTask) {
        [_currentEPGDownloadTask cancel];
        _currentEPGDownloadTask = nil;
    }
    
    _isDownloadingEPG = YES;
    self.isLoadingEpg = YES;
    NSLog(@"Starting EPG download from: %@", self.epgUrl);
    
    // Update UI to show EPG loading (separate from M3U loading)
    dispatch_async(dispatch_get_main_queue(), ^{
        [self setEpgLoadingStatusText:@"Downloading EPG data..."];
        self.epgLoadingProgress = 0.0;
        // DON'T set self.isLoading = YES to avoid interfering with M3U loading
    });
    
    // Create temp file path for EPG
    NSString *tempDir = NSTemporaryDirectory();
    NSString *tempFilePath = [tempDir stringByAppendingPathComponent:@"epg_data.xml"];
    
    // Download EPG file
    DownloadManager *manager = [[DownloadManager alloc] init];
    [manager startDownloadFromURL:self.epgUrl
                  progressHandler:^(int64_t bytesReceived, int64_t totalBytes) {
                      float percentage = (totalBytes > 0) ? ((float)bytesReceived / (float)totalBytes) * 100.0 : 0.0;
                      dispatch_async(dispatch_get_main_queue(), ^{
                          self.epgLoadingProgress = percentage / 100.0;
                          [self setEpgLoadingStatusText:[NSString stringWithFormat:@"Downloading EPG: %.1f%% (%lld/%lld bytes)", 
                                                        percentage, 
                                                        bytesReceived, 
                                                        totalBytes]];
                      });
                  }
                completionHandler:^(NSString *filePath, NSError *error) {                    
                    if (!error && filePath) {
                        NSLog(@"✅ EPG download completed successfully to: %@", filePath);
                        dispatch_async(dispatch_get_main_queue(), ^{
                            [self setEpgLoadingStatusText:@"EPG download completed, processing data..."];
                            self.epgLoadingProgress = 1.0;
                        });
                        
                        // Load and process the EPG file with memory optimization
                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                            @autoreleasepool {
                                NSLog(@"📺 [EPG-MEMORY] 🧹 iOS EPG file processing with autorelease pool");
                                NSError *readError = nil;
                                NSData *epgData = [NSData dataWithContentsOfFile:filePath options:NSDataReadingMappedIfSafe error:&readError];
                            
                            if (readError || !epgData) {
                                NSLog(@"❌ Error reading EPG file: %@", readError ? readError.localizedDescription : @"No data");
                                dispatch_async(dispatch_get_main_queue(), ^{
                                    [self setEpgLoadingStatusText:@"Error reading EPG data"];
                                    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                                        [self clearEpgLoadingState];
                                        [self setEpgLoadingStatusText:@""];
                                    });
                                });
        return;
    }
    
                                                            NSLog(@"📺 Processing EPG data: %.2f MB", (float)epgData.length / 1048576.0);
                                
                                // Safety check: If EPG data is too large (>100MB), warn and potentially skip
                                if (epgData.length > 100 * 1024 * 1024) {
                                    NSLog(@"📺 [EPG-MEMORY] ⚠️ EPG file is very large (%.2f MB) - this may cause memory issues", (float)epgData.length / 1048576.0);
                                }
                                
                                dispatch_async(dispatch_get_main_queue(), ^{
                                    [self setEpgLoadingStatusText:@"Processing EPG data..."];
                                });
                            
                            // Process the EPG XML data using the existing EPG parsing logic
                            NSLog(@"📺 [EPG-iOS] ✅ About to process %lu bytes of EPG data", (unsigned long)epgData.length);
                            if ([self respondsToSelector:@selector(processEpgXmlData:)]) {
                                NSLog(@"📺 [EPG-iOS] ✅ processEpgXmlData method available - calling it now");
                                [self processEpgXmlData:epgData];
                            } else {
                                NSLog(@"📺 [EPG-iOS] ❌ processEpgXmlData method not available");
                                dispatch_async(dispatch_get_main_queue(), ^{
                                    [self setEpgLoadingStatusText:@"EPG processing not available"];
                                    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                                        [self clearEpgLoadingState];
                                        [self setEpgLoadingStatusText:@""];
                                    });
                                });
                            }
                            } // End autorelease pool for iOS EPG processing
                            NSLog(@"📺 [EPG-MEMORY] ✅ iOS EPG file processing autorelease pool completed");
                        });
                    } else {
                        NSLog(@"❌ EPG download failed: %@", error.localizedDescription);
                        dispatch_async(dispatch_get_main_queue(), ^{
                            [self setEpgLoadingStatusText:[NSString stringWithFormat:@"EPG download failed: %@", error.localizedDescription]];
                            self.epgLoadingProgress = 0.0;
                            [self clearEpgLoadingState];
                        });
                    }
                    
                    // Clean up download state and manager
                    _isDownloadingEPG = NO;
                    _currentEPGDownloadTask = nil;
                    [manager release];
                }
              destinationPath:tempFilePath];
}

#pragma mark - Theme Settings ScrollView

- (void)createOrUpdateThemeSettingsScrollView:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    if (!_themeSettingsScrollView) {
        CGRect scrollFrame = CGRectMake(x, 0, width, rect.size.height);
        _themeSettingsScrollView = [[UIScrollView alloc] initWithFrame:scrollFrame];
        _themeSettingsScrollView.backgroundColor = [UIColor clearColor];
        _themeSettingsScrollView.showsVerticalScrollIndicator = YES;
        _themeSettingsScrollView.showsHorizontalScrollIndicator = NO;
        _themeSettingsScrollView.userInteractionEnabled = YES;
        _themeSettingsScrollView.scrollEnabled = YES;
        _themeSettingsScrollView.bounces = YES;
        _themeSettingsScrollView.delaysContentTouches = NO; // Allow immediate touch response for sliders
        _themeSettingsScrollView.canCancelContentTouches = NO; // Don't cancel slider touches
        
        // Additional scroll view touch optimizations for single-tap slider response
        if ([_themeSettingsScrollView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) {
            _themeSettingsScrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
        }
        
#if TARGET_OS_IOS
        // Critical: Make the scroll view delegate touches immediately to subviews (iOS only)
        _themeSettingsScrollView.exclusiveTouch = NO;
        _themeSettingsScrollView.multipleTouchEnabled = YES;
        
        // Override all gesture recognizers to allow immediate slider interaction
        for (UIGestureRecognizer *gestureRecognizer in _themeSettingsScrollView.gestureRecognizers) {
            gestureRecognizer.cancelsTouchesInView = NO;
            gestureRecognizer.delaysTouchesBegan = NO;
            gestureRecognizer.delaysTouchesEnded = NO;
            
            if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) {
                UIPanGestureRecognizer *panGesture = (UIPanGestureRecognizer *)gestureRecognizer;
                // Only respond to multi-finger or very deliberate pan gestures
                panGesture.minimumNumberOfTouches = 1;
                panGesture.maximumNumberOfTouches = 2;
            }
        }
#endif
        [self addSubview:_themeSettingsScrollView];
        
        [self setupThemeSettingsContent];
    } else {
        // Update frame and show the scroll view
        CGRect newFrame = CGRectMake(x, 0, width, rect.size.height);
        _themeSettingsScrollView.frame = newFrame;
        _themeSettingsScrollView.hidden = NO; // Ensure it's visible
        
        // Recreate content if scroll view was hidden (returning from another group)
        if (_themeSettingsScrollView.subviews.count == 0) {
            [self setupThemeSettingsContent];
        }
    }
}

- (void)setupThemeSettingsContent {
#if TARGET_OS_IOS
    // Remove existing subviews
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        [subview removeFromSuperview];
    }
    
    CGFloat padding = 20;
    CGFloat currentY = padding;
    CGFloat controlWidth = _themeSettingsScrollView.frame.size.width - (padding * 2);
    CGFloat spacing = 25;
    
    // Title
    UILabel *titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 30)];
    titleLabel.text = @"Theme Settings";
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.font = [UIFont boldSystemFontOfSize:18];
    [_themeSettingsScrollView addSubview:titleLabel];
    [titleLabel release];
    currentY += 30 + spacing;
    
    // Theme label and dropdown (like macOS)
    UILabel *themeLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, 80, 20)];
    themeLabel.text = @"Theme:";
    themeLabel.textColor = [UIColor whiteColor];
    themeLabel.font = [UIFont systemFontOfSize:14];
    [_themeSettingsScrollView addSubview:themeLabel];
    [themeLabel release];
    
    // Theme dropdown button (styled like macOS)
    UIButton *themeDropdown = [UIButton buttonWithType:UIButtonTypeSystem];
    themeDropdown.frame = CGRectMake(padding + 90, currentY - 5, controlWidth - 100, 35);
    [themeDropdown setTitle:[self getCurrentThemeDisplayTextiOS] forState:UIControlStateNormal];
    [themeDropdown setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    themeDropdown.backgroundColor = [UIColor colorWithRed:0.15 green:0.15 blue:0.15 alpha:0.9];
    themeDropdown.layer.cornerRadius = 6;
    themeDropdown.layer.borderWidth = 1;
    themeDropdown.layer.borderColor = [UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0].CGColor;
    themeDropdown.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
    themeDropdown.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);
    themeDropdown.userInteractionEnabled = YES;
    [themeDropdown addTarget:self action:@selector(showThemeDropdown:) forControlEvents:UIControlEventTouchUpInside];
    [_themeSettingsScrollView addSubview:themeDropdown];
    
    // Add dropdown arrow
    UILabel *arrowLabel = [[UILabel alloc] initWithFrame:CGRectMake(themeDropdown.frame.size.width - 25, 8, 20, 20)];
    arrowLabel.text = @"▼";
    arrowLabel.textColor = [UIColor lightGrayColor];
    arrowLabel.font = [UIFont systemFontOfSize:12];
    arrowLabel.textAlignment = NSTextAlignmentCenter;
    arrowLabel.userInteractionEnabled = NO;
    [themeDropdown addSubview:arrowLabel];
    [arrowLabel release];
    
    currentY += 35 + spacing;
    
    // Transparency label and slider (like macOS)
    UILabel *transparencyLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    transparencyLabel.text = [NSString stringWithFormat:@"Transparency: %.0f%%", (self.themeAlpha ?: 0.8) * 100];
    transparencyLabel.textColor = [UIColor whiteColor];
    transparencyLabel.font = [UIFont systemFontOfSize:14];
    transparencyLabel.tag = 999; // For updating the label
    [_themeSettingsScrollView addSubview:transparencyLabel];
    [transparencyLabel release];
    currentY += 20 + 10;
    
    // Transparency slider (with proper touch handling)
    UISlider *transparencySlider = [[UISlider alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 30)];
    transparencySlider.minimumValue = 0.3;
    transparencySlider.maximumValue = 1.0;
    transparencySlider.value = self.themeAlpha ?: 0.8;
    transparencySlider.tintColor = [UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:1.0];
    transparencySlider.userInteractionEnabled = YES;
    transparencySlider.continuous = YES;
    transparencySlider.multipleTouchEnabled = NO; // Disable multi-touch for better single finger response
    transparencySlider.tag = 998; // For finding the slider
    // Add comprehensive touch event handlers for all slider interactions
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventValueChanged];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchDown];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchDragInside];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchDragOutside];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchUpInside];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchUpOutside];
    [transparencySlider addTarget:self action:@selector(transparencySliderChanged:) forControlEvents:UIControlEventTouchCancel];
    
    // Optimize slider for immediate single-tap response
    [self optimizeSliderForSingleTapResponse:transparencySlider];
    
    [_themeSettingsScrollView addSubview:transparencySlider];
    [transparencySlider release];
    currentY += 30 + spacing;
    
    // Custom theme controls (shown when Custom is selected)
    if (self.currentTheme == VLC_THEME_CUSTOM) {
        currentY = [self addCustomThemeControlsAtY:currentY padding:padding controlWidth:controlWidth spacing:spacing];
    }
    
    // Selection Colors section (like macOS)
    currentY += spacing;
    UILabel *selectionLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    selectionLabel.text = @"Selection Colors";
    selectionLabel.textColor = [UIColor whiteColor];
    selectionLabel.font = [UIFont boldSystemFontOfSize:16];
    [_themeSettingsScrollView addSubview:selectionLabel];
    [selectionLabel release];
    currentY += 20 + 15;
    
    // Selection Red
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Selection Red" 
                                        tag:11 
                                      value:self.customSelectionRed ?: 0.2];
    
    // Selection Green
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Selection Green" 
                                        tag:12 
                                      value:self.customSelectionGreen ?: 0.4];
    
    // Selection Blue
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Selection Blue" 
                                        tag:13 
                                      value:self.customSelectionBlue ?: 0.9];
    
    // Advanced Settings section
    currentY += spacing;
    UILabel *advancedLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    advancedLabel.text = @"Advanced Settings";
    advancedLabel.textColor = [UIColor whiteColor];
    advancedLabel.font = [UIFont boldSystemFontOfSize:16];
    [_themeSettingsScrollView addSubview:advancedLabel];
    [advancedLabel release];
    currentY += 20 + 15;
    
    // Glassmorphism toggle
    UILabel *glassLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    glassLabel.text = [NSString stringWithFormat:@"Glassmorphism Effects: %@", self.glassmorphismEnabled ? @"Enabled" : @"Disabled"];
    glassLabel.textColor = [UIColor whiteColor];
    glassLabel.font = [UIFont systemFontOfSize:14];
    glassLabel.tag = 1999; // For updating
    [_themeSettingsScrollView addSubview:glassLabel];
    [glassLabel release];
    currentY += 20 + 5;
    
    UISwitch *glassSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(padding, currentY, 60, 30)];
    glassSwitch.on = self.glassmorphismEnabled;
    glassSwitch.tag = 1998; // For identification
    [glassSwitch addTarget:self action:@selector(glassmorphismToggleChanged:) forControlEvents:UIControlEventValueChanged];
    [_themeSettingsScrollView addSubview:glassSwitch];
    [glassSwitch release];
    currentY += 30 + spacing;
    
    // Advanced Glassmorphism Controls (when enabled)
    if (self.glassmorphismEnabled) {
        currentY += 10; // Extra spacing before advanced controls
        
        // Glassmorphism Intensity
        currentY = [self addGlassmorphismSliderAtY:currentY 
                                          padding:padding 
                                     controlWidth:controlWidth 
                                          spacing:spacing 
                                            title:@"Glassmorphism Intensity" 
                                              tag:21 
                                            value:self.glassmorphismIntensity ?: 1.0
                                         minValue:0.0
                                         maxValue:1.0
                                      displayUnit:@"%"];
        
        // Blur Radius
        currentY = [self addGlassmorphismSliderAtY:currentY 
                                          padding:padding 
                                     controlWidth:controlWidth 
                                          spacing:spacing 
                                            title:@"Blur Radius" 
                                              tag:22 
                                            value:self.glassmorphismBlurRadius ?: 25.0
                                         minValue:0.0
                                         maxValue:50.0
                                      displayUnit:@"px"];
        
        // Border Width
        currentY = [self addGlassmorphismSliderAtY:currentY 
                                          padding:padding 
                                     controlWidth:controlWidth 
                                          spacing:spacing 
                                            title:@"Border Width" 
                                              tag:23 
                                            value:self.glassmorphismBorderWidth ?: 1.0
                                         minValue:0.0
                                         maxValue:5.0
                                      displayUnit:@"px"];
        
        // Corner Radius
        currentY = [self addGlassmorphismSliderAtY:currentY 
                                          padding:padding 
                                     controlWidth:controlWidth 
                                          spacing:spacing 
                                            title:@"Corner Radius" 
                                              tag:24 
                                            value:self.glassmorphismCornerRadius ?: 8.0
                                         minValue:0.0
                                         maxValue:20.0
                                      displayUnit:@"px"];
        
        // Sanded Texture Intensity
        currentY = [self addGlassmorphismSliderAtY:currentY 
                                          padding:padding 
                                     controlWidth:controlWidth 
                                          spacing:spacing 
                                            title:@"Sanded Texture" 
                                              tag:25 
                                            value:self.glassmorphismSandedIntensity ?: 0.0
                                         minValue:0.0
                                         maxValue:3.0
                                      displayUnit:@""];
        
        // High Quality toggle
        currentY += 10;
        UILabel *qualityLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
        qualityLabel.text = [NSString stringWithFormat:@"High Quality Mode: %@", self.glassmorphismHighQuality ? @"Enabled" : @"Disabled"];
        qualityLabel.textColor = [UIColor whiteColor];
        qualityLabel.font = [UIFont systemFontOfSize:14];
        qualityLabel.tag = 1997; // For updating
        [_themeSettingsScrollView addSubview:qualityLabel];
        [qualityLabel release];
        currentY += 20 + 5;
        
        UISwitch *qualitySwitch = [[UISwitch alloc] initWithFrame:CGRectMake(padding, currentY, 60, 30)];
        qualitySwitch.on = self.glassmorphismHighQuality;
        qualitySwitch.tag = 1996; // For identification
        [qualitySwitch addTarget:self action:@selector(glassmorphismQualityToggleChanged:) forControlEvents:UIControlEventValueChanged];
        [_themeSettingsScrollView addSubview:qualitySwitch];
        [qualitySwitch release];
        currentY += 30 + spacing;
        
        // Ignore Transparency toggle
        UILabel *ignoreLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
        ignoreLabel.text = [NSString stringWithFormat:@"Independent Transparency: %@", self.glassmorphismIgnoreTransparency ? @"Yes" : @"No"];
        ignoreLabel.textColor = [UIColor whiteColor];
        ignoreLabel.font = [UIFont systemFontOfSize:14];
        ignoreLabel.tag = 1995; // For updating
        [_themeSettingsScrollView addSubview:ignoreLabel];
        [ignoreLabel release];
        currentY += 20 + 5;
        
        UISwitch *ignoreSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(padding, currentY, 60, 30)];
        ignoreSwitch.on = self.glassmorphismIgnoreTransparency;
        ignoreSwitch.tag = 1994; // For identification
        [ignoreSwitch addTarget:self action:@selector(glassmorphismIgnoreToggleChanged:) forControlEvents:UIControlEventValueChanged];
        [_themeSettingsScrollView addSubview:ignoreSwitch];
        [ignoreSwitch release];
        currentY += 30 + spacing;
    }
    
    // Set content size with extra padding
    _themeSettingsScrollView.contentSize = CGSizeMake(_themeSettingsScrollView.frame.size.width, currentY + 50);
#else
    // tvOS fallback - show a simple message
    UILabel *tvosLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 20, _themeSettingsScrollView.frame.size.width - 40, 40)];
    tvosLabel.text = @"Theme settings not available on tvOS";
    tvosLabel.textColor = [UIColor whiteColor];
    tvosLabel.font = [UIFont systemFontOfSize:16];
    tvosLabel.textAlignment = NSTextAlignmentCenter;
    [_themeSettingsScrollView addSubview:tvosLabel];
    [tvosLabel release];
    
    _themeSettingsScrollView.contentSize = CGSizeMake(_themeSettingsScrollView.frame.size.width, 100);
#endif
}

- (NSString *)getCurrentThemeDisplayTextiOS {
    switch (self.currentTheme) {
        case VLC_THEME_DARK: return @"Dark";
        case VLC_THEME_DARKER: return @"Darker";
        case VLC_THEME_BLUE: return @"Blue";
        case VLC_THEME_GREEN: return @"Green";
        case VLC_THEME_PURPLE: return @"Purple";
        case VLC_THEME_CUSTOM: return @"Custom";
        default: return @"Dark";
    }
}

- (void)showThemeDropdown:(UIButton *)sender {
    NSLog(@"🎨 Theme dropdown tapped");
    
    // Create action sheet (iOS dropdown equivalent)
    UIAlertController *themeSheet = [UIAlertController alertControllerWithTitle:@"Select Theme" 
                                                                        message:nil 
                                                                 preferredStyle:UIAlertControllerStyleActionSheet];
    
    // Add theme options
    NSArray *themes = @[
        @[@"Dark", @(VLC_THEME_DARK)],
        @[@"Darker", @(VLC_THEME_DARKER)],
        @[@"Blue", @(VLC_THEME_BLUE)],
        @[@"Green", @(VLC_THEME_GREEN)],
        @[@"Purple", @(VLC_THEME_PURPLE)],
        @[@"Custom", @(VLC_THEME_CUSTOM)]
    ];
    
    for (NSArray *themeInfo in themes) {
        NSString *themeName = themeInfo[0];
        VLCColorTheme themeValue = [themeInfo[1] integerValue];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:themeName 
                                                         style:UIAlertActionStyleDefault 
                                                       handler:^(UIAlertAction * _Nonnull action) {
            [self selectTheme:themeValue];
        }];
        
        // Mark current theme
        if (themeValue == self.currentTheme) {
            [action setValue:[UIImage systemImageNamed:@"checkmark"] forKey:@"image"];
        }
        
        [themeSheet addAction:action];
    }
    
    // Add cancel button
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" 
                                                           style:UIAlertActionStyleCancel 
                                                         handler:nil];
    [themeSheet addAction:cancelAction];
    
    // Present the action sheet
    // Find the view controller
    UIViewController *viewController = nil;
    UIResponder *responder = self;
    while (responder) {
        if ([responder isKindOfClass:[UIViewController class]]) {
            viewController = (UIViewController *)responder;
            break;
        }
        responder = [responder nextResponder];
    }
    
    if (viewController) {
        // Configure for iPad
        if (themeSheet.popoverPresentationController) {
            themeSheet.popoverPresentationController.sourceView = sender;
            themeSheet.popoverPresentationController.sourceRect = sender.bounds;
        }
        
        [viewController presentViewController:themeSheet animated:YES completion:nil];
    }
}

- (void)selectTheme:(VLCColorTheme)theme {
    NSLog(@"🎨 Selected theme: %ld", (long)theme);
    
    // Apply the theme
    [self applyThemeiOS:theme];
    
    // Update dropdown button text
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UIButton class]]) {
            UIButton *button = (UIButton *)subview;
            if ([button.titleLabel.text containsString:@"Dark"] || 
                [button.titleLabel.text containsString:@"Custom"] ||
                [button.titleLabel.text containsString:@"Blue"] ||
                [button.titleLabel.text containsString:@"Green"] ||
                [button.titleLabel.text containsString:@"Purple"]) {
                [button setTitle:[self getCurrentThemeDisplayTextiOS] forState:UIControlStateNormal];
                break;
            }
        }
    }
    
    // Refresh the theme settings to show/hide custom controls
    [self setupThemeSettingsContent];
}

#if TARGET_OS_IOS
- (void)transparencySliderChanged:(UISlider *)sender {
    CGFloat transparency = sender.value;
    NSLog(@"🌫️ Transparency slider changed to: %.2f", transparency);
    
    // Update theme alpha and apply immediately
    self.themeAlpha = transparency;
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
    
    // Update the transparency label
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == 999) {
            UILabel *label = (UILabel *)subview;
            label.text = [NSString stringWithFormat:@"Transparency: %.0f%%", transparency * 100];
            break;
        }
    }
}

- (CGFloat)addCustomThemeControlsAtY:(CGFloat)currentY 
                             padding:(CGFloat)padding 
                        controlWidth:(CGFloat)controlWidth 
                             spacing:(CGFloat)spacing {
    
    // Custom RGB Controls section
    UILabel *customLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    customLabel.text = @"Custom Colors";
    customLabel.textColor = [UIColor whiteColor];
    customLabel.font = [UIFont boldSystemFontOfSize:16];
    [_themeSettingsScrollView addSubview:customLabel];
    [customLabel release];
    currentY += 20 + 15;
    
    // Red component
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Red" 
                                        tag:1 
                                      value:self.customThemeRed ?: 0.10];
    
    // Green component  
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Green" 
                                        tag:2 
                                      value:self.customThemeGreen ?: 0.12];
    
    // Blue component
    currentY = [self addCustomColorSliderAtY:currentY 
                                    padding:padding 
                               controlWidth:controlWidth 
                                    spacing:spacing 
                                      title:@"Blue" 
                                        tag:3 
                                      value:self.customThemeBlue ?: 0.16];
    
    return currentY;
}

- (CGFloat)addCustomColorSliderAtY:(CGFloat)currentY 
                           padding:(CGFloat)padding 
                      controlWidth:(CGFloat)controlWidth 
                           spacing:(CGFloat)spacing 
                             title:(NSString *)title 
                               tag:(NSInteger)tag 
                             value:(CGFloat)value {
    
    // Color label
    UILabel *colorLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    colorLabel.text = [NSString stringWithFormat:@"%@: %.2f", title, value];
    colorLabel.textColor = [UIColor whiteColor];
    colorLabel.font = [UIFont systemFontOfSize:14];
    colorLabel.tag = tag + 100; // For updating the label
    [_themeSettingsScrollView addSubview:colorLabel];
    [colorLabel release];
    currentY += 20 + 5;
    
    // Color slider with enhanced touch handling
    UISlider *colorSlider = [[UISlider alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 30)];
    colorSlider.minimumValue = 0.0;
    colorSlider.maximumValue = 1.0;
    colorSlider.value = value;
    colorSlider.tag = tag;
    colorSlider.userInteractionEnabled = YES;
    colorSlider.continuous = YES;
    colorSlider.multipleTouchEnabled = NO; // Disable multi-touch for better single finger response
    
    // Set appropriate color for each slider
    switch (tag) {
        case 1: // Red
            colorSlider.tintColor = [UIColor redColor];
            break;
        case 2: // Green
            colorSlider.tintColor = [UIColor greenColor];
            break;
        case 3: // Blue
            colorSlider.tintColor = [UIColor blueColor];
            break;
        default:
            colorSlider.tintColor = [UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:1.0];
            break;
    }
    
    // Add comprehensive touch event handlers for all slider interactions
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventValueChanged];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchDown];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchDragInside];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchDragOutside];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchUpInside];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchUpOutside];
    [colorSlider addTarget:self action:@selector(customColorSliderChanged:) forControlEvents:UIControlEventTouchCancel];
    
    // Optimize slider for immediate single-tap response
    [self optimizeSliderForSingleTapResponse:colorSlider];
    
    [_themeSettingsScrollView addSubview:colorSlider];
    [colorSlider release];
    currentY += 30 + spacing;
    
    return currentY;
}

- (CGFloat)addGlassmorphismSliderAtY:(CGFloat)currentY 
                             padding:(CGFloat)padding 
                        controlWidth:(CGFloat)controlWidth 
                             spacing:(CGFloat)spacing 
                               title:(NSString *)title 
                                 tag:(NSInteger)tag 
                               value:(CGFloat)value
                            minValue:(CGFloat)minValue
                            maxValue:(CGFloat)maxValue
                         displayUnit:(NSString *)displayUnit {
    
    // Format display value based on unit
    NSString *displayValue;
    if ([displayUnit isEqualToString:@"%"]) {
        displayValue = [NSString stringWithFormat:@"%.0f%%", value * 100];
    } else if ([displayUnit isEqualToString:@"px"]) {
        displayValue = [NSString stringWithFormat:@"%.1f px", value];
    } else {
        displayValue = [NSString stringWithFormat:@"%.1f", value];
    }
    
    // Glassmorphism slider label
    UILabel *glassLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    glassLabel.text = [NSString stringWithFormat:@"%@: %@", title, displayValue];
    glassLabel.textColor = [UIColor whiteColor];
    glassLabel.font = [UIFont systemFontOfSize:14];
    glassLabel.tag = tag + 100; // For updating the label
    [_themeSettingsScrollView addSubview:glassLabel];
    [glassLabel release];
    currentY += 20 + 5;
    
    // Glassmorphism slider with optimized touch handling
    UISlider *glassSlider = [[UISlider alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 30)];
    glassSlider.minimumValue = minValue;
    glassSlider.maximumValue = maxValue;
    glassSlider.value = value;
    glassSlider.tag = tag;
    glassSlider.userInteractionEnabled = YES;
    glassSlider.continuous = YES;
    glassSlider.multipleTouchEnabled = NO;
    
    // Set appropriate colors for different glassmorphism sliders
    switch (tag) {
        case 21: // Intensity
            glassSlider.tintColor = [UIColor colorWithRed:0.3 green:0.7 blue:1.0 alpha:1.0];
            break;
        case 22: // Blur
            glassSlider.tintColor = [UIColor colorWithRed:0.5 green:0.8 blue:1.0 alpha:1.0];
            break;
        case 23: // Border
            glassSlider.tintColor = [UIColor colorWithRed:0.7 green:0.9 blue:1.0 alpha:1.0];
            break;
        case 24: // Corner
            glassSlider.tintColor = [UIColor colorWithRed:0.9 green:1.0 blue:1.0 alpha:1.0];
            break;
        case 25: // Sanded
            glassSlider.tintColor = [UIColor colorWithRed:1.0 green:0.9 blue:0.7 alpha:1.0];
            break;
        default:
            glassSlider.tintColor = [UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:1.0];
            break;
    }
    
    // Add comprehensive touch event handlers for all slider interactions
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventValueChanged];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchDown];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchDragInside];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchDragOutside];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchUpInside];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchUpOutside];
    [glassSlider addTarget:self action:@selector(glassmorphismSliderChanged:) forControlEvents:UIControlEventTouchCancel];
    
    // Optimize slider for immediate single-tap response
    [self optimizeSliderForSingleTapResponse:glassSlider];
    
    [_themeSettingsScrollView addSubview:glassSlider];
    [glassSlider release];
    currentY += 30 + spacing;
    
    return currentY;
}

- (void)customColorSliderChanged:(UISlider *)sender {
    NSInteger colorTag = sender.tag;
    CGFloat colorValue = sender.value;
    
    // Update the corresponding label
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == (colorTag + 100)) {
            UILabel *label = (UILabel *)subview;
            NSString *colorName = @"";
            
            // Handle both custom theme colors (1-3) and selection colors (11-13)
            switch (colorTag) {
                case 1: colorName = @"Red"; break;
                case 2: colorName = @"Green"; break;
                case 3: colorName = @"Blue"; break;
                case 11: colorName = @"Selection Red"; break;
                case 12: colorName = @"Selection Green"; break;
                case 13: colorName = @"Selection Blue"; break;
            }
            label.text = [NSString stringWithFormat:@"%@: %.2f", colorName, colorValue];
            break;
        }
    }
    
    // Update color values
    switch (colorTag) {
        case 1: // Custom Theme Red
            self.customThemeRed = colorValue;
            NSLog(@"🔴 Custom red changed to: %.2f", colorValue);
            break;
        case 2: // Custom Theme Green
            self.customThemeGreen = colorValue;
            NSLog(@"🟢 Custom green changed to: %.2f", colorValue);
            break;
        case 3: // Custom Theme Blue
            self.customThemeBlue = colorValue;
            NSLog(@"🔵 Custom blue changed to: %.2f", colorValue);
            break;
        case 11: // Selection Red
            self.customSelectionRed = colorValue;
            NSLog(@"🟡 Selection red changed to: %.2f", colorValue);
            break;
        case 12: // Selection Green
            self.customSelectionGreen = colorValue;
            NSLog(@"🟡 Selection green changed to: %.2f", colorValue);
            break;
        case 13: // Selection Blue
            self.customSelectionBlue = colorValue;
            NSLog(@"🟡 Selection blue changed to: %.2f", colorValue);
            break;
    }
    
    // Apply theme colors immediately like macOS
    [self updateThemeColorsiOS];
    [self updateSelectionColorsToCurrentTheme];
    [self setNeedsDisplay];
    
    NSLog(@"🎨 Applied color changes, theme updated");
}

- (void)glassmorphismSliderChanged:(UISlider *)sender {
    NSInteger sliderTag = sender.tag;
    CGFloat sliderValue = sender.value;
    
    // Update the corresponding label with proper formatting
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == (sliderTag + 100)) {
            UILabel *label = (UILabel *)subview;
            NSString *sliderName = @"";
            NSString *displayValue = @"";
            
            // Handle different glassmorphism sliders with proper display formatting
            switch (sliderTag) {
                case 21: // Intensity
                    sliderName = @"Glassmorphism Intensity";
                    displayValue = [NSString stringWithFormat:@"%.0f%%", sliderValue * 100];
                    break;
                case 22: // Blur Radius
                    sliderName = @"Blur Radius";
                    displayValue = [NSString stringWithFormat:@"%.1f px", sliderValue];
                    break;
                case 23: // Border Width
                    sliderName = @"Border Width";
                    displayValue = [NSString stringWithFormat:@"%.1f px", sliderValue];
                    break;
                case 24: // Corner Radius
                    sliderName = @"Corner Radius";
                    displayValue = [NSString stringWithFormat:@"%.1f px", sliderValue];
                    break;
                case 25: // Sanded Texture
                    sliderName = @"Sanded Texture";
                    displayValue = [NSString stringWithFormat:@"%.1f", sliderValue];
                    break;
            }
            label.text = [NSString stringWithFormat:@"%@: %@", sliderName, displayValue];
            break;
        }
    }
    
    // Update glassmorphism property values
    switch (sliderTag) {
        case 21: // Glassmorphism Intensity
            self.glassmorphismIntensity = sliderValue;
            NSLog(@"✨ Glassmorphism intensity changed to: %.2f", sliderValue);
            break;
        case 22: // Blur Radius
            self.glassmorphismBlurRadius = sliderValue;
            NSLog(@"✨ Glassmorphism blur radius changed to: %.2f", sliderValue);
            break;
        case 23: // Border Width
            self.glassmorphismBorderWidth = sliderValue;
            NSLog(@"✨ Glassmorphism border width changed to: %.2f", sliderValue);
            break;
        case 24: // Corner Radius
            self.glassmorphismCornerRadius = sliderValue;
            NSLog(@"✨ Glassmorphism corner radius changed to: %.2f", sliderValue);
            break;
        case 25: // Sanded Texture Intensity
            self.glassmorphismSandedIntensity = sliderValue;
            NSLog(@"✨ Glassmorphism sanded intensity changed to: %.2f", sliderValue);
            break;
    }
    
    // Apply glassmorphism changes immediately like macOS
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
    
    NSLog(@"✨ Applied glassmorphism changes");
}

- (void)glassmorphismToggleChanged:(UISwitch *)sender {
    BOOL enabled = sender.isOn;
    NSLog(@"✨ Glassmorphism toggled: %@", enabled ? @"ON" : @"OFF");
    
    self.glassmorphismEnabled = enabled;
    
    // Update the label
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == 1999) {
            UILabel *label = (UILabel *)subview;
            label.text = [NSString stringWithFormat:@"Glassmorphism Effects: %@", enabled ? @"Enabled" : @"Disabled"];
            break;
        }
    }
    
    // Recreate the entire theme settings to show/hide advanced controls
    [self setupThemeSettingsContent];
    
    // Apply the change immediately
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
}

- (void)glassmorphismQualityToggleChanged:(UISwitch *)sender {
    BOOL enabled = sender.isOn;
    NSLog(@"✨ Glassmorphism quality toggled: %@", enabled ? @"HIGH" : @"LOW");
    
    self.glassmorphismHighQuality = enabled;
    
    // Update the label
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == 1997) {
            UILabel *label = (UILabel *)subview;
            label.text = [NSString stringWithFormat:@"High Quality Mode: %@", enabled ? @"Enabled" : @"Disabled"];
            break;
        }
    }
    
    // Apply the change immediately
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
}

- (void)glassmorphismIgnoreToggleChanged:(UISwitch *)sender {
    BOOL enabled = sender.isOn;
    NSLog(@"✨ Glassmorphism ignore transparency toggled: %@", enabled ? @"YES" : @"NO");
    
    self.glassmorphismIgnoreTransparency = enabled;
    
    // Update the label
    for (UIView *subview in _themeSettingsScrollView.subviews) {
        if ([subview isKindOfClass:[UILabel class]] && subview.tag == 1995) {
            UILabel *label = (UILabel *)subview;
            label.text = [NSString stringWithFormat:@"Independent Transparency: %@", enabled ? @"Yes" : @"No"];
            break;
        }
    }
    
    // Apply the change immediately
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
}

- (void)optimizeSliderForSingleTapResponse:(UISlider *)slider {
    // Ensure slider responds immediately to single tap without scroll view interference
    
    // Disable all gesture recognizers that might delay touch response
    for (UIGestureRecognizer *gesture in slider.gestureRecognizers) {
        gesture.delaysTouchesBegan = NO;
        gesture.delaysTouchesEnded = NO;
        gesture.cancelsTouchesInView = NO;
    }
    
    // Set additional slider properties for immediate response
    slider.exclusiveTouch = YES;  // Prevent other controls from interfering
    
    // Force the slider to be higher priority than its superview's gesture recognizers
    if (slider.superview) {
        for (UIGestureRecognizer *superGesture in slider.superview.gestureRecognizers) {
            for (UIGestureRecognizer *sliderGesture in slider.gestureRecognizers) {
                [superGesture requireGestureRecognizerToFail:sliderGesture];
            }
        }
    }
    
    // Create a custom tap gesture specifically for immediate slider response
    UITapGestureRecognizer *immediateSliderTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleImmediateSliderTap:)];
    immediateSliderTap.delaysTouchesBegan = NO;
    immediateSliderTap.delaysTouchesEnded = NO;
    immediateSliderTap.cancelsTouchesInView = NO;
    immediateSliderTap.numberOfTapsRequired = 1;
    immediateSliderTap.numberOfTouchesRequired = 1;
    [slider addGestureRecognizer:immediateSliderTap];
    [immediateSliderTap release];
}

- (void)handleImmediateSliderTap:(UITapGestureRecognizer *)gesture {
    if ([gesture.view isKindOfClass:[UISlider class]]) {
        UISlider *slider = (UISlider *)gesture.view;
        
        // Get tap location and convert to slider value
        CGPoint tapLocation = [gesture locationInView:slider];
        CGFloat sliderWidth = slider.bounds.size.width;
        CGFloat percentage = tapLocation.x / sliderWidth;
        percentage = MAX(0.0, MIN(1.0, percentage)); // Clamp to valid range
        
        // Calculate new slider value
        CGFloat newValue = slider.minimumValue + (percentage * (slider.maximumValue - slider.minimumValue));
        
        // Update slider value and trigger events
        slider.value = newValue;
        [slider sendActionsForControlEvents:UIControlEventValueChanged];
        [slider sendActionsForControlEvents:UIControlEventTouchDown];
        [slider sendActionsForControlEvents:UIControlEventTouchUpInside];
        
        NSLog(@"🎯 Single tap on slider detected - immediate response with value: %.2f", newValue);
    }
}
#endif // TARGET_OS_IOS - End of iOS-specific UI methods

#pragma mark - Subtitle Settings ScrollView

#if TARGET_OS_IOS
- (void)createOrUpdateSubtitleSettingsScrollView:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    if (!_subtitleSettingsScrollView) {
        CGRect scrollFrame = CGRectMake(x, 0, width, rect.size.height);
        _subtitleSettingsScrollView = [[UIScrollView alloc] initWithFrame:scrollFrame];
        _subtitleSettingsScrollView.backgroundColor = [UIColor clearColor];
        _subtitleSettingsScrollView.showsVerticalScrollIndicator = YES;
        _subtitleSettingsScrollView.showsHorizontalScrollIndicator = NO;
        [self addSubview:_subtitleSettingsScrollView];
        
        [self setupSubtitleSettingsContent];
    } else {
        // Update frame
        CGRect newFrame = CGRectMake(x, 0, width, rect.size.height);
        _subtitleSettingsScrollView.frame = newFrame;
    }
}

- (void)setupSubtitleSettingsContent {
    // Remove existing subviews
    for (UIView *subview in _subtitleSettingsScrollView.subviews) {
        [subview removeFromSuperview];
    }
    
    CGFloat padding = 20;
    CGFloat currentY = padding;
    CGFloat controlWidth = _subtitleSettingsScrollView.frame.size.width - (padding * 2);
    CGFloat controlHeight = 40;
    CGFloat spacing = 15;
    
    // Title
    UILabel *titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 30)];
    titleLabel.text = @"Subtitle Settings";
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.font = [UIFont boldSystemFontOfSize:18];
    [_subtitleSettingsScrollView addSubview:titleLabel];
    currentY += 30 + spacing;
    
    // Description
    UILabel *descLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 20)];
    descLabel.text = @"Move the slider to adjust subtitle text size in real-time";
    descLabel.textColor = [UIColor lightGrayColor];
    descLabel.font = [UIFont systemFontOfSize:12];
    [_subtitleSettingsScrollView addSubview:descLabel];
    currentY += 20 + spacing * 2;
    
    // Font Size Section
    _subtitleFontSizeLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 25)];
    _subtitleFontSizeLabel.text = @"Font Size: 16 px";
    _subtitleFontSizeLabel.textColor = [UIColor whiteColor];
    _subtitleFontSizeLabel.font = [UIFont boldSystemFontOfSize:16];
    [_subtitleSettingsScrollView addSubview:_subtitleFontSizeLabel];
    currentY += 25 + 10;
    
    // Font size slider (like macOS)
#if TARGET_OS_IOS
    _subtitleFontSizeSlider = [[UISlider alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, controlHeight)];
    _subtitleFontSizeSlider.minimumValue = 8;
    _subtitleFontSizeSlider.maximumValue = 32;
    _subtitleFontSizeSlider.value = 16;
    _subtitleFontSizeSlider.tintColor = [UIColor colorWithRed:0.0 green:0.5 blue:1.0 alpha:1.0];
    [_subtitleFontSizeSlider addTarget:self action:@selector(subtitleFontSizeChanged:) forControlEvents:UIControlEventValueChanged];
    [_subtitleSettingsScrollView addSubview:_subtitleFontSizeSlider];
#endif
    currentY += controlHeight + spacing * 2;
    
    // Additional subtitle options
    NSArray *subtitleOptions = @[
        @"Font Color",
        @"Background Color", 
        @"Position", 
        @"Language",
        @"Encoding"
    ];
    
    for (NSString *option in subtitleOptions) {
        UILabel *optionLabel = [[UILabel alloc] initWithFrame:CGRectMake(padding, currentY, controlWidth, 25)];
        optionLabel.text = option;
        optionLabel.textColor = [UIColor whiteColor];
        optionLabel.font = [UIFont boldSystemFontOfSize:14];
        [_subtitleSettingsScrollView addSubview:optionLabel];
        currentY += 25 + 5;
        
        UIButton *optionButton = [UIButton buttonWithType:UIButtonTypeRoundedRect];
        optionButton.frame = CGRectMake(padding, currentY, controlWidth, 35);
        [optionButton setTitle:[NSString stringWithFormat:@"Configure %@", option] forState:UIControlStateNormal];
        [optionButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        optionButton.backgroundColor = [UIColor colorWithRed:0.2 green:0.3 blue:0.4 alpha:1.0];
        optionButton.layer.cornerRadius = 6;
        [optionButton addTarget:self action:@selector(subtitleOptionSelected:) forControlEvents:UIControlEventTouchUpInside];
        [_subtitleSettingsScrollView addSubview:optionButton];
        currentY += 35 + spacing;
    }
    
    // Set content size
    _subtitleSettingsScrollView.contentSize = CGSizeMake(_subtitleSettingsScrollView.frame.size.width, currentY + padding);
}

#if TARGET_OS_IOS
- (void)subtitleFontSizeChanged:(UISlider *)sender {
    NSInteger fontSize = (NSInteger)sender.value;
    _subtitleFontSizeLabel.text = [NSString stringWithFormat:@"Font Size: %ld px", (long)fontSize];
    NSLog(@"🔤 Subtitle font size changed to: %ld px", (long)fontSize);
    
    // TODO: Apply to VLC player immediately like macOS version
    // Example: [self.player.currentVideoSubTitleIndex setFont...];
}
#endif

- (void)subtitleOptionSelected:(UIButton *)sender {
    NSLog(@"🔧 Subtitle option selected: %@", sender.titleLabel.text);
    // TODO: Implement subtitle option dialogs
}
#endif // TARGET_OS_IOS - End of iOS subtitle settings

#pragma mark - iOS Gesture Handlers


#pragma mark - Program Guide Drawing (iOS/tvOS)

- (void)drawProgramGuideForChannelAtIndex:(NSInteger)channelIndex rect:(CGRect)rect {
    // Calculate responsive dimensions
    CGFloat categoryWidth = [self categoryWidth];
    CGFloat groupWidth = [self groupWidth];
    CGFloat programGuideWidth = [self programGuideWidth];
    
    // Calculate program guide area
    CGFloat channelListX = categoryWidth + groupWidth;
    CGFloat channelListWidth = rect.size.width - channelListX - programGuideWidth;
    CGFloat programGuideX = channelListX + channelListWidth;
    
    // Draw program guide background
    CGRect programGuideRect = CGRectMake(programGuideX, 0, programGuideWidth, rect.size.height);
    [[UIColor colorWithRed:0.1 green:0.1 blue:0.15 alpha:0.8] setFill];
    UIRectFill(programGuideRect);
    
    // Get channel data using the same method as macOS
    VLCChannel *channel = [self getChannelAtIndex:channelIndex];
    
    // Auto-trigger EPG loading if not loaded
    if (!self.isEpgLoaded && !self.isLoadingEpg) {
        // First, try to auto-generate EPG URL if missing
        if (!self.epgUrl || [self.epgUrl length] == 0) {
            NSLog(@"📺 [AUTO-EPG] No EPG URL found, trying to auto-generate...");
            [self autoGenerateEpgUrl];
        }
        
        // Now try to load EPG if we have a URL
        if (self.epgUrl && [self.epgUrl length] > 0) {
            NSLog(@"📺 [AUTO-EPG] Triggering EPG loading automatically...");
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [self loadEpgDataAtStartup];
            });
        } else {
            NSLog(@"📺 [AUTO-EPG] ❌ No EPG URL available and could not auto-generate from M3U URL");
        }
    }
    
    if (!channel) {
        // Show "No program data available" message
        NSDictionary *attrs = @{
            NSFontAttributeName: [UIFont systemFontOfSize:14],
            NSForegroundColorAttributeName: [UIColor lightGrayColor]
        };
        
        CGRect messageRect = CGRectMake(programGuideX + 20, rect.size.height / 2 - 10, programGuideWidth - 40, 20);
        [@"No program data available" drawInRect:messageRect withAttributes:attrs];
        return;
    }
    
    // Draw channel name at top
    NSDictionary *channelNameAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:16],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect channelNameRect = CGRectMake(programGuideX + 15, rect.size.height - 45, programGuideWidth - 30, 25);
    NSString *channelName = channel.name ?: @"Unknown Channel";
    [channelName drawInRect:channelNameRect withAttributes:channelNameAttrs];
    
    // Check if channel has EPG data
    if (!channel.programs || [channel.programs count] == 0) {
        // Show appropriate message based on EPG loading state
        NSDictionary *attrs = @{
            NSFontAttributeName: [UIFont systemFontOfSize:12],
            NSForegroundColorAttributeName: [UIColor lightGrayColor]
        };
        
        CGRect messageRect = CGRectMake(programGuideX + 15, rect.size.height - 80, programGuideWidth - 30, 20);
        
        NSString *message;
        if (self.isEpgLoaded) {
            message = @"No program schedule available";
        } else if (self.isLoadingEpg) {
            message = @"Loading program guide...";
        } else {
            message = @"Program guide not loaded";
        }
        
        [message drawInRect:messageRect withAttributes:attrs];
        return;
    }
    
    // Sort programs by start time
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    // Get current time for highlighting current program
    NSDate *now = [NSDate date];
    NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600;
    NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
    
    // Find current program
    NSInteger currentProgramIndex = -1;
    for (NSInteger i = 0; i < sortedPrograms.count; i++) {
        VLCProgram *program = sortedPrograms[i];
        if ([adjustedNow timeIntervalSinceDate:program.startTime] >= 0 && 
            [adjustedNow timeIntervalSinceDate:program.endTime] < 0) {
            currentProgramIndex = i;
            break;
        }
    }
    
    // Check if we're playing timeshift content and get the timeshift playing program
    BOOL isTimeshiftPlaying = [self isCurrentlyPlayingTimeshift];
    VLCProgram *timeshiftPlayingProgram = nil;
    NSInteger timeshiftProgramIndex = -1;
    
    if (isTimeshiftPlaying) {
        // Get the program that's currently being played via timeshift
        timeshiftPlayingProgram = [self getCurrentTimeshiftPlayingProgram];
        
        // Find the index of the timeshift playing program
        if (timeshiftPlayingProgram && channel.programs) {
            for (NSInteger i = 0; i < channel.programs.count; i++) {
                VLCProgram *program = [channel.programs objectAtIndex:i];
                if ([program.title isEqualToString:timeshiftPlayingProgram.title] &&
                    [program.startTime isEqualToDate:timeshiftPlayingProgram.startTime]) {
                    timeshiftProgramIndex = i;
                    break;
                }
            }
        }
    }
    
    // Calculate drawing parameters
    CGFloat programHeight = 60;
    CGFloat programSpacing = 5;
    CGFloat contentStartY = rect.size.height - 90; // Leave space for channel name
    CGFloat visibleHeight = contentStartY - 20; // Bottom margin
    
    // Calculate total content height for scrolling
    CGFloat totalContentHeight = sortedPrograms.count * (programHeight + programSpacing);
    CGFloat maxScrollPosition = MAX(0, totalContentHeight - visibleHeight);
    
    // Auto-scroll to current program when EPG first opens (center it in the view)
    static NSMutableDictionary *centeredChannels = nil;
    if (!centeredChannels) {
        centeredChannels = [[NSMutableDictionary alloc] init];
    }
    
    NSString *channelKey = [NSString stringWithFormat:@"%@_%ld", channel.name ?: @"unknown", (long)channel.programs.count];
    if (currentProgramIndex >= 0 && ![centeredChannels objectForKey:channelKey]) {
        // Calculate position to center the current program
        CGFloat currentProgramY = currentProgramIndex * (programHeight + programSpacing);
        CGFloat targetScrollPosition = currentProgramY - (visibleHeight / 2) + (programHeight / 2);
        targetScrollPosition = MAX(0, MIN(targetScrollPosition, maxScrollPosition));
        
        _programGuideScrollPosition = targetScrollPosition;
        [centeredChannels setObject:@YES forKey:channelKey];
        
        NSLog(@"📺 [EPG-CENTER] Auto-centered current program %ld at scroll position %.1f", (long)currentProgramIndex, targetScrollPosition);
    }
    
    // DEBUG: Log scroll calculations
    static NSInteger debugLogCount = 0;
    if (debugLogCount % 60 == 0) { // Log every 60 frames to avoid spam
        NSLog(@"📺 [EPG-SCROLL] Programs: %ld, ContentHeight: %.1f, VisibleHeight: %.1f, MaxScroll: %.1f, CurrentScroll: %.1f", 
              (long)sortedPrograms.count, totalContentHeight, visibleHeight, maxScrollPosition, _programGuideScrollPosition);
    }
    debugLogCount++;
    
    // Clamp scroll position
    _programGuideScrollPosition = MAX(0, MIN(_programGuideScrollPosition, maxScrollPosition));
    
    // Calculate which programs are visible based on scroll position
    NSInteger maxVisiblePrograms = (NSInteger)(visibleHeight / (programHeight + programSpacing)) + 2; // +2 for partial visibility
    NSInteger startIndex = MAX(0, (NSInteger)(_programGuideScrollPosition / (programHeight + programSpacing)));
    NSInteger endIndex = MIN(sortedPrograms.count, startIndex + maxVisiblePrograms);
    
    for (NSInteger i = startIndex; i < endIndex; i++) {
        VLCProgram *program = sortedPrograms[i];
        
        // Calculate Y position accounting for scroll position
        // FIXED: Past programs at top, future programs at bottom (normal order)
        CGFloat baseY = i * (programHeight + programSpacing);
        CGFloat programY = 20 + baseY - _programGuideScrollPosition; // Start from top, subtract scroll
        CGRect programRect = CGRectMake(programGuideX + 10, programY, programGuideWidth - 20, programHeight);
        
        // Skip if not visible (programs outside the visible area)
        if (programY + programHeight < 20 || programY > contentStartY) {
            continue;
        }
        
        // Determine program colors based on status (matching Mac version logic)
        UIColor *bgColor, *textColor, *timeColor, *borderColor = nil;
        BOOL isPastProgram = ([adjustedNow timeIntervalSinceDate:program.endTime] > 0);
        BOOL hasCatchup = program.hasArchive;
        BOOL channelSupportsCatchup = (channel.supportsCatchup || channel.catchupDays > 0);
        
        // Check if this program is selected in EPG navigation mode (iOS/tvOS)
        BOOL isSelectedInEpg = (self.epgNavigationMode && i == self.selectedEpgProgramIndex);
        
        if (isSelectedInEpg) {
            // Selected program gets bright focus highlighting (iOS/tvOS)
            bgColor = [UIColor colorWithRed:self.customSelectionRed green:self.customSelectionGreen blue:self.customSelectionBlue alpha:0.9];
            borderColor = [UIColor colorWithRed:self.customSelectionRed * 1.2 green:self.customSelectionGreen * 1.2 blue:self.customSelectionBlue * 1.2 alpha:1.0];
            textColor = [UIColor whiteColor];
            timeColor = [UIColor colorWithRed:1.0 green:1.0 blue:0.8 alpha:1.0];
        } else if (isTimeshiftPlaying && i == timeshiftProgramIndex) {
            // Timeshift playing program gets special orange/amber highlight (like Mac)
            bgColor = [UIColor colorWithRed:0.35 green:0.25 blue:0.10 alpha:0.7];
            borderColor = [UIColor colorWithRed:1.0 green:0.6 blue:0.2 alpha:0.9];
            textColor = [UIColor whiteColor];
            timeColor = [UIColor colorWithRed:1.0 green:0.8 blue:0.4 alpha:1.0];
        } else if (i == currentProgramIndex) {
            // Current live program - blue highlight
            if (hasCatchup || channelSupportsCatchup) {
                bgColor = [UIColor colorWithRed:0.15 green:0.35 blue:0.25 alpha:0.7]; // Green-blue tint for catchup
                borderColor = [UIColor colorWithRed:0.2 green:0.8 blue:0.6 alpha:0.8];
            } else {
                bgColor = [UIColor colorWithRed:0.2 green:0.4 blue:0.8 alpha:0.6]; // Standard blue
                borderColor = [UIColor colorWithRed:0.4 green:0.7 blue:1.0 alpha:0.7];
            }
            textColor = [UIColor whiteColor];
            timeColor = [UIColor colorWithRed:1.0 green:1.0 blue:0.8 alpha:1.0];
        } else if (isPastProgram && (hasCatchup || channelSupportsCatchup)) {
            // Past program with catchup available - GREEN like Mac version
            bgColor = [UIColor colorWithRed:0.10 green:0.30 blue:0.15 alpha:0.7]; // More prominent green
            borderColor = [UIColor colorWithRed:0.2 green:0.8 blue:0.4 alpha:0.8]; // Green border like Mac
            textColor = [UIColor colorWithWhite:0.95 alpha:1.0]; // Brighter text
            timeColor = [UIColor colorWithRed:0.4 green:1.0 blue:0.6 alpha:1.0]; // Bright green time
        } else {
            // Other programs (future or past without catchup)
            bgColor = [UIColor colorWithRed:0.15 green:0.15 blue:0.2 alpha:0.6];
            textColor = [UIColor colorWithWhite:0.9 alpha:1.0];
            timeColor = [UIColor colorWithWhite:0.7 alpha:1.0];
        }
        
        // Draw program background
        [bgColor setFill];
        UIBezierPath *programPath = [UIBezierPath bezierPathWithRoundedRect:programRect cornerRadius:6];
        [programPath fill];
        
        // Draw border for special programs
        if (borderColor) {
            [borderColor setStroke];
            // Make EPG selection border thicker for better visibility
            if (isSelectedInEpg) {
                programPath.lineWidth = 3.0; // Thick border for EPG selection
            } else {
                programPath.lineWidth = 1.5; // Normal border for other states
            }
            [programPath stroke];
        }
        
        // Draw program time
        NSString *timeString = [program formattedTimeRangeWithOffset:self.epgTimeOffsetHours];
        NSDictionary *timeAttrs = @{
            NSFontAttributeName: [UIFont systemFontOfSize:11],
            NSForegroundColorAttributeName: timeColor
        };
        
        CGRect timeRect = CGRectMake(programRect.origin.x + 8, 
                                   programRect.origin.y + programHeight - 18, 
                                   programRect.size.width - 16, 
                                   14);
        [timeString drawInRect:timeRect withAttributes:timeAttrs];
        
        // Draw program title
        NSString *title = program.title ?: @"Unknown Program";
        if (title.length > 30) {
            title = [[title substringToIndex:27] stringByAppendingString:@"..."];
        }
        
        NSDictionary *titleAttrs = @{
            NSFontAttributeName: [UIFont boldSystemFontOfSize:13],
            NSForegroundColorAttributeName: textColor
        };
        
        CGRect titleRect = CGRectMake(programRect.origin.x + 8, 
                                    programRect.origin.y + 8, 
                                    programRect.size.width - 16, 
                                    18);
        [title drawInRect:titleRect withAttributes:titleAttrs];
        
        // Draw program description if available
        if (program.description && program.description.length > 0) {
            NSString *desc = program.description;
            if (desc.length > 50) {
                desc = [[desc substringToIndex:47] stringByAppendingString:@"..."];
            }
            
            NSDictionary *descAttrs = @{
                NSFontAttributeName: [UIFont systemFontOfSize:10],
                NSForegroundColorAttributeName: [UIColor colorWithWhite:0.8 alpha:1.0]
            };
            
            CGRect descRect = CGRectMake(programRect.origin.x + 8, 
                                       programRect.origin.y + 28, 
                                       programRect.size.width - 16, 
                                       14);
            [desc drawInRect:descRect withAttributes:descAttrs];
        }
        
        // Draw catchup indicator if program has archive OR channel supports catchup (like Mac version)
        if (program.hasArchive || (channelSupportsCatchup && isPastProgram)) {
            CGFloat catchupSize = 24;
            CGRect catchupRect = CGRectMake(programRect.origin.x + programRect.size.width - catchupSize - 8,
                                          programRect.origin.y + 8,
                                          catchupSize, 
                                          catchupSize);
            
            // Background circle
            UIColor *catchupBgColor = isPastProgram ? 
                [UIColor colorWithRed:0.2 green:0.8 blue:0.3 alpha:0.8] :  // Green for past programs
                [UIColor colorWithRed:0.3 green:0.6 blue:1.0 alpha:0.8];   // Blue for current programs
            
            [catchupBgColor setFill];
            UIBezierPath *catchupBg = [UIBezierPath bezierPathWithOvalInRect:catchupRect];
            [catchupBg fill];
            
            // Clock symbol
            NSDictionary *clockAttrs = @{
                NSFontAttributeName: [UIFont systemFontOfSize:14],
                NSForegroundColorAttributeName: [UIColor whiteColor]
            };
            
            [@"⏱" drawInRect:catchupRect withAttributes:clockAttrs];
        }
        
        // Draw progress bar for current program
        if (i == currentProgramIndex) {
            NSTimeInterval totalDuration = [program.endTime timeIntervalSinceDate:program.startTime];
            NSTimeInterval elapsed = [adjustedNow timeIntervalSinceDate:program.startTime];
            CGFloat progress = totalDuration > 0 ? (elapsed / totalDuration) : 0;
            progress = MAX(0, MIN(progress, 1.0));
            
            CGFloat progressBarHeight = 2;
            CGRect progressBg = CGRectMake(programRect.origin.x + 8, 
                                         programRect.origin.y + programHeight - 6, 
                                         programRect.size.width - 16, 
                                         progressBarHeight);
            
            // Background
            [[UIColor colorWithWhite:0.3 alpha:0.8] setFill];
            UIRectFill(progressBg);
            
            // Progress
            CGRect progressFill = CGRectMake(progressBg.origin.x, 
                                           progressBg.origin.y, 
                                           progressBg.size.width * progress, 
                                           progressBarHeight);
            
            UIColor *progressColor;
            if (progress < 0.25) {
                progressColor = [UIColor colorWithRed:0.2 green:0.8 blue:0.3 alpha:1.0]; // Green
            } else if (progress < 0.75) {
                progressColor = [UIColor colorWithRed:0.3 green:0.6 blue:1.0 alpha:1.0]; // Blue
            } else {
                progressColor = [UIColor colorWithRed:1.0 green:0.4 blue:0.2 alpha:1.0]; // Red
            }
            [progressColor setFill];
            UIRectFill(progressFill);
        }
    }
}

#pragma mark - Channel Data Helpers

- (VLCChannel *)getChannelAtIndex:(NSInteger)channelIndex {
    NSArray *channels = [self getChannelsForCurrentGroup];
    if (channelIndex < 0 || channelIndex >= channels.count) {
        return nil;
    }
    
    id channelObject = channels[channelIndex];
    if ([channelObject isKindOfClass:[VLCChannel class]]) {
        return (VLCChannel *)channelObject;
    }
    
    return nil;
}

#pragma mark - Theme Action Handlers (iOS)

// Old theme button handlers removed - using new dropdown system

#pragma mark - iOS Theme System

- (void)initializeThemeSystemiOS {
    NSLog(@"🎨 Initializing iOS theme system");
    
    // Set default theme values
    self.currentTheme = VLC_THEME_DARK;
    self.themeAlpha = 0.8;
    self.customThemeRed = 0.10;
    self.customThemeGreen = 0.12;
    self.customThemeBlue = 0.16;
    self.customSelectionRed = 0.2;
    self.customSelectionGreen = 0.4;
    self.customSelectionBlue = 0.9;
    
    // Set default glassmorphism values
    self.glassmorphismEnabled = YES;
    self.glassmorphismIntensity = 1.0;
    self.glassmorphismHighQuality = NO;
    
    // Initialize advanced glassmorphism controls (matching macOS defaults)
    self.glassmorphismOpacity = 0.6;
    self.glassmorphismBlurRadius = 25.0;
    self.glassmorphismBorderWidth = 1.0;
    self.glassmorphismCornerRadius = 8.0;
    self.glassmorphismIgnoreTransparency = NO;
    self.glassmorphismSandedIntensity = 0.0;
    
    // Apply default theme
    [self updateThemeColorsiOS];
    
    NSLog(@"🎨 iOS theme system initialized with default dark theme");
}

- (void)updateSelectionColorsToCurrentTheme {
    // This method applies the selection colors to all UI elements that use them
    // Similar to macOS updateSelectionColors method
    
    NSLog(@"🎯 Updating selection colors: R:%.2f G:%.2f B:%.2f", 
          self.customSelectionRed, self.customSelectionGreen, self.customSelectionBlue);
    
    // Force redraw to apply new selection colors to buttons and highlights
    [self setNeedsDisplay];
}

- (void)applyThemeiOS:(VLCColorTheme)theme {
    self.currentTheme = theme;
    [self updateThemeColorsiOS];
    [self setNeedsDisplay];
    NSLog(@"🎨 Applied iOS theme: %ld", (long)theme);
}

- (void)updateThemeColorsiOS {
    CGFloat alpha = self.themeAlpha ?: 0.8;
    
    switch (self.currentTheme) {
        case VLC_THEME_DARK:
            // Default dark theme (current colors)
            self.themeCategoryStartColor = [UIColor colorWithRed:0.08 green:0.10 blue:0.14 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.10 green:0.12 blue:0.16 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.10 green:0.12 blue:0.16 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.12 green:0.14 blue:0.18 alpha:alpha];
            break;
            
        case VLC_THEME_DARKER:
            // Even darker theme
            self.themeCategoryStartColor = [UIColor colorWithRed:0.05 green:0.05 blue:0.05 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.08 green:0.08 blue:0.08 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.08 green:0.08 blue:0.08 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.10 green:0.10 blue:0.10 alpha:alpha];
            break;
            
        case VLC_THEME_BLUE:
            // Blue accent theme
            self.themeCategoryStartColor = [UIColor colorWithRed:0.05 green:0.08 blue:0.15 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.08 green:0.12 blue:0.20 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.08 green:0.12 blue:0.20 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.10 green:0.15 blue:0.25 alpha:alpha];
            break;
            
        case VLC_THEME_GREEN:
            // Green accent theme
            self.themeCategoryStartColor = [UIColor colorWithRed:0.05 green:0.12 blue:0.08 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.08 green:0.16 blue:0.12 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.08 green:0.16 blue:0.12 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.10 green:0.20 blue:0.15 alpha:alpha];
            break;
            
        case VLC_THEME_PURPLE:
            // Purple accent theme
            self.themeCategoryStartColor = [UIColor colorWithRed:0.12 green:0.08 blue:0.15 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.16 green:0.12 blue:0.20 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.16 green:0.12 blue:0.20 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.20 green:0.15 blue:0.25 alpha:alpha];
            break;
            
        case VLC_THEME_CUSTOM:
            // Custom theme - use user-defined RGB values
            CGFloat baseR = self.customThemeRed ?: 0.10;
            CGFloat baseG = self.customThemeGreen ?: 0.12;
            CGFloat baseB = self.customThemeBlue ?: 0.16;
            
            // Create gradient variations using the base custom color
            self.themeCategoryStartColor = [UIColor colorWithRed:baseR * 0.8 green:baseG * 0.8 blue:baseB * 0.8 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:baseR green:baseG blue:baseB alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:baseR green:baseG blue:baseB alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:baseR * 1.2 green:baseG * 1.2 blue:baseB * 1.2 alpha:alpha];
            break;
            
        default:
            // Fall back to dark theme
            self.themeCategoryStartColor = [UIColor colorWithRed:0.08 green:0.10 blue:0.14 alpha:alpha];
            self.themeCategoryEndColor = [UIColor colorWithRed:0.10 green:0.12 blue:0.16 alpha:alpha];
            self.themeChannelStartColor = [UIColor colorWithRed:0.10 green:0.12 blue:0.16 alpha:alpha];
            self.themeChannelEndColor = [UIColor colorWithRed:0.12 green:0.14 blue:0.18 alpha:alpha];
            break;
    }
    
    NSLog(@"🎨 Updated iOS theme colors for theme: %ld", (long)self.currentTheme);
}

// Old custom theme control methods removed - functionality moved to setupThemeSettingsContent with new dropdown system

#pragma mark - tvOS Selection Methods

#if TARGET_OS_TV
- (void)showTVOSTimeOffsetSelection {
    NSLog(@"📺 tvOS Time offset selection");
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"EPG Time Offset"
                                                                             message:@"Select time offset for EPG data"
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    
    NSArray *timeOffsets = @[@(-12.0), @(-6.0), @(-3.0), @(-1.0), @(0.0), @(1.0), @(3.0), @(6.0), @(12.0)];
    NSArray *timeLabels = @[@"-12 hours", @"-6 hours", @"-3 hours", @"-1 hour", @"No offset", @"+1 hour", @"+3 hours", @"+6 hours", @"+12 hours"];
    
    for (NSInteger i = 0; i < timeOffsets.count; i++) {
        NSNumber *offset = timeOffsets[i];
        NSString *label = timeLabels[i];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:label style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            self.epgTimeOffsetHours = offset.doubleValue;
            [self saveSettings];
            NSLog(@"📺 Time offset set to: %.1f hours", self.epgTimeOffsetHours);
            [self setNeedsDisplay];
        }];
        
        // Mark current selection
        if (fabs(self.epgTimeOffsetHours - offset.doubleValue) < 0.1) {
            action.accessibilityLabel = [NSString stringWithFormat:@"%@ (Current)", label];
        }
        
        [alertController addAction:action];
    }
    
    // Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)showTVOSThemeSelection {
    //NSLog(@"📺 tvOS Theme selection");
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Select Theme"
                                                                             message:@"Choose a color theme"
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    
    NSArray *themeValues = @[@(VLC_THEME_DARK), @(VLC_THEME_DARKER), @(VLC_THEME_BLUE), @(VLC_THEME_GREEN), @(VLC_THEME_PURPLE), @(VLC_THEME_CUSTOM)];
    NSArray *themeNames = @[@"Dark", @"Darker", @"Blue", @"Green", @"Purple", @"Custom"];
    
    for (NSInteger i = 0; i < themeValues.count; i++) {
        VLCColorTheme theme = ((NSNumber *)themeValues[i]).integerValue;
        NSString *name = themeNames[i];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:name style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            [self applyThemeiOS:theme];
            [self saveSettings];
            //NSLog(@"📺 Theme set to: %@", name);
        }];
        
        // Mark current selection
        if (self.currentTheme == theme) {
            action.accessibilityLabel = [NSString stringWithFormat:@"%@ (Current)", name];
        }
        
        [alertController addAction:action];
    }
    
    // Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)showTVOSTransparencySelection {
    //NSLog(@"📺 tvOS Transparency selection");
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Transparency"
                                                                             message:@"Select transparency level"
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    
    NSArray *transparencyValues = @[@(0.3), @(0.5), @(0.7), @(0.8), @(0.9), @(1.0)];
    NSArray *transparencyLabels = @[@"30%", @"50%", @"70%", @"80%", @"90%", @"100% (Opaque)"];
    
    for (NSInteger i = 0; i < transparencyValues.count; i++) {
        NSNumber *transparency = transparencyValues[i];
        NSString *label = transparencyLabels[i];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:label style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            self.themeAlpha = transparency.doubleValue;
            [self updateThemeColorsiOS];
            [self saveSettings];
            //NSLog(@"📺 Transparency set to: %.0f%%", transparency.doubleValue * 100);
            [self setNeedsDisplay];
        }];
        
        // Mark current selection
        if (fabs((self.themeAlpha ?: 0.8) - transparency.doubleValue) < 0.05) {
            action.accessibilityLabel = [NSString stringWithFormat:@"%@ (Current)", label];
        }
        
        [alertController addAction:action];
    }
    
    // Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)showTVOSSelectionColorSelection:(NSString *)colorName component:(NSInteger)component {
    //NSLog(@"📺 tvOS Selection color selection: %@", colorName);
    
    NSString *title = [NSString stringWithFormat:@"Selection %@", colorName];
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title
                                                                             message:@"Select color intensity"
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    
    NSArray *colorValues = @[@(0.0), @(0.1), @(0.2), @(0.3), @(0.4), @(0.5), @(0.6), @(0.7), @(0.8), @(0.9), @(1.0)];
    
    for (NSNumber *value in colorValues) {
        NSString *label = [NSString stringWithFormat:@"%.0f%%", value.doubleValue * 100];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:label style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            switch (component) {
                case 0: // Red
                    self.customSelectionRed = value.doubleValue;
                    break;
                case 1: // Green
                    self.customSelectionGreen = value.doubleValue;
                    break;
                case 2: // Blue
                    self.customSelectionBlue = value.doubleValue;
                    break;
            }
            [self updateSelectionColorsToCurrentTheme];
            [self saveSettings];
            //NSLog(@"📺 Selection %@ set to: %.0f%%", colorName, value.doubleValue * 100);
        }];
        
        // Mark current selection
        CGFloat currentValue = 0;
        switch (component) {
            case 0: currentValue = self.customSelectionRed ?: 0.2; break;
            case 1: currentValue = self.customSelectionGreen ?: 0.4; break;
            case 2: currentValue = self.customSelectionBlue ?: 0.9; break;
        }
        
        if (fabs(currentValue - value.doubleValue) < 0.05) {
            action.accessibilityLabel = [NSString stringWithFormat:@"%@ (Current)", label];
        }
        
        [alertController addAction:action];
    }
    
    // Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)toggleTVOSGlassmorphism {
    self.glassmorphismEnabled = !self.glassmorphismEnabled;
    [self saveSettings];
    //NSLog(@"📺 Glassmorphism %@", self.glassmorphismEnabled ? @"enabled" : @"disabled");
    [self setNeedsDisplay];
}

- (void)showTVOSGlassmorphismIntensitySelection {
    //NSLog(@"📺 tvOS Glassmorphism intensity selection");
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Glassmorphism Intensity"
                                                                             message:@"Select glassmorphism effect intensity"
                                                                      preferredStyle:UIAlertControllerStyleActionSheet];
    
    NSArray *intensityValues = @[@(0.0), @(0.25), @(0.5), @(0.75), @(1.0), @(1.25), @(1.5), @(2.0)];
    NSArray *intensityLabels = @[@"Off", @"Light", @"Medium", @"Strong", @"Full", @"Enhanced", @"Maximum", @"Extreme"];
    
    for (NSInteger i = 0; i < intensityValues.count; i++) {
        NSNumber *intensity = intensityValues[i];
        NSString *label = intensityLabels[i];
        
        UIAlertAction *action = [UIAlertAction actionWithTitle:label style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            self.glassmorphismIntensity = intensity.doubleValue;
            if (intensity.doubleValue > 0) {
                self.glassmorphismEnabled = YES;
            }
            [self saveSettings];
            //NSLog(@"📺 Glassmorphism intensity set to: %.2f", self.glassmorphismIntensity);
            [self setNeedsDisplay];
        }];
        
        // Mark current selection
        if (fabs((self.glassmorphismIntensity ?: 1.0) - intensity.doubleValue) < 0.1) {
            action.accessibilityLabel = [NSString stringWithFormat:@"%@ (Current)", label];
        }
        
        [alertController addAction:action];
    }
    
    // Cancel action
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)resetTVOSThemeSettings {
    //NSLog(@"📺 tvOS Reset theme settings");
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Reset Theme Settings"
                                                                             message:@"This will reset all theme settings to defaults"
                                                                      preferredStyle:UIAlertControllerStyleAlert];
    
    UIAlertAction *resetAction = [UIAlertAction actionWithTitle:@"Reset" style:UIAlertActionStyleDestructive handler:^(UIAlertAction *action) {
        // Reset to defaults
        [self initializeThemeSystemiOS];
        [self saveSettings];
        //NSLog(@"📺 Theme settings reset to defaults");
        [self setNeedsDisplay];
    }];
    
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:nil];
    
    [alertController addAction:resetAction];
    [alertController addAction:cancelAction];
    
    // Present the alert
    UIViewController *topViewController = [self topViewController];
    if (topViewController) {
        [topViewController presentViewController:alertController animated:YES completion:nil];
    }
}

- (void)drawTVOSThemeSettings:(CGRect)rect x:(CGFloat)x width:(CGFloat)width {
    CGFloat padding = 20;
    CGFloat startY = rect.size.height - 80;
    CGFloat lineHeight = 25;
    CGFloat controlHeight = 35;
    CGFloat spacing = 15;
    
    // Title
    NSDictionary *titleAttrs = @{
        NSFontAttributeName: [UIFont boldSystemFontOfSize:18],
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };
    
    CGRect titleRect = CGRectMake(x + padding, startY, width - (padding * 2), lineHeight);
    [@"Theme Settings" drawInRect:titleRect withAttributes:titleAttrs];
    
    CGFloat currentY = startY - 50;
    NSInteger controlIndex = 0;
    
    // Control 0: Theme Selection
    NSString *currentThemeName = [self getCurrentThemeDisplayTextiOS];
    [self drawTVOSControl:controlIndex
                    label:@"Theme:"
                    value:currentThemeName
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 1: Transparency
    NSString *transparencyText = [NSString stringWithFormat:@"%.0f%%", (self.themeAlpha ?: 0.8) * 100];
    [self drawTVOSControl:controlIndex
                    label:@"Transparency:"
                    value:transparencyText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 2: Selection Red
    NSString *redText = [NSString stringWithFormat:@"%.0f%%", (self.customSelectionRed ?: 0.2) * 100];
    [self drawTVOSControl:controlIndex
                    label:@"Selection Red:"
                    value:redText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 3: Selection Green
    NSString *greenText = [NSString stringWithFormat:@"%.0f%%", (self.customSelectionGreen ?: 0.4) * 100];
    [self drawTVOSControl:controlIndex
                    label:@"Selection Green:"
                    value:greenText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 4: Selection Blue
    NSString *blueText = [NSString stringWithFormat:@"%.0f%%", (self.customSelectionBlue ?: 0.9) * 100];
    [self drawTVOSControl:controlIndex
                    label:@"Selection Blue:"
                    value:blueText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 5: Glassmorphism Toggle
    NSString *glassmorphismText = self.glassmorphismEnabled ? @"Enabled" : @"Disabled";
    [self drawTVOSControl:controlIndex
                    label:@"Glassmorphism:"
                    value:glassmorphismText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 6: Glassmorphism Intensity
    NSString *intensityText = [NSString stringWithFormat:@"%.1f", self.glassmorphismIntensity ?: 1.0];
    [self drawTVOSControl:controlIndex
                    label:@"Intensity:"
                    value:intensityText
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
    currentY -= controlHeight + spacing;
    controlIndex++;
    
    // Control 7: Reset Button
    [self drawTVOSControl:controlIndex
                    label:@"Reset to Defaults"
                    value:@"Press to reset"
                    rect:CGRectMake(x + padding, currentY, width - (padding * 2), controlHeight)
                 selected:(_tvosNavigationArea == 3 && _tvosSelectedSettingsControl == controlIndex)];
}
#endif

#pragma mark - tvOS EPG Navigation Helpers

- (void)initializeEpgNavigation {
    VLCChannel *channel = [self getChannelAtIndex:_selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) return;
    
    // Enable EPG navigation mode
    self.epgNavigationMode = YES;
    
    // Find current program index to start selection there
    NSDate *now = [NSDate date];
    NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600;
    NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
    
    // Sort programs by start time
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    // Find current program
    NSInteger currentProgramIndex = -1;
    for (NSInteger i = 0; i < sortedPrograms.count; i++) {
        VLCProgram *program = sortedPrograms[i];
        if ([adjustedNow timeIntervalSinceDate:program.startTime] >= 0 && 
            [adjustedNow timeIntervalSinceDate:program.endTime] < 0) {
            currentProgramIndex = i;
            break;
        }
    }
    
    // Start at current program, or first program if no current program found
    self.selectedEpgProgramIndex = (currentProgramIndex >= 0) ? currentProgramIndex : 0;
    
    NSLog(@"📺 [EPG-INIT] Started EPG navigation at program index: %ld (current program: %ld)", 
          (long)self.selectedEpgProgramIndex, (long)currentProgramIndex);
    
    // Scroll to show the selected program
    [self scrollToSelectedEpgProgram];
    [self setNeedsDisplay];
}

- (void)scrollToSelectedEpgProgram {
    VLCChannel *channel = [self getChannelAtIndex:_selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) return;
    
    CGFloat programHeight = 60;
    CGFloat programSpacing = 5;
    CGFloat visibleHeight = self.bounds.size.height - 110; // Account for margins
    
    // Calculate position of selected program
    CGFloat selectedProgramY = self.selectedEpgProgramIndex * (programHeight + programSpacing);
    
    // Calculate scroll position to center the selected program
    CGFloat targetScrollPosition = selectedProgramY - (visibleHeight / 2) + (programHeight / 2);
    
    // Calculate max scroll position
    CGFloat totalContentHeight = channel.programs.count * (programHeight + programSpacing);
    CGFloat maxScrollPosition = MAX(0, totalContentHeight - visibleHeight);
    
    // Clamp scroll position
    _programGuideScrollPosition = MAX(0, MIN(targetScrollPosition, maxScrollPosition));
    
    NSLog(@"📺 [EPG-SCROLL] Scrolled to program %ld, scroll position: %.1f", 
          (long)self.selectedEpgProgramIndex, _programGuideScrollPosition);
}

- (void)handleTVOSEpgProgramSelection {
    if (!self.epgNavigationMode) return;
    
    VLCChannel *channel = [self getChannelAtIndex:_selectedChannelIndex];
    if (!channel || !channel.programs || channel.programs.count == 0) return;
    
    if (self.selectedEpgProgramIndex < 0 || self.selectedEpgProgramIndex >= channel.programs.count) return;
    
    // Sort programs by start time to match the display order
    NSArray *sortedPrograms = [channel.programs sortedArrayUsingComparator:^NSComparisonResult(VLCProgram *a, VLCProgram *b) {
        return [a.startTime compare:b.startTime];
    }];
    
    VLCProgram *selectedProgram = sortedPrograms[self.selectedEpgProgramIndex];
    
    NSLog(@"📺 [EPG-SELECT] Selected program: %@ at %@", 
          selectedProgram.title, selectedProgram.startTime);
    
    // Check if this is a past program with catchup available
    NSDate *now = [NSDate date];
    NSTimeInterval offsetSeconds = -self.epgTimeOffsetHours * 3600;
    NSDate *adjustedNow = [now dateByAddingTimeInterval:offsetSeconds];
    BOOL isPastProgram = ([adjustedNow timeIntervalSinceDate:selectedProgram.endTime] > 0);
    BOOL hasCatchup = (selectedProgram.hasArchive || channel.supportsCatchup || channel.catchupDays > 0);
    
    if (isPastProgram && hasCatchup) {
        // TODO: Implement timeshift playback to the selected program
        NSLog(@"📺 [EPG-SELECT] ⏱ Starting timeshift playback for past program with catchup");
        // For now, just play the channel - timeshift implementation would go here
        [self playChannelAtIndex:_selectedChannelIndex];
    } else if (!isPastProgram) {
        // Future program - just play the channel normally  
        NSLog(@"📺 [EPG-SELECT] ▶️ Playing channel for future/current program");
        [self playChannelAtIndex:_selectedChannelIndex];
    } else {
        // Past program without catchup
        NSLog(@"📺 [EPG-SELECT] ❌ Past program without catchup - playing current channel");
        [self playChannelAtIndex:_selectedChannelIndex];
    }
    
    // Hide menu after selection
    _isChannelListVisible = NO;
    self.epgNavigationMode = NO;
    [self setNeedsDisplay];
}

// Helper method to check if a group has channels with catch-up functionality
- (BOOL)groupHasCatchupChannels:(NSString *)groupName {
    if (!groupName) return NO;
    
    NSArray *channelsInGroup = [self.channelsByGroup objectForKey:groupName];
    if (!channelsInGroup) return NO;
    
    for (VLCChannel *channel in channelsInGroup) {
        // Check both EPG-based catch-up and channel-level catch-up
        if (channel.supportsCatchup || channel.catchupDays > 0) {
            return YES; // Channel-level catch-up support
        }
        
        if (channel.programs && channel.programs.count > 0) {
            for (VLCProgram *program in channel.programs) {
                if (program.hasArchive) {
                    return YES; // EPG-based catch-up support
                }
            }
        }
    }
    
    return NO;
}

#pragma mark - Timeshift/Catchup Support (iOS/tvOS)

// Auto-fetch catch-up info when loading M3U (called from M3U loading)
- (void)autoFetchCatchupInfo {
    NSLog(@"🔄 autoFetchCatchupInfo called with %lu channels", (unsigned long)self.channels.count);
    
    // Only fetch if we have channels
    if (self.channels.count > 0) {
        // Check if any channel already has catch-up info
        BOOL hasCatchupInfo = NO;
        NSInteger catchupChannels = 0;
        
        for (VLCChannel *channel in self.channels) {
            if (channel.supportsCatchup && channel.catchupDays > 0) {
                hasCatchupInfo = YES;
                catchupChannels++;
            }
        }
        
        NSLog(@"🔄 Found %ld channels with existing catchup info (hasCatchupInfo=%d)", 
              (long)catchupChannels, hasCatchupInfo);
        
        // Calculate percentage of channels with catchup info
        float catchupPercentage = (float)catchupChannels / (float)self.channels.count;
        
        if (!hasCatchupInfo || catchupPercentage < 0.1) { // Less than 10% have catchup info
            NSLog(@"🔄 Insufficient catchup info (%.1f%% of channels) - calling fetchCatchupInfoFromAPI", 
                  catchupPercentage * 100);
            [self fetchCatchupInfoFromAPI];
        } else {
            NSLog(@"🔄 Sufficient catchup info found (%.1f%% of channels) - skipping API fetch", 
                  catchupPercentage * 100);
        }
    } else {
        NSLog(@"❌ No channels loaded - cannot fetch catchup info");
    }
}

// Construct API URL for live streams catch-up info
- (NSString *)constructLiveStreamsApiUrl {
    if (!self.m3uFilePath) return nil;
    
    // Parse server information from M3U URL
    NSURL *m3uURL = [NSURL URLWithString:self.m3uFilePath];
    if (!m3uURL) return nil;
    
    NSString *scheme = [m3uURL scheme];
    NSString *host = [m3uURL host];
    NSNumber *port = [m3uURL port];
    NSString *portString = port ? [NSString stringWithFormat:@":%@", port] : @"";
    
    // Extract username and password (reuse existing logic)
    NSString *username = @"";
    NSString *password = @"";
    
    // First try to get from query parameters
    NSString *query = [m3uURL query];
    if (query) {
        NSArray *queryItems = [query componentsSeparatedByString:@"&"];
        for (NSString *item in queryItems) {
            NSArray *keyValue = [item componentsSeparatedByString:@"="];
            if (keyValue.count == 2) {
                NSString *key = keyValue[0];
                NSString *value = keyValue[1];
                
                if ([key isEqualToString:@"username"]) {
                    username = value;
                } else if ([key isEqualToString:@"password"]) {
                    password = value;
                }
            }
        }
    }
    
    // If not found in query, try path components
    if (username.length == 0 || password.length == 0) {
        NSString *path = [m3uURL path];
        NSArray *pathComponents = [path pathComponents];
        
        // Look for typical username/password segments in the URL path
        for (NSInteger i = 0; i < pathComponents.count - 1; i++) {
            // Username is often after "get.php" or similar pattern
            if ([pathComponents[i] hasSuffix:@".php"] && i + 1 < pathComponents.count) {
                username = pathComponents[i + 1];
                
                // Password typically follows the username
                if (i + 2 < pathComponents.count) {
                    password = pathComponents[i + 2];
                    break;
                }
            }
        }
    }
    
    // Construct the API URL for live streams
    NSString *apiUrl = [NSString stringWithFormat:@"%@://%@%@/player_api.php?username=%@&password=%@&action=get_live_streams",
                        scheme, host, portString, username, password];
    
    NSLog(@"🔄 Constructed live streams API URL: %@", apiUrl);
    return apiUrl;
}

// Fetch catch-up information for all channels from the API
- (void)fetchCatchupInfoFromAPI {
    NSString *apiUrl = [self constructLiveStreamsApiUrl];
    if (!apiUrl) {
        NSLog(@"❌ Failed to construct live streams API URL");
        return;
    }
    
    NSLog(@"🔄 Fetching catch-up info from API: %@", apiUrl);
    
    // Create the URL request
    NSURL *url = [NSURL URLWithString:apiUrl];
    NSURLRequest *request = [NSURLRequest requestWithURL:url 
                                             cachePolicy:NSURLRequestUseProtocolCachePolicy 
                                         timeoutInterval:30.0];
    
    // Create and begin an asynchronous data task
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request 
                                               completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        if (error || !data) {
            NSLog(@"❌ Error fetching catch-up info from API: %@", error);
            return;
        }
        
        NSLog(@"✅ Received catch-up data (%lu bytes)", (unsigned long)[data length]);
        
        // Parse the JSON response
        NSError *jsonError = nil;
        NSArray *channelsArray = [NSJSONSerialization JSONObjectWithData:data 
                                                                  options:0 
                                                                    error:&jsonError];
        
        if (jsonError || !channelsArray || ![channelsArray isKindOfClass:[NSArray class]]) {
            NSLog(@"❌ Error parsing catch-up info JSON: %@", jsonError);
            return;
        }
        
        NSLog(@"✅ Successfully parsed %lu channels from API", (unsigned long)[channelsArray count]);
        
        // Process the catch-up information on the main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            [self processCatchupInfoFromAPI:channelsArray];
        });
    }];
    
    // Start the data task
    [dataTask resume];
}

// Process catch-up information and update channel properties
- (void)processCatchupInfoFromAPI:(NSArray *)apiChannels {
    NSLog(@"🔄 Processing catch-up info for %lu API channels", (unsigned long)[apiChannels count]);
    
    // Create a mapping of stream_id to catch-up info for fast lookup
    NSMutableDictionary *catchupInfo = [NSMutableDictionary dictionary];
    
    for (NSDictionary *apiChannel in apiChannels) {
        if (![apiChannel isKindOfClass:[NSDictionary class]]) continue;
        
        NSNumber *streamId = [apiChannel objectForKey:@"stream_id"];
        NSNumber *tvArchive = [apiChannel objectForKey:@"tv_archive"];
        NSString *tvArchiveDuration = [apiChannel objectForKey:@"tv_archive_duration"];
        NSString *channelName = [apiChannel objectForKey:@"name"];
        
        if (streamId) {
            NSDictionary *info = @{
                @"tv_archive": tvArchive ? tvArchive : @(0),
                @"tv_archive_duration": tvArchiveDuration ? tvArchiveDuration : @"0",
                @"name": channelName ? channelName : @""
            };
            [catchupInfo setObject:info forKey:[streamId stringValue]];
        }
    }
    
    NSLog(@"🔄 Created catch-up lookup table with %lu entries", (unsigned long)[catchupInfo count]);
    
    // Update our channels with catch-up information
    NSInteger updatedChannels = 0;
    for (VLCChannel *channel in self.channels) {
        // Extract stream_id from channel URL
        NSString *streamId = [self extractStreamIdFromChannelUrl:channel.url];
        if (!streamId) continue;
        
        NSDictionary *info = [catchupInfo objectForKey:streamId];
        if (info) {
            NSNumber *tvArchive = [info objectForKey:@"tv_archive"];
            NSString *tvArchiveDuration = [info objectForKey:@"tv_archive_duration"];
            
            // Update channel catch-up properties
            channel.supportsCatchup = [tvArchive boolValue];
            channel.catchupDays = [tvArchiveDuration integerValue];
            
            if (channel.supportsCatchup) {
                channel.catchupSource = @"default";
                channel.catchupTemplate = @""; // Will be constructed dynamically
                updatedChannels++;
                NSLog(@"✅ Updated catch-up for channel '%@': %d days (API)", channel.name, (int)channel.catchupDays);
            }
        }
    }
    
    NSLog(@"🔄 Updated catch-up info for %ld channels", (long)updatedChannels);
    
    // Log final summary 
    NSInteger finalCatchupChannels = 0;
    for (VLCChannel *channel in self.channels) {
        if (channel.supportsCatchup || channel.catchupDays > 0) {
            finalCatchupChannels++;
        }
    }
    NSLog(@"🔧 [TIMESHIFT-API-SUMMARY] Now have %ld channels with timeshift support after API fetch", (long)finalCatchupChannels);
    
    // Save the updated channel information to cache (including catch-up properties)
    if (updatedChannels > 0 && self.m3uFilePath) {
        NSLog(@"🔄 Saving updated catch-up information to cache...");
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [self saveChannelsToCache:self.m3uFilePath];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                NSLog(@"✅ Successfully saved catch-up information to cache");
            });
        });
    }
    
    // Trigger UI update to show catch-up indicators
    [self setNeedsDisplay];
}

// Extract stream_id from channel URL
- (NSString *)extractStreamIdFromChannelUrl:(NSString *)urlString {
    if (!urlString) return nil;
    
    // Pattern for Xtream Codes URLs: .../username/password/stream_id or .../stream_id.m3u8
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"/(\\d+)(?:\\.m3u8)?/?$" 
                                                                           options:0 
                                                                             error:&error];
    
    if (!error) {
        NSArray *matches = [regex matchesInString:urlString options:0 range:NSMakeRange(0, [urlString length])];
        if (matches.count > 0) {
            NSTextCheckingResult *match = [matches lastObject];
            if (match.numberOfRanges > 1) {
                NSRange idRange = [match rangeAtIndex:1];
                NSString *streamId = [urlString substringWithRange:idRange];
                return streamId;
            }
        }
    }
    
    return nil;
}

@end

#endif // TARGET_OS_IOS || TARGET_OS_TV 
